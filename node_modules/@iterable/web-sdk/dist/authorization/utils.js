(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "buffer", "axios"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("buffer"), require("axios"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.buffer, global.axios);
    global.utils = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _buffer, _axios) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.getEpochExpiryTimeInMS = _exports.getEpochDifferenceInMS = _exports.cancelAxiosRequestAndMakeFetch = void 0;
  _axios = _interopRequireDefault(_axios);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  const getEpochExpiryTimeInMS = jwt => {
    /** @thanks https://stackoverflow.com/a/38552302/7455960  */
    try {
      var _jwt$split, _JSON$parse;

      const base64Url = (_jwt$split = jwt.split('.')) === null || _jwt$split === void 0 ? void 0 : _jwt$split[1];
      const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
      const jsonPayload = decodeURIComponent(_buffer.Buffer.from(base64, 'base64').toString().split('').map(character => '%' + ('00' + character.charCodeAt(0).toString(16)).slice(-2)).join(''));
      const expTime = (_JSON$parse = JSON.parse(jsonPayload)) === null || _JSON$parse === void 0 ? void 0 : _JSON$parse.exp;
      return expTime < 10000000000 ? expTime * 1000 : expTime;
    } catch {
      return 0;
    }
  };
  /*
    take two epoch timestamps and diff them and return them in MS.
    Also tries to convert seconds to MS if needed (since some server languages like 
    python deal with time in seconds).
  */


  _exports.getEpochExpiryTimeInMS = getEpochExpiryTimeInMS;

  const getEpochDifferenceInMS = (epochNow, epochFuture) => {
    let parsedNow = epochNow;
    let parsedFuture = epochFuture;

    if (epochNow < 10000000000) {
      /* convert to MS if in seconds */
      parsedNow = epochNow * 1000;
    }

    if (epochFuture < 10000000000) {
      /* convert to MS if in seconds */
      parsedFuture = epochFuture * 1000;
    }

    return parsedFuture - parsedNow;
  };

  _exports.getEpochDifferenceInMS = getEpochDifferenceInMS;

  const cancelAxiosRequestAndMakeFetch = (config, {
    email,
    userID
  }, jwtToken, authToken) => {
    /* 
      send fetch request instead solely so we can use the "keepalive" flag.
      This is used purely for one use-case only - when the user clicks a link
      that is going to navigate the browser tab to a new page/site and we need
      to still call POST /trackInAppClick.
       Normally, since the page is going somewhere new, the browser would just 
      navigate away and cancel any in-flight requests and not fulfill them, 
      but with the fetch API's "keepalive" flag, it will continue the request 
      without blocking the main thread.
       We can't do this with Axios because it's built upon XHR and that 
      doesn't support "keepalive" so we fall back to the fetch API
    */
    const additionalData = email ? {
      email: email
    } : {
      userId: userID
    };
    fetch(`${config.baseURL}${config.url}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Api-Key': authToken,
        Authorization: `Bearer ${jwtToken}`
      },
      body: JSON.stringify(_objectSpread(_objectSpread({}, config === null || config === void 0 ? void 0 : config.data), additionalData) || {}),
      keepalive: true
    }).catch();
    /* cancel the axios request */

    return _objectSpread(_objectSpread({}, config), {}, {
      cancelToken: new _axios.default.CancelToken(cancel => {
        cancel('Cancel repeated request');
      })
    });
  };

  _exports.cancelAxiosRequestAndMakeFetch = cancelAxiosRequestAndMakeFetch;
});