var rudderanalytics = (function (exports) {
  'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }

    return _get.apply(this, arguments);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = it.call(o);
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace (n) {
  	return n && n['default'] || n;
  }

  var componentEmitter = createCommonjsModule(function (module) {
    /**
     * Expose `Emitter`.
     */
    {
      module.exports = Emitter;
    }
    /**
     * Initialize a new `Emitter`.
     *
     * @api public
     */


    function Emitter(obj) {
      if (obj) return mixin(obj);
    }
    /**
     * Mixin the emitter properties.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */

    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }

      return obj;
    }
    /**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */


    Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
      return this;
    };
    /**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */


    Emitter.prototype.once = function (event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }

      on.fn = fn;
      this.on(event, on);
      return this;
    };
    /**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */


    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
      this._callbacks = this._callbacks || {}; // all

      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      } // specific event


      var callbacks = this._callbacks['$' + event];
      if (!callbacks) return this; // remove all handlers

      if (1 == arguments.length) {
        delete this._callbacks['$' + event];
        return this;
      } // remove specific handler


      var cb;

      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];

        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      } // Remove event specific arrays for event types that no
      // one is subscribed for to avoid memory leak.


      if (callbacks.length === 0) {
        delete this._callbacks['$' + event];
      }

      return this;
    };
    /**
     * Emit `event` with the given args.
     *
     * @param {String} event
     * @param {Mixed} ...
     * @return {Emitter}
     */


    Emitter.prototype.emit = function (event) {
      this._callbacks = this._callbacks || {};
      var args = new Array(arguments.length - 1),
          callbacks = this._callbacks['$' + event];

      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }

      if (callbacks) {
        callbacks = callbacks.slice(0);

        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }

      return this;
    };
    /**
     * Return array of callbacks for `event`.
     *
     * @param {String} event
     * @return {Array}
     * @api public
     */


    Emitter.prototype.listeners = function (event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks['$' + event] || [];
    };
    /**
     * Check if this emitter has `event` handlers.
     *
     * @param {String} event
     * @return {Boolean}
     * @api public
     */


    Emitter.prototype.hasListeners = function (event) {
      return !!this.listeners(event).length;
    };
  });

  var after_1 = after;

  function after(count, callback, err_cb) {
    var bail = false;
    err_cb = err_cb || noop;
    proxy.count = count;
    return count === 0 ? callback() : proxy;

    function proxy(err, result) {
      if (proxy.count <= 0) {
        throw new Error('after called too many times');
      }

      --proxy.count; // after first error, rest are passed to err_cb

      if (err) {
        bail = true;
        callback(err); // future error callbacks will go to error handler

        callback = err_cb;
      } else if (proxy.count === 0 && !bail) {
        callback(null, result);
      }
    }
  }

  function noop() {}

  var trim_1 = createCommonjsModule(function (module, exports) {
    exports = module.exports = trim;

    function trim(str) {
      if (str.trim) return str.trim();
      return exports.right(exports.left(str));
    }

    exports.left = function (str) {
      if (str.trimLeft) return str.trimLeft();
      return str.replace(/^\s\s*/, '');
    };

    exports.right = function (str) {
      if (str.trimRight) return str.trimRight();
      var whitespace_pattern = /\s/,
          i = str.length;

      while (whitespace_pattern.test(str.charAt(--i))) {
      }

      return str.slice(0, i + 1);
    };
  });
  var trim_2 = trim_1.left;
  var trim_3 = trim_1.right;

  /**
   * toString ref.
   */
  var toString = Object.prototype.toString;
  /**
   * Return the type of `val`.
   *
   * @param {Mixed} val
   * @return {String}
   * @api public
   */

  var componentType = function componentType(val) {
    switch (toString.call(val)) {
      case '[object Date]':
        return 'date';

      case '[object RegExp]':
        return 'regexp';

      case '[object Arguments]':
        return 'arguments';

      case '[object Array]':
        return 'array';

      case '[object Error]':
        return 'error';
    }

    if (val === null) return 'null';
    if (val === undefined) return 'undefined';
    if (val !== val) return 'nan';
    if (val && val.nodeType === 1) return 'element';
    val = val.valueOf ? val.valueOf() : Object.prototype.valueOf.apply(val);
    return _typeof(val);
  };

  /**
   * Module dependencies.
   */

  var pattern = /(\w+)\[(\d+)\]/;
  /**
   * Safely encode the given string
   * 
   * @param {String} str
   * @return {String}
   * @api private
   */

  var encode = function encode(str) {
    try {
      return encodeURIComponent(str);
    } catch (e) {
      return str;
    }
  };
  /**
   * Safely decode the string
   * 
   * @param {String} str
   * @return {String}
   * @api private
   */


  var decode = function decode(str) {
    try {
      return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
      return str;
    }
  };
  /**
   * Parse the given query `str`.
   *
   * @param {String} str
   * @return {Object}
   * @api public
   */


  var parse = function parse(str) {
    if ('string' != typeof str) return {};
    str = trim_1(str);
    if ('' == str) return {};
    if ('?' == str.charAt(0)) str = str.slice(1);
    var obj = {};
    var pairs = str.split('&');

    for (var i = 0; i < pairs.length; i++) {
      var parts = pairs[i].split('=');
      var key = decode(parts[0]);
      var m;

      if (m = pattern.exec(key)) {
        obj[m[1]] = obj[m[1]] || [];
        obj[m[1]][m[2]] = decode(parts[1]);
        continue;
      }

      obj[parts[0]] = null == parts[1] ? '' : decode(parts[1]);
    }

    return obj;
  };
  /**
   * Stringify the given `obj`.
   *
   * @param {Object} obj
   * @return {String}
   * @api public
   */


  var stringify = function stringify(obj) {
    if (!obj) return '';
    var pairs = [];

    for (var key in obj) {
      var value = obj[key];

      if ('array' == componentType(value)) {
        for (var i = 0; i < value.length; ++i) {
          pairs.push(encode(key + '[' + i + ']') + '=' + encode(value[i]));
        }

        continue;
      }

      pairs.push(encode(key) + '=' + encode(obj[key]));
    }

    return pairs.join('&');
  };

  var componentQuerystring = {
    parse: parse,
    stringify: stringify
  };

  var lodash_merge = createCommonjsModule(function (module, exports) {
    /**
     * Lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;
    /** Used to stand-in for `undefined` hash values. */

    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    /** Used to detect hot functions by number of calls within a span of milliseconds. */

    var HOT_COUNT = 800,
        HOT_SPAN = 16;
    /** Used as references for various `Number` constants. */

    var MAX_SAFE_INTEGER = 9007199254740991;
    /** `Object#toString` result references. */

    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        asyncTag = '[object AsyncFunction]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        nullTag = '[object Null]',
        objectTag = '[object Object]',
        proxyTag = '[object Proxy]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        undefinedTag = '[object Undefined]',
        weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */

    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    /** Used to detect host constructors (Safari). */

    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    /** Used to detect unsigned integer values. */

    var reIsUint = /^(?:0|[1-9]\d*)$/;
    /** Used to identify `toStringTag` values of typed arrays. */

    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    /** Detect free variable `global` from Node.js. */

    var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    /** Detect free variable `self`. */

    var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */

    var root = freeGlobal || freeSelf || Function('return this')();
    /** Detect free variable `exports`. */

    var freeExports =  exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */

    var freeProcess = moduleExports && freeGlobal.process;
    /** Used to access faster Node.js helpers. */

    var nodeUtil = function () {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        } // Legacy `process.binding('util')` for Node.js < 10.


        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();
    /* Node.js helper references. */


    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    /**
     * A faster alternative to `Function#apply`, this function invokes `func`
     * with the `this` binding of `thisArg` and the arguments of `args`.
     *
     * @private
     * @param {Function} func The function to invoke.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} args The arguments to invoke `func` with.
     * @returns {*} Returns the result of `func`.
     */

    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);

        case 1:
          return func.call(thisArg, args[0]);

        case 2:
          return func.call(thisArg, args[0], args[1]);

        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }

      return func.apply(thisArg, args);
    }
    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */


    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }

      return result;
    }
    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */


    function baseUnary(func) {
      return function (value) {
        return func(value);
      };
    }
    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */


    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }
    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */


    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }
    /** Used for built-in method references. */


    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;
    /** Used to detect overreaching core-js shims. */

    var coreJsData = root['__core-js_shared__'];
    /** Used to resolve the decompiled source of functions. */

    var funcToString = funcProto.toString;
    /** Used to check objects for own properties. */

    var hasOwnProperty = objectProto.hasOwnProperty;
    /** Used to detect methods masquerading as native. */

    var maskSrcKey = function () {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? 'Symbol(src)_1.' + uid : '';
    }();
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */


    var nativeObjectToString = objectProto.toString;
    /** Used to infer the `Object` constructor. */

    var objectCtorString = funcToString.call(Object);
    /** Used to detect if a method is native. */

    var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
    /** Built-in value references. */

    var Buffer = moduleExports ? root.Buffer : undefined,
        _Symbol = root.Symbol,
        Uint8Array = root.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

    var defineProperty = function () {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }();
    /* Built-in method references for those with the same name as other `lodash` methods. */


    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeMax = Math.max,
        nativeNow = Date.now;
    /* Built-in method references that are verified to be native. */

    var Map = getNative(root, 'Map'),
        nativeCreate = getNative(Object, 'create');
    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */

    var baseCreate = function () {
      function object() {}

      return function (proto) {
        if (!isObject(proto)) {
          return {};
        }

        if (objectCreate) {
          return objectCreate(proto);
        }

        object.prototype = proto;
        var result = new object();
        object.prototype = undefined;
        return result;
      };
    }();
    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */


    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */


    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function hashGet(key) {
      var data = this.__data__;

      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }

      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }
    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
    }
    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */


    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
      return this;
    } // Add methods to `Hash`.


    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */


    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }

      var lastIndex = data.length - 1;

      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }

      --this.size;
      return true;
    }
    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);
      return index < 0 ? undefined : data[index][1];
    }
    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */


    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }

      return this;
    } // Add methods to `ListCache`.


    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */


    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash(),
        'map': new (Map || ListCache)(),
        'string': new Hash()
      };
    }
    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */


    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    } // Add methods to `MapCache`.


    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */


    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);
      this.size = data.size;
      return result;
    }
    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function stackGet(key) {
      return this.__data__.get(key);
    }
    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function stackHas(key) {
      return this.__data__.has(key);
    }
    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */


    function stackSet(key, value) {
      var data = this.__data__;

      if (data instanceof ListCache) {
        var pairs = data.__data__;

        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }

        data = this.__data__ = new MapCache(pairs);
      }

      data.set(key, value);
      this.size = data.size;
      return this;
    } // Add methods to `Stack`.


    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */

    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
        key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }

      return result;
    }
    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */


    function assignMergeValue(object, key, value) {
      if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */


    function assignValue(object, key, value) {
      var objValue = object[key];

      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */


    function assocIndexOf(array, key) {
      var length = array.length;

      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }

      return -1;
    }
    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */


    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }
    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */


    var baseFor = createBaseFor();
    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */

    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }

      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */


    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */


    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }

      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */


    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */


    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }

      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }

      return result;
    }
    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */


    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }

      baseFor(source, function (srcValue, key) {
        stack || (stack = new Stack());

        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }

          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */


    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }

      var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;

        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;

          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }

      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }

      assignMergeValue(object, key, newValue);
    }
    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */


    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }
    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */


    var baseSetToString = !defineProperty ? identity : function (func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };
    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */

    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }

      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */


    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }
    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */


    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */


    function copyArray(source, array) {
      var index = -1,
          length = source.length;
      array || (array = Array(length));

      while (++index < length) {
        array[index] = source[index];
      }

      return array;
    }
    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */


    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }

        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }

      return object;
    }
    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */


    function createAssigner(assigner) {
      return baseRest(function (object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;
        customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }

        object = Object(object);

        while (++index < length) {
          var source = sources[index];

          if (source) {
            assigner(object, source, index, customizer);
          }
        }

        return object;
      });
    }
    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */


    function createBaseFor(fromRight) {
      return function (object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];

          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }

        return object;
      };
    }
    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */


    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
    }
    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */


    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }
    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */


    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);

      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }

      return result;
    }
    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */


    function initCloneObject(object) {
      return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */


    function isIndex(value, length) {
      var type = _typeof(value);

      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }
    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */


    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }

      var type = _typeof(index);

      if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
        return eq(object[index], value);
      }

      return false;
    }
    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */


    function isKeyable(value) {
      var type = _typeof(value);

      return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
    }
    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */


    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */


    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
      return value === proto;
    }
    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */


    function nativeKeysIn(object) {
      var result = [];

      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }

      return result;
    }
    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */


    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */


    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? func.length - 1 : start, 0);
      return function () {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }

        index = -1;
        var otherArgs = Array(start + 1);

        while (++index < start) {
          otherArgs[index] = args[index];
        }

        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */


    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }
    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */


    var setToString = shortOut(baseSetToString);
    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */

    function shortOut(func) {
      var count = 0,
          lastCalled = 0;
      return function () {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;

        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }

        return func.apply(undefined, arguments);
      };
    }
    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */


    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}

        try {
          return func + '';
        } catch (e) {}
      }

      return '';
    }
    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */


    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */


    var isArguments = baseIsArguments(function () {
      return arguments;
    }()) ? baseIsArguments : function (value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    };
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */

    var isArray = Array.isArray;
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */

    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */


    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */


    var isBuffer = nativeIsBuffer || stubFalse;
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */

    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      } // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.


      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */


    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */


    function isObject(value) {
      var type = _typeof(value);

      return value != null && (type == 'object' || type == 'function');
    }
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */


    function isObjectLike(value) {
      return value != null && _typeof(value) == 'object';
    }
    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */


    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }

      var proto = getPrototype(value);

      if (proto === null) {
        return true;
      }

      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */


    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */

    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */


    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */


    var merge = createAssigner(function (object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */

    function constant(value) {
      return function () {
        return value;
      };
    }
    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */


    function identity(value) {
      return value;
    }
    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */


    function stubFalse() {
      return false;
    }

    module.exports = merge;
  });

  var lodash_clonedeep = createCommonjsModule(function (module, exports) {
    /**
     * lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright jQuery Foundation and other contributors <https://jquery.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;
    /** Used to stand-in for `undefined` hash values. */

    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    /** Used as references for various `Number` constants. */

    var MAX_SAFE_INTEGER = 9007199254740991;
    /** `Object#toString` result references. */

    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        promiseTag = '[object Promise]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]',
        weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */

    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    /** Used to match `RegExp` flags from their coerced string values. */

    var reFlags = /\w*$/;
    /** Used to detect host constructors (Safari). */

    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    /** Used to detect unsigned integer values. */

    var reIsUint = /^(?:0|[1-9]\d*)$/;
    /** Used to identify `toStringTag` values supported by `_.clone`. */

    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    /** Detect free variable `global` from Node.js. */

    var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    /** Detect free variable `self`. */

    var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */

    var root = freeGlobal || freeSelf || Function('return this')();
    /** Detect free variable `exports`. */

    var freeExports =  exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /**
     * Adds the key-value `pair` to `map`.
     *
     * @private
     * @param {Object} map The map to modify.
     * @param {Array} pair The key-value pair to add.
     * @returns {Object} Returns `map`.
     */

    function addMapEntry(map, pair) {
      // Don't return `map.set` because it's not chainable in IE 11.
      map.set(pair[0], pair[1]);
      return map;
    }
    /**
     * Adds `value` to `set`.
     *
     * @private
     * @param {Object} set The set to modify.
     * @param {*} value The value to add.
     * @returns {Object} Returns `set`.
     */


    function addSetEntry(set, value) {
      // Don't return `set.add` because it's not chainable in IE 11.
      set.add(value);
      return set;
    }
    /**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */


    function arrayEach(array, iteratee) {
      var index = -1,
          length = array ? array.length : 0;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }

      return array;
    }
    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */


    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }

      return array;
    }
    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */


    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array ? array.length : 0;

      if (initAccum && length) {
        accumulator = array[++index];
      }

      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }

      return accumulator;
    }
    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */


    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }

      return result;
    }
    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */


    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }
    /**
     * Checks if `value` is a host object in IE < 9.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
     */


    function isHostObject(value) {
      // Many host objects are `Object` objects that can coerce to strings
      // despite having improperly defined `toString` methods.
      var result = false;

      if (value != null && typeof value.toString != 'function') {
        try {
          result = !!(value + '');
        } catch (e) {}
      }

      return result;
    }
    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */


    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);
      map.forEach(function (value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */


    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }
    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */


    function setToArray(set) {
      var index = -1,
          result = Array(set.size);
      set.forEach(function (value) {
        result[++index] = value;
      });
      return result;
    }
    /** Used for built-in method references. */


    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;
    /** Used to detect overreaching core-js shims. */

    var coreJsData = root['__core-js_shared__'];
    /** Used to detect methods masquerading as native. */

    var maskSrcKey = function () {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? 'Symbol(src)_1.' + uid : '';
    }();
    /** Used to resolve the decompiled source of functions. */


    var funcToString = funcProto.toString;
    /** Used to check objects for own properties. */

    var hasOwnProperty = objectProto.hasOwnProperty;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */

    var objectToString = objectProto.toString;
    /** Used to detect if a method is native. */

    var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
    /** Built-in value references. */

    var Buffer = moduleExports ? root.Buffer : undefined,
        _Symbol = root.Symbol,
        Uint8Array = root.Uint8Array,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice;
    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeKeys = overArg(Object.keys, Object);
    /* Built-in method references that are verified to be native. */

    var DataView = getNative(root, 'DataView'),
        Map = getNative(root, 'Map'),
        Promise = getNative(root, 'Promise'),
        Set = getNative(root, 'Set'),
        WeakMap = getNative(root, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');
    /** Used to detect maps, sets, and weakmaps. */

    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);
    /** Used to convert symbols to primitives and strings. */

    var symbolProto = _Symbol ? _Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function Hash(entries) {
      var index = -1,
          length = entries ? entries.length : 0;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */


    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function hashGet(key) {
      var data = this.__data__;

      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }

      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }
    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
    }
    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */


    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
      return this;
    } // Add methods to `Hash`.


    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function ListCache(entries) {
      var index = -1,
          length = entries ? entries.length : 0;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */


    function listCacheClear() {
      this.__data__ = [];
    }
    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }

      var lastIndex = data.length - 1;

      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }

      return true;
    }
    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);
      return index < 0 ? undefined : data[index][1];
    }
    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */


    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }

      return this;
    } // Add methods to `ListCache`.


    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function MapCache(entries) {
      var index = -1,
          length = entries ? entries.length : 0;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */


    function mapCacheClear() {
      this.__data__ = {
        'hash': new Hash(),
        'map': new (Map || ListCache)(),
        'string': new Hash()
      };
    }
    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function mapCacheDelete(key) {
      return getMapData(this, key)['delete'](key);
    }
    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */


    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    } // Add methods to `MapCache`.


    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */


    function stackClear() {
      this.__data__ = new ListCache();
    }
    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function stackDelete(key) {
      return this.__data__['delete'](key);
    }
    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function stackGet(key) {
      return this.__data__.get(key);
    }
    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function stackHas(key) {
      return this.__data__.has(key);
    }
    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */


    function stackSet(key, value) {
      var cache = this.__data__;

      if (cache instanceof ListCache) {
        var pairs = cache.__data__;

        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }

        cache = this.__data__ = new MapCache(pairs);
      }

      cache.set(key, value);
      return this;
    } // Add methods to `Stack`.


    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */

    function arrayLikeKeys(value, inherited) {
      // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
      // Safari 9 makes `arguments.length` enumerable in strict mode.
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length,
          skipIndexes = !!length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
          result.push(key);
        }
      }

      return result;
    }
    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */


    function assignValue(object, key, value) {
      var objValue = object[key];

      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
        object[key] = value;
      }
    }
    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */


    function assocIndexOf(array, key) {
      var length = array.length;

      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }

      return -1;
    }
    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */


    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {boolean} [isFull] Specify a clone including symbols.
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */


    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }

      if (result !== undefined) {
        return result;
      }

      if (!isObject(value)) {
        return value;
      }

      var isArr = isArray(value);

      if (isArr) {
        result = initCloneArray(value);

        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }

        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }

          result = initCloneObject(isFunc ? {} : value);

          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }

          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      } // Check for circular references and return its corresponding clone.


      stack || (stack = new Stack());
      var stacked = stack.get(value);

      if (stacked) {
        return stacked;
      }

      stack.set(value, result);

      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }

      arrayEach(props || value, function (subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        } // Recursively populate clone (susceptible to call stack limits).


        assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
      });
      return result;
    }
    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */


    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */


    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    /**
     * The base implementation of `getTag`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */


    function baseGetTag(value) {
      return objectToString.call(value);
    }
    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */


    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }

      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */


    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }

      var result = [];

      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }

      return result;
    }
    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */


    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }

      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */


    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }
    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */


    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    /**
     * Creates a clone of `map`.
     *
     * @private
     * @param {Object} map The map to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned map.
     */


    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */


    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    /**
     * Creates a clone of `set`.
     *
     * @private
     * @param {Object} set The set to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned set.
     */


    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */


    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */


    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */


    function copyArray(source, array) {
      var index = -1,
          length = source.length;
      array || (array = Array(length));

      while (++index < length) {
        array[index] = source[index];
      }

      return array;
    }
    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */


    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
        assignValue(object, key, newValue === undefined ? source[key] : newValue);
      }

      return object;
    }
    /**
     * Copies own symbol properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */


    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */


    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */


    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
    }
    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */


    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }
    /**
     * Creates an array of the own enumerable symbol properties of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */


    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */

    var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11,
    // for data views in Edge < 14, and promises in Node.js.

    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function getTag(value) {
        var result = objectToString.call(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : undefined;

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;

            case mapCtorString:
              return mapTag;

            case promiseCtorString:
              return promiseTag;

            case setCtorString:
              return setTag;

            case weakMapCtorString:
              return weakMapTag;
          }
        }

        return result;
      };
    }
    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */


    function initCloneArray(array) {
      var length = array.length,
          result = array.constructor(length); // Add properties assigned by `RegExp#exec`.

      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }

      return result;
    }
    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */


    function initCloneObject(object) {
      return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */


    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;

      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return cloneSet(object, isDeep, cloneFunc);

        case symbolTag:
          return cloneSymbol(object);
      }
    }
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */


    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }
    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */


    function isKeyable(value) {
      var type = _typeof(value);

      return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
    }
    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */


    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */


    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
      return value === proto;
    }
    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to process.
     * @returns {string} Returns the source code.
     */


    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}

        try {
          return func + '';
        } catch (e) {}
      }

      return '';
    }
    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */


    function cloneDeep(value) {
      return baseClone(value, true, true);
    }
    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */


    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */


    function isArguments(value) {
      // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
    }
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */


    var isArray = Array.isArray;
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */

    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */


    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */


    var isBuffer = nativeIsBuffer || stubFalse;
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */

    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8-9 which returns 'object' for typed array and other constructors.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */


    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */


    function isObject(value) {
      var type = _typeof(value);

      return !!value && (type == 'object' || type == 'function');
    }
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */


    function isObjectLike(value) {
      return !!value && _typeof(value) == 'object';
    }
    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */


    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */


    function stubArray() {
      return [];
    }
    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */


    function stubFalse() {
      return false;
    }

    module.exports = cloneDeep;
  });

  var hop = Object.prototype.hasOwnProperty;
  var strCharAt = String.prototype.charAt;
  var toStr = Object.prototype.toString;
  /**
   * Returns the character at a given index.
   *
   * @param {string} str
   * @param {number} index
   * @return {string|undefined}
   */
  // TODO: Move to a library

  var charAt = function charAt(str, index) {
    return strCharAt.call(str, index);
  };
  /**
   * hasOwnProperty, wrapped as a function.
   *
   * @name has
   * @api private
   * @param {*} context
   * @param {string|number} prop
   * @return {boolean}
   */
  // TODO: Move to a library


  var has = function has(context, prop) {
    return hop.call(context, prop);
  };
  /**
   * Returns true if a value is a string, otherwise false.
   *
   * @name isString
   * @api private
   * @param {*} val
   * @return {boolean}
   */
  // TODO: Move to a library


  var isString = function isString(val) {
    return toStr.call(val) === '[object String]';
  };
  /**
   * Returns true if a value is array-like, otherwise false. Array-like means a
   * value is not null, undefined, or a function, and has a numeric `length`
   * property.
   *
   * @name isArrayLike
   * @api private
   * @param {*} val
   * @return {boolean}
   */
  // TODO: Move to a library


  var isArrayLike = function isArrayLike(val) {
    return val != null && typeof val !== 'function' && typeof val.length === 'number';
  };
  /**
   * indexKeys
   *
   * @name indexKeys
   * @api private
   * @param {} target
   * @param {Function} pred
   * @return {Array}
   */


  var indexKeys = function indexKeys(target, pred) {
    pred = pred || has;
    var results = [];

    for (var i = 0, len = target.length; i < len; i += 1) {
      if (pred(target, i)) {
        results.push(String(i));
      }
    }

    return results;
  };
  /**
   * Returns an array of an object's owned keys.
   *
   * @name objectKeys
   * @api private
   * @param {*} target
   * @param {Function} pred Predicate function used to include/exclude values from
   * the resulting array.
   * @return {Array}
   */


  var objectKeys = function objectKeys(target, pred) {
    pred = pred || has;
    var results = [];

    for (var key in target) {
      if (pred(target, key)) {
        results.push(String(key));
      }
    }

    return results;
  };
  /**
   * Creates an array composed of all keys on the input object. Ignores any non-enumerable properties.
   * More permissive than the native `Object.keys` function (non-objects will not throw errors).
   *
   * @name keys
   * @api public
   * @category Object
   * @param {Object} source The value to retrieve keys from.
   * @return {Array} An array containing all the input `source`'s keys.
   * @example
   * keys({ likes: 'avocado', hates: 'pineapple' });
   * //=> ['likes', 'pineapple'];
   *
   * // Ignores non-enumerable properties
   * var hasHiddenKey = { name: 'Tim' };
   * Object.defineProperty(hasHiddenKey, 'hidden', {
   *   value: 'i am not enumerable!',
   *   enumerable: false
   * })
   * keys(hasHiddenKey);
   * //=> ['name'];
   *
   * // Works on arrays
   * keys(['a', 'b', 'c']);
   * //=> ['0', '1', '2']
   *
   * // Skips unpopulated indices in sparse arrays
   * var arr = [1];
   * arr[4] = 4;
   * keys(arr);
   * //=> ['0', '4']
   */


  var keys = function keys(source) {
    if (source == null) {
      return [];
    } // IE6-8 compatibility (string)


    if (isString(source)) {
      return indexKeys(source, charAt);
    } // IE6-8 compatibility (arguments)


    if (isArrayLike(source)) {
      return indexKeys(source, has);
    }

    return objectKeys(source);
  };
  /*
   * Exports.
   */


  var keys_1 = keys;

  /*
   * Module dependencies.
   */


  var objToString = Object.prototype.toString;
  /**
   * Tests if a value is a number.
   *
   * @name isNumber
   * @api private
   * @param {*} val The value to test.
   * @return {boolean} Returns `true` if `val` is a number, otherwise `false`.
   */
  // TODO: Move to library

  var isNumber = function isNumber(val) {
    var type = _typeof(val);

    return type === 'number' || type === 'object' && objToString.call(val) === '[object Number]';
  };
  /**
   * Tests if a value is an array.
   *
   * @name isArray
   * @api private
   * @param {*} val The value to test.
   * @return {boolean} Returns `true` if the value is an array, otherwise `false`.
   */
  // TODO: Move to library


  var isArray = typeof Array.isArray === 'function' ? Array.isArray : function isArray(val) {
    return objToString.call(val) === '[object Array]';
  };
  /**
   * Tests if a value is array-like. Array-like means the value is not a function and has a numeric
   * `.length` property.
   *
   * @name isArrayLike
   * @api private
   * @param {*} val
   * @return {boolean}
   */
  // TODO: Move to library

  var isArrayLike$1 = function isArrayLike(val) {
    return val != null && (isArray(val) || val !== 'function' && isNumber(val.length));
  };
  /**
   * Internal implementation of `each`. Works on arrays and array-like data structures.
   *
   * @name arrayEach
   * @api private
   * @param {Function(value, key, collection)} iterator The function to invoke per iteration.
   * @param {Array} array The array(-like) structure to iterate over.
   * @return {undefined}
   */


  var arrayEach = function arrayEach(iterator, array) {
    for (var i = 0; i < array.length; i += 1) {
      // Break iteration early if `iterator` returns `false`
      if (iterator(array[i], i, array) === false) {
        break;
      }
    }
  };
  /**
   * Internal implementation of `each`. Works on objects.
   *
   * @name baseEach
   * @api private
   * @param {Function(value, key, collection)} iterator The function to invoke per iteration.
   * @param {Object} object The object to iterate over.
   * @return {undefined}
   */


  var baseEach = function baseEach(iterator, object) {
    var ks = keys_1(object);

    for (var i = 0; i < ks.length; i += 1) {
      // Break iteration early if `iterator` returns `false`
      if (iterator(object[ks[i]], ks[i], object) === false) {
        break;
      }
    }
  };
  /**
   * Iterate over an input collection, invoking an `iterator` function for each element in the
   * collection and passing to it three arguments: `(value, index, collection)`. The `iterator`
   * function can end iteration early by returning `false`.
   *
   * @name each
   * @api public
   * @param {Function(value, key, collection)} iterator The function to invoke per iteration.
   * @param {Array|Object|string} collection The collection to iterate over.
   * @return {undefined} Because `each` is run only for side effects, always returns `undefined`.
   * @example
   * var log = console.log.bind(console);
   *
   * each(log, ['a', 'b', 'c']);
   * //-> 'a', 0, ['a', 'b', 'c']
   * //-> 'b', 1, ['a', 'b', 'c']
   * //-> 'c', 2, ['a', 'b', 'c']
   * //=> undefined
   *
   * each(log, 'tim');
   * //-> 't', 2, 'tim'
   * //-> 'i', 1, 'tim'
   * //-> 'm', 0, 'tim'
   * //=> undefined
   *
   * // Note: Iteration order not guaranteed across environments
   * each(log, { name: 'tim', occupation: 'enchanter' });
   * //-> 'tim', 'name', { name: 'tim', occupation: 'enchanter' }
   * //-> 'enchanter', 'occupation', { name: 'tim', occupation: 'enchanter' }
   * //=> undefined
   */


  var each = function each(iterator, collection) {
    return (isArrayLike$1(collection) ? arrayEach : baseEach).call(this, iterator, collection);
  };
  /*
   * Exports.
   */


  var each_1 = each;

  /*
   * Module dependencies.
   */

  /**
   * Reduces all the values in a collection down into a single value. Does so by iterating through the
   * collection from left to right, repeatedly calling an `iterator` function and passing to it four
   * arguments: `(accumulator, value, index, collection)`.
   *
   * Returns the final return value of the `iterator` function.
   *
   * @name foldl
   * @api public
   * @param {Function} iterator The function to invoke per iteration.
   * @param {*} accumulator The initial accumulator value, passed to the first invocation of `iterator`.
   * @param {Array|Object} collection The collection to iterate over.
   * @return {*} The return value of the final call to `iterator`.
   * @example
   * foldl(function(total, n) {
   *   return total + n;
   * }, 0, [1, 2, 3]);
   * //=> 6
   *
   * var phonebook = { bob: '555-111-2345', tim: '655-222-6789', sheila: '655-333-1298' };
   *
   * foldl(function(results, phoneNumber) {
   *  if (phoneNumber[0] === '6') {
   *    return results.concat(phoneNumber);
   *  }
   *  return results;
   * }, [], phonebook);
   * // => ['655-222-6789', '655-333-1298']
   */


  var foldl = function foldl(iterator, accumulator, collection) {
    if (typeof iterator !== 'function') {
      throw new TypeError('Expected a function but received a ' + _typeof(iterator));
    }

    each_1(function (val, i, collection) {
      accumulator = iterator(accumulator, val, i, collection);
    }, collection);
    return accumulator;
  };
  /*
   * Exports.
   */


  var foldl_1 = foldl;

  /**
   * Module dependencies.
   */


  var parse$1 = componentQuerystring.parse;
  /**
   * hasOwnProperty reference.
   */

  var has$1 = Object.prototype.hasOwnProperty;
  /**
   * Get all utm params from the given `querystring`
   *
   * @param {String} query
   * @return {Object}
   * @api private
   */

  function utm(query) {
    // Remove leading ? if present
    if (query.charAt(0) === '?') {
      query = query.substring(1);
    }

    query = query.replace(/\?/g, '&');
    var param;
    var params = parse$1(query);
    var results = {};

    for (var key in params) {
      if (has$1.call(params, key)) {
        if (key.substr(0, 4) === 'utm_') {
          param = key.substr(4);
          if (param === 'campaign') param = 'name';
          results[param] = params[key];
        }
      }
    }

    return results;
  }

  var allowedKeys = {
    name: true,
    term: true,
    source: true,
    medium: true,
    content: true
  };
  /**
   * Get strict utm params - from the given `querystring`
   *
   * @param {String} query
   * @return {Object}
   * @api private
   */

  function strict(query) {
    return foldl_1(function (acc, val, key) {
      if (has$1.call(allowedKeys, key)) acc[key] = val;
      return acc;
    }, {}, utm(query));
  }
  /*
   * Exports.
   */


  var lib = utm;
  var strict_1 = strict;
  lib.strict = strict_1;

  var componentUrl = createCommonjsModule(function (module, exports) {
    /**
     * Parse the given `url`.
     *
     * @param {String} str
     * @return {Object}
     * @api public
     */
    exports.parse = function (url) {
      var a = document.createElement('a');
      a.href = url;
      return {
        href: a.href,
        host: a.host || location.host,
        port: '0' === a.port || '' === a.port ? port(a.protocol) : a.port,
        hash: a.hash,
        hostname: a.hostname || location.hostname,
        pathname: a.pathname.charAt(0) != '/' ? '/' + a.pathname : a.pathname,
        protocol: !a.protocol || ':' == a.protocol ? location.protocol : a.protocol,
        search: a.search,
        query: a.search.slice(1)
      };
    };
    /**
     * Check if `url` is absolute.
     *
     * @param {String} url
     * @return {Boolean}
     * @api public
     */


    exports.isAbsolute = function (url) {
      return 0 == url.indexOf('//') || !!~url.indexOf('://');
    };
    /**
     * Check if `url` is relative.
     *
     * @param {String} url
     * @return {Boolean}
     * @api public
     */


    exports.isRelative = function (url) {
      return !exports.isAbsolute(url);
    };
    /**
     * Check if `url` is cross domain.
     *
     * @param {String} url
     * @return {Boolean}
     * @api public
     */


    exports.isCrossDomain = function (url) {
      url = exports.parse(url);
      var location = exports.parse(window.location.href);
      return url.hostname !== location.hostname || url.port !== location.port || url.protocol !== location.protocol;
    };
    /**
     * Return default port for `protocol`.
     *
     * @param  {String} protocol
     * @return {String}
     * @api private
     */


    function port(protocol) {
      switch (protocol) {
        case 'http:':
          return 80;

        case 'https:':
          return 443;

        default:
          return location.port;
      }
    }
  });
  var componentUrl_1 = componentUrl.parse;
  var componentUrl_2 = componentUrl.isAbsolute;
  var componentUrl_3 = componentUrl.isRelative;
  var componentUrl_4 = componentUrl.isCrossDomain;

  /*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */

  var isobject = function isObject(val) {
    return val != null && _typeof(val) === 'object' && Array.isArray(val) === false;
  };

  /*!
   * get-value <https://github.com/jonschlinkert/get-value>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   */

  var getValue = function getValue(target, path, options) {
    if (!isobject(options)) {
      options = {
        default: options
      };
    }

    if (!isValidObject(target)) {
      return typeof options.default !== 'undefined' ? options.default : target;
    }

    if (typeof path === 'number') {
      path = String(path);
    }

    var isArray = Array.isArray(path);
    var isString = typeof path === 'string';
    var splitChar = options.separator || '.';
    var joinChar = options.joinChar || (typeof splitChar === 'string' ? splitChar : '.');

    if (!isString && !isArray) {
      return target;
    }

    if (isString && path in target) {
      return isValid(path, target, options) ? target[path] : options.default;
    }

    var segs = isArray ? path : split(path, splitChar, options);
    var len = segs.length;
    var idx = 0;

    do {
      var prop = segs[idx];

      if (typeof prop === 'number') {
        prop = String(prop);
      }

      while (prop && prop.slice(-1) === '\\') {
        prop = join([prop.slice(0, -1), segs[++idx] || ''], joinChar, options);
      }

      if (prop in target) {
        if (!isValid(prop, target, options)) {
          return options.default;
        }

        target = target[prop];
      } else {
        var hasProp = false;
        var n = idx + 1;

        while (n < len) {
          prop = join([prop, segs[n++]], joinChar, options);

          if (hasProp = prop in target) {
            if (!isValid(prop, target, options)) {
              return options.default;
            }

            target = target[prop];
            idx = n - 1;
            break;
          }
        }

        if (!hasProp) {
          return options.default;
        }
      }
    } while (++idx < len && isValidObject(target));

    if (idx === len) {
      return target;
    }

    return options.default;
  };

  function join(segs, joinChar, options) {
    if (typeof options.join === 'function') {
      return options.join(segs);
    }

    return segs[0] + joinChar + segs[1];
  }

  function split(path, splitChar, options) {
    if (typeof options.split === 'function') {
      return options.split(path);
    }

    return path.split(splitChar);
  }

  function isValid(key, target, options) {
    if (typeof options.isValid === 'function') {
      return options.isValid(key, target);
    }

    return true;
  }

  function isValidObject(val) {
    return isobject(val) || Array.isArray(val) || typeof val === 'function';
  }

  var LOG_LEVEL_INFO = 1;
  var LOG_LEVEL_DEBUG = 2;
  var LOG_LEVEL_WARN = 3;
  var LOG_LEVEL_ERROR = 4;
  var LOG_LEVEL = LOG_LEVEL_ERROR;
  var logger = {
    setLogLevel: function setLogLevel(logLevel) {
      switch (logLevel.toUpperCase()) {
        case "INFO":
          LOG_LEVEL = LOG_LEVEL_INFO;
          return;

        case "DEBUG":
          LOG_LEVEL = LOG_LEVEL_DEBUG;
          return;

        case "WARN":
          LOG_LEVEL = LOG_LEVEL_WARN;
      }
    },
    info: function info() {
      if (LOG_LEVEL <= LOG_LEVEL_INFO) {
        var _console;

        (_console = console).log.apply(_console, arguments);
      }
    },
    debug: function debug() {
      if (LOG_LEVEL <= LOG_LEVEL_DEBUG) {
        var _console2;

        (_console2 = console).log.apply(_console2, arguments);
      }
    },
    warn: function warn() {
      if (LOG_LEVEL <= LOG_LEVEL_WARN) {
        var _console3;

        (_console3 = console).log.apply(_console3, arguments);
      }
    },
    error: function error() {
      if (LOG_LEVEL <= LOG_LEVEL_ERROR) {
        var _console4;

        (_console4 = console).log.apply(_console4, arguments);
      }
    }
  };

  var _CNameMapping;

  var NAME = "ADOBE_ANALYTICS";
  var CNameMapping = (_CNameMapping = {
    "Adobe Analytics": NAME
  }, _defineProperty(_CNameMapping, NAME, NAME), _defineProperty(_CNameMapping, "AdobeAnalytics", NAME), _defineProperty(_CNameMapping, "adobeanalytics", NAME), _CNameMapping);

  var _CNameMapping$1;

  var NAME$1 = "AM";
  var CNameMapping$1 = (_CNameMapping$1 = {}, _defineProperty(_CNameMapping$1, NAME$1, NAME$1), _defineProperty(_CNameMapping$1, "AMPLITUDE", NAME$1), _defineProperty(_CNameMapping$1, "Amplitude", NAME$1), _CNameMapping$1);

  var _CNameMapping$2;

  var NAME$2 = "APPCUES";
  var CNameMapping$2 = (_CNameMapping$2 = {}, _defineProperty(_CNameMapping$2, NAME$2, NAME$2), _defineProperty(_CNameMapping$2, "Appcues", NAME$2), _CNameMapping$2);

  var _CNameMapping$3;

  var NAME$3 = "BINGADS";
  var CNameMapping$3 = (_CNameMapping$3 = {}, _defineProperty(_CNameMapping$3, NAME$3, NAME$3), _defineProperty(_CNameMapping$3, "BingAds", NAME$3), _CNameMapping$3);

  var _CNameMapping$4;

  var NAME$4 = "BRAZE";
  var CNameMapping$4 = (_CNameMapping$4 = {}, _defineProperty(_CNameMapping$4, NAME$4, NAME$4), _defineProperty(_CNameMapping$4, "Braze", NAME$4), _CNameMapping$4);

  var NAME$5 = "BUGSNAG";

  var CNameMapping$5 = _defineProperty({}, NAME$5, NAME$5);

  var _CNameMapping$5;

  var NAME$6 = "CHARTBEAT";
  var CNameMapping$6 = (_CNameMapping$5 = {}, _defineProperty(_CNameMapping$5, NAME$6, NAME$6), _defineProperty(_CNameMapping$5, "Chartbeat", NAME$6), _CNameMapping$5);

  var _CNameMapping$6;

  var NAME$7 = "CLEVERTAP";
  var CNameMapping$7 = (_CNameMapping$6 = {}, _defineProperty(_CNameMapping$6, NAME$7, NAME$7), _defineProperty(_CNameMapping$6, "Clevertap", NAME$7), _CNameMapping$6);

  var _CNameMapping$7;

  var NAME$8 = "COMSCORE";
  var CNameMapping$8 = (_CNameMapping$7 = {}, _defineProperty(_CNameMapping$7, NAME$8, NAME$8), _defineProperty(_CNameMapping$7, "Comscore", NAME$8), _CNameMapping$7);

  var _CNameMapping$8;

  var NAME$9 = "CRITEO";
  var CNameMapping$9 = (_CNameMapping$8 = {}, _defineProperty(_CNameMapping$8, NAME$9, NAME$9), _defineProperty(_CNameMapping$8, "Criteo", NAME$9), _defineProperty(_CNameMapping$8, "criteo", NAME$9), _CNameMapping$8);

  var _CNameMapping$9;

  var NAME$a = "CUSTOMERIO";
  var CNameMapping$a = (_CNameMapping$9 = {}, _defineProperty(_CNameMapping$9, NAME$a, NAME$a), _defineProperty(_CNameMapping$9, "Customerio", NAME$a), _defineProperty(_CNameMapping$9, "Customer.io", NAME$a), _CNameMapping$9);

  var _CNameMapping$a;

  var NAME$b = "DRIP";
  var CNameMapping$b = (_CNameMapping$a = {}, _defineProperty(_CNameMapping$a, NAME$b, NAME$b), _defineProperty(_CNameMapping$a, "Drip", NAME$b), _defineProperty(_CNameMapping$a, "drip", NAME$b), _CNameMapping$a);

  var _CNameMapping$b;

  var NAME$c = "FACEBOOK_PIXEL";
  var CNameMapping$c = (_CNameMapping$b = {}, _defineProperty(_CNameMapping$b, NAME$c, NAME$c), _defineProperty(_CNameMapping$b, "FB Pixel", NAME$c), _defineProperty(_CNameMapping$b, "Facebook Pixel", NAME$c), _defineProperty(_CNameMapping$b, "FB_PIXEL", NAME$c), _CNameMapping$b);
  var traitsMapper = [{
    destKey: "external_id",
    sourceKeys: ["userId", "context.traits.userId", "context.traits.id", "anonymousId"]
  }, {
    destKey: "em",
    sourceKeys: "context.traits.email"
  }, {
    destKey: "ph",
    sourceKeys: "context.traits.phone"
  }, {
    destKey: "ge",
    sourceKeys: "context.traits.gender"
  }, {
    destKey: "db",
    sourceKeys: "context.traits.birthday"
  }, {
    destKey: "ln",
    sourceKeys: ["context.traits.lastname", "context.traits.lastName", "context.traits.last_name"]
  }, {
    destKey: "fn",
    sourceKeys: ["context.traits.firstname", "context.traits.firstName", "context.traits.first_name"]
  }, {
    destKey: "ct",
    sourceKeys: ["context.traits.address.city", "context.traits.city"]
  }, {
    destKey: "st",
    sourceKeys: ["context.traits.address.state", "context.traits.state"]
  }, {
    destKey: "zp",
    sourceKeys: ["context.traits.address.zip", "context.traits.zip"]
  }, {
    destKey: "country",
    sourceKeys: ["context.traits.address.country", "context.traits.country"]
  }];

  var _CNameMapping$c;

  var NAME$d = "FULLSTORY";
  var CNameMapping$d = (_CNameMapping$c = {}, _defineProperty(_CNameMapping$c, NAME$d, NAME$d), _defineProperty(_CNameMapping$c, "Fullstory", NAME$d), _defineProperty(_CNameMapping$c, "FullStory", NAME$d), _CNameMapping$c);

  var _CNameMapping$d;

  var NAME$e = "GA";
  var CNameMapping$e = (_CNameMapping$d = {}, _defineProperty(_CNameMapping$d, NAME$e, NAME$e), _defineProperty(_CNameMapping$d, "Google Analytics", NAME$e), _defineProperty(_CNameMapping$d, "GoogleAnalytics", NAME$e), _CNameMapping$d);

  var _CNameMapping$e;

  var NAME$f = "GA4";
  var CNameMapping$f = (_CNameMapping$e = {}, _defineProperty(_CNameMapping$e, NAME$f, NAME$f), _defineProperty(_CNameMapping$e, "Google Analytics 4", NAME$f), _defineProperty(_CNameMapping$e, "GoogleAnalytics4", NAME$f), _CNameMapping$e);

  var _CNameMapping$f;

  var NAME$g = "GOOGLEADS";
  var CNameMapping$g = (_CNameMapping$f = {}, _defineProperty(_CNameMapping$f, NAME$g, NAME$g), _defineProperty(_CNameMapping$f, "Google Ads", NAME$g), _defineProperty(_CNameMapping$f, "GoogleAds", NAME$g), _CNameMapping$f);

  var _CNameMapping$g;

  var NAME$h = "GOOGLE_OPTIMIZE";
  var CNameMapping$h = (_CNameMapping$g = {}, _defineProperty(_CNameMapping$g, NAME$h, NAME$h), _defineProperty(_CNameMapping$g, "Google Optimize", NAME$h), _defineProperty(_CNameMapping$g, "GoogleOptimize", NAME$h), _defineProperty(_CNameMapping$g, "Googleoptimize", NAME$h), _defineProperty(_CNameMapping$g, "GOOGLEOPTIMIZE", NAME$h), _CNameMapping$g);

  var _CNameMapping$h;

  var NAME$i = "GTM";
  var CNameMapping$i = (_CNameMapping$h = {}, _defineProperty(_CNameMapping$h, NAME$i, NAME$i), _defineProperty(_CNameMapping$h, "Google Tag Manager", NAME$i), _CNameMapping$h);

  var _CNameMapping$i;

  var NAME$j = "HEAP";
  var CNameMapping$j = (_CNameMapping$i = {}, _defineProperty(_CNameMapping$i, NAME$j, NAME$j), _defineProperty(_CNameMapping$i, "Heap", NAME$j), _defineProperty(_CNameMapping$i, "heap", NAME$j), _defineProperty(_CNameMapping$i, "Heap.io", NAME$j), _CNameMapping$i);

  var _CNameMapping$j;

  var NAME$k = "HOTJAR";
  var CNameMapping$k = (_CNameMapping$j = {}, _defineProperty(_CNameMapping$j, NAME$k, NAME$k), _defineProperty(_CNameMapping$j, "Hotjar", NAME$k), _defineProperty(_CNameMapping$j, "hotjar", NAME$k), _CNameMapping$j);

  var _CNameMapping$k;

  var NAME$l = "HS";
  var CNameMapping$l = (_CNameMapping$k = {}, _defineProperty(_CNameMapping$k, NAME$l, NAME$l), _defineProperty(_CNameMapping$k, "Hubspot", NAME$l), _defineProperty(_CNameMapping$k, "HUBSPOT", NAME$l), _CNameMapping$k);

  var _CNameMapping$l;

  var NAME$m = "INTERCOM";
  var CNameMapping$m = (_CNameMapping$l = {}, _defineProperty(_CNameMapping$l, NAME$m, NAME$m), _defineProperty(_CNameMapping$l, "Intercom", NAME$m), _CNameMapping$l);

  var _CNameMapping$m;

  var NAME$n = "KEEN";
  var CNameMapping$n = (_CNameMapping$m = {}, _defineProperty(_CNameMapping$m, NAME$n, NAME$n), _defineProperty(_CNameMapping$m, "Keen", NAME$n), _defineProperty(_CNameMapping$m, "Keen.io", NAME$n), _CNameMapping$m);

  var _CNameMapping$n;

  var NAME$o = "KISSMETRICS";
  var CNameMapping$o = (_CNameMapping$n = {}, _defineProperty(_CNameMapping$n, NAME$o, NAME$o), _defineProperty(_CNameMapping$n, "Kissmetrics", NAME$o), _CNameMapping$n);

  var _CNameMapping$o;

  var NAME$p = "KLAVIYO";
  var CNameMapping$p = (_CNameMapping$o = {}, _defineProperty(_CNameMapping$o, NAME$p, NAME$p), _defineProperty(_CNameMapping$o, "Klaviyo", NAME$p), _CNameMapping$o);

  var _CNameMapping$p;

  var NAME$q = "LAUNCHDARKLY";
  var CNameMapping$q = (_CNameMapping$p = {}, _defineProperty(_CNameMapping$p, NAME$q, NAME$q), _defineProperty(_CNameMapping$p, "LaunchDarkly", NAME$q), _defineProperty(_CNameMapping$p, "Launch_Darkly", NAME$q), _defineProperty(_CNameMapping$p, "Launch Darkly", NAME$q), _defineProperty(_CNameMapping$p, "launchDarkly", NAME$q), _CNameMapping$p);

  var _CNameMapping$q;

  var NAME$r = "LINKEDIN_INSIGHT_TAG";
  var CNameMapping$r = (_CNameMapping$q = {}, _defineProperty(_CNameMapping$q, NAME$r, NAME$r), _defineProperty(_CNameMapping$q, "LinkedIn Insight Tag", NAME$r), _defineProperty(_CNameMapping$q, "Linkedin_insight_tag", NAME$r), _defineProperty(_CNameMapping$q, "LinkedinInsighttag", NAME$r), _defineProperty(_CNameMapping$q, "LinkedinInsightTag", NAME$r), _defineProperty(_CNameMapping$q, "LinkedInInsightTag", NAME$r), _defineProperty(_CNameMapping$q, "Linkedininsighttag", NAME$r), _defineProperty(_CNameMapping$q, "LINKEDININSIGHTTAG", NAME$r), _CNameMapping$q);

  var _CNameMapping$r;

  var NAME$s = "LOTAME";
  var CNameMapping$s = (_CNameMapping$r = {}, _defineProperty(_CNameMapping$r, NAME$s, NAME$s), _defineProperty(_CNameMapping$r, "Lotame", NAME$s), _CNameMapping$r);

  var _CNameMapping$s;

  var NAME$t = "LYTICS";
  var CNameMapping$t = (_CNameMapping$s = {}, _defineProperty(_CNameMapping$s, NAME$t, NAME$t), _defineProperty(_CNameMapping$s, "Lytics", NAME$t), _CNameMapping$s);

  var _CNameMapping$t;

  var NAME$u = "MP";
  var CNameMapping$u = (_CNameMapping$t = {}, _defineProperty(_CNameMapping$t, NAME$u, NAME$u), _defineProperty(_CNameMapping$t, "MIXPANEL", NAME$u), _defineProperty(_CNameMapping$t, "Mixpanel", NAME$u), _CNameMapping$t);

  var _CNameMapping$u;

  var NAME$v = "MOENGAGE";
  var CNameMapping$v = (_CNameMapping$u = {}, _defineProperty(_CNameMapping$u, NAME$v, NAME$v), _defineProperty(_CNameMapping$u, "MoEngage", NAME$v), _CNameMapping$u);

  var _CNameMapping$v;

  var NAME$w = "OPTIMIZELY";
  var CNameMapping$w = (_CNameMapping$v = {}, _defineProperty(_CNameMapping$v, NAME$w, NAME$w), _defineProperty(_CNameMapping$v, "Optimizely", NAME$w), _CNameMapping$v);

  var _CNameMapping$w;

  var NAME$x = "PENDO";
  var CNameMapping$x = (_CNameMapping$w = {}, _defineProperty(_CNameMapping$w, NAME$x, NAME$x), _defineProperty(_CNameMapping$w, "Pendo", NAME$x), _CNameMapping$w);

  var _CNameMapping$x;

  var NAME$y = "PINTEREST_TAG";
  var CNameMapping$y = (_CNameMapping$x = {}, _defineProperty(_CNameMapping$x, NAME$y, NAME$y), _defineProperty(_CNameMapping$x, "PinterestTag", NAME$y), _defineProperty(_CNameMapping$x, "Pinterest_Tag", NAME$y), _defineProperty(_CNameMapping$x, "PINTERESTTAG", NAME$y), _defineProperty(_CNameMapping$x, "pinterest", NAME$y), _defineProperty(_CNameMapping$x, "PinterestAds", NAME$y), _defineProperty(_CNameMapping$x, "Pinterest_Ads", NAME$y), _defineProperty(_CNameMapping$x, "Pinterest", NAME$y), _CNameMapping$x);

  var _CNameMapping$y;

  var NAME$z = "POST_AFFILIATE_PRO";
  var CNameMapping$z = (_CNameMapping$y = {}, _defineProperty(_CNameMapping$y, NAME$z, NAME$z), _defineProperty(_CNameMapping$y, "PostAffiliatePro", NAME$z), _defineProperty(_CNameMapping$y, "Post_affiliate_pro", NAME$z), _defineProperty(_CNameMapping$y, "Post Affiliate Pro", NAME$z), _defineProperty(_CNameMapping$y, "postaffiliatepro", NAME$z), _defineProperty(_CNameMapping$y, "POSTAFFILIATEPRO", NAME$z), _CNameMapping$y);

  var _CNameMapping$z;

  var NAME$A = "POSTHOG";
  var CNameMapping$A = (_CNameMapping$z = {}, _defineProperty(_CNameMapping$z, NAME$A, NAME$A), _defineProperty(_CNameMapping$z, "PostHog", NAME$A), _defineProperty(_CNameMapping$z, "Posthog", NAME$A), _CNameMapping$z);

  var _CNameMapping$A;

  var NAME$B = "PROFITWELL";
  var CNameMapping$B = (_CNameMapping$A = {}, _defineProperty(_CNameMapping$A, NAME$B, NAME$B), _defineProperty(_CNameMapping$A, "ProfitWell", NAME$B), _defineProperty(_CNameMapping$A, "profitwell", NAME$B), _defineProperty(_CNameMapping$A, "Profitwell", NAME$B), _CNameMapping$A);

  var _CNameMapping$B;

  var NAME$C = "QUALTRICS";
  var CNameMapping$C = (_CNameMapping$B = {}, _defineProperty(_CNameMapping$B, NAME$C, NAME$C), _defineProperty(_CNameMapping$B, "Qualtrics", NAME$C), _defineProperty(_CNameMapping$B, "qualtrics", NAME$C), _CNameMapping$B);

  var _CNameMapping$C;

  var NAME$D = "QUANTUMMETRIC";
  var CNameMapping$D = (_CNameMapping$C = {}, _defineProperty(_CNameMapping$C, NAME$D, NAME$D), _defineProperty(_CNameMapping$C, "Quantum Metric", NAME$D), _defineProperty(_CNameMapping$C, "QuantumMetric", NAME$D), _defineProperty(_CNameMapping$C, "quantumMetric", NAME$D), _defineProperty(_CNameMapping$C, "quantummetric", NAME$D), _defineProperty(_CNameMapping$C, "Quantum_Metric", NAME$D), _CNameMapping$C);

  var _CNameMapping$D;

  var NAME$E = "REDDIT_PIXEL";
  var CNameMapping$E = (_CNameMapping$D = {}, _defineProperty(_CNameMapping$D, NAME$E, NAME$E), _defineProperty(_CNameMapping$D, "Reddit_Pixel", NAME$E), _defineProperty(_CNameMapping$D, "RedditPixel", NAME$E), _defineProperty(_CNameMapping$D, "REDDITPIXEL", NAME$E), _defineProperty(_CNameMapping$D, "redditpixel", NAME$E), _defineProperty(_CNameMapping$D, "Reddit Pixel", NAME$E), _defineProperty(_CNameMapping$D, "REDDIT PIXEL", NAME$E), _defineProperty(_CNameMapping$D, "reddit pixel", NAME$E), _CNameMapping$D);

  var _CNameMapping$E;

  var NAME$F = "SENTRY";
  var CNameMapping$F = (_CNameMapping$E = {}, _defineProperty(_CNameMapping$E, NAME$F, NAME$F), _defineProperty(_CNameMapping$E, "sentry", NAME$F), _defineProperty(_CNameMapping$E, "Sentry", NAME$F), _CNameMapping$E);

  var _CNameMapping$F;

  var NAME$G = "SNAP_PIXEL";
  var CNameMapping$G = (_CNameMapping$F = {}, _defineProperty(_CNameMapping$F, NAME$G, NAME$G), _defineProperty(_CNameMapping$F, "Snap_Pixel", NAME$G), _defineProperty(_CNameMapping$F, "SnapPixel", NAME$G), _defineProperty(_CNameMapping$F, "SNAPPIXEL", NAME$G), _defineProperty(_CNameMapping$F, "snappixel", NAME$G), _defineProperty(_CNameMapping$F, "Snap Pixel", NAME$G), _defineProperty(_CNameMapping$F, "SNAP PIXEL", NAME$G), _defineProperty(_CNameMapping$F, "snap pixel", NAME$G), _CNameMapping$F);

  var _CNameMapping$G;

  var NAME$H = "TVSQUARED";
  var CNameMapping$H = (_CNameMapping$G = {}, _defineProperty(_CNameMapping$G, NAME$H, NAME$H), _defineProperty(_CNameMapping$G, "TVSquared", NAME$H), _CNameMapping$G);

  var _CNameMapping$H;

  var NAME$I = "VWO";
  var CNameMapping$I = (_CNameMapping$H = {}, _defineProperty(_CNameMapping$H, NAME$I, NAME$I), _defineProperty(_CNameMapping$H, "Visual Website Optimizer", NAME$I), _CNameMapping$H);

  var _CNameMapping$I;

  var NAME$J = "GA360";
  var CNameMapping$J = (_CNameMapping$I = {}, _defineProperty(_CNameMapping$I, NAME$J, NAME$J), _defineProperty(_CNameMapping$I, "Google Analytics 360", NAME$J), _defineProperty(_CNameMapping$I, "GoogleAnalytics360", NAME$J), _defineProperty(_CNameMapping$I, "GA 360", NAME$J), _CNameMapping$I);

  var _CNameMapping$J;

  var NAME$K = "ADROLL";
  var CNameMapping$K = (_CNameMapping$J = {}, _defineProperty(_CNameMapping$J, NAME$K, NAME$K), _defineProperty(_CNameMapping$J, "Adroll", NAME$K), _defineProperty(_CNameMapping$J, "Ad roll", NAME$K), _CNameMapping$J);

  // add a mapping from common names to index.js exported key names as identified by Rudder

  var commonNames = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({
    All: "All"
  }, CNameMapping), CNameMapping$K), CNameMapping$1), CNameMapping$2), CNameMapping$3), CNameMapping$4), CNameMapping$5), CNameMapping$6), CNameMapping$7), CNameMapping$8), CNameMapping$9), CNameMapping$a), CNameMapping$b), CNameMapping$c), CNameMapping$d), CNameMapping$e), CNameMapping$f), CNameMapping$J), CNameMapping$g), CNameMapping$h), CNameMapping$i), CNameMapping$j), CNameMapping$k), CNameMapping$l), CNameMapping$m), CNameMapping$n), CNameMapping$o), CNameMapping$p), CNameMapping$q), CNameMapping$r), CNameMapping$s), CNameMapping$t), CNameMapping$u), CNameMapping$v), CNameMapping$w), CNameMapping$x), CNameMapping$y), CNameMapping$z), CNameMapping$A), CNameMapping$B), CNameMapping$C), CNameMapping$D), CNameMapping$E), CNameMapping$F), CNameMapping$G), CNameMapping$H), CNameMapping$I);

  // from client native integration name to server identified display name
  // add a mapping from Rudder identified key names to Rudder server recognizable names
  var clientToServerNames = {
    All: "All",
    GA: "Google Analytics",
    GOOGLEADS: "Google Ads",
    BRAZE: "Braze",
    CHARTBEAT: "Chartbeat",
    COMSCORE: "Comscore",
    CUSTOMERIO: "Customer IO",
    FACEBOOK_PIXEL: "Facebook Pixel",
    GTM: "Google Tag Manager",
    HOTJAR: "Hotjar",
    HS: "HubSpot",
    INTERCOM: "Intercom",
    KEEN: "Keen",
    KISSMETRICS: "Kiss Metrics",
    LOTAME: "Lotame",
    VWO: "VWO",
    OPTIMIZELY: "Optimizely Web",
    FULLSTORY: "Fullstory",
    TVSQUARED: "TVSquared",
    GA4: "Google Analytics 4",
    MOENGAGE: "MoEngage",
    AM: "Amplitude",
    PENDO: "Pendo",
    LYTICS: "Lytics",
    APPCUES: "Appcues",
    POSTHOG: "PostHog",
    PROFITWELL: "ProfitWell",
    KLAVIYO: "Klaviyo",
    CLEVERTAP: "CleverTap",
    BINGADS: "Bing Ads",
    PINTEREST_TAG: "Pinterest Tag",
    SNAP_PIXEL: "Snap Pixel",
    LINKEDIN_INSIGHT_TAG: "Linkedin Insight Tag",
    REDDIT_PIXEL: "Reddit Pixel",
    DRIP: "Drip",
    HEAP: "Heap.io",
    CRITEO: "Criteo",
    MP: "Mixpanel",
    QUALTRICS: "Qualtrics",
    SENTRY: "Sentry",
    GOOGLE_OPTIMIZE: "Google Optimize",
    POST_AFFILIATE_PRO: "Post Affiliate Pro",
    LAUNCHDARKLY: "LaunchDarkly",
    GA360: "Google Analytics 360",
    ADROLL: "Adroll"
  };

  // Reserved Keywords for properties/triats
  var ReservedPropertyKeywords = ["anonymous_id", "id", "sent_at", "received_at", "timestamp", "original_timestamp", "event_text", "event"]; // Message Type enumeration

  var MessageType = {
    TRACK: "track",
    PAGE: "page",
    // SCREEN: "screen",
    IDENTIFY: "identify"
  }; // ECommerce Parameter Names Enumeration

  var ECommerceEvents = {
    PRODUCTS_SEARCHED: "Products Searched",
    PRODUCT_LIST_VIEWED: "Product List Viewed",
    PRODUCT_LIST_FILTERED: "Product List Filtered",
    PROMOTION_VIEWED: "Promotion Viewed",
    PROMOTION_CLICKED: "Promotion Clicked",
    PRODUCT_CLICKED: "Product Clicked",
    PRODUCT_VIEWED: "Product Viewed",
    PRODUCT_ADDED: "Product Added",
    PRODUCT_REMOVED: "Product Removed",
    CART_VIEWED: "Cart Viewed",
    CHECKOUT_STARTED: "Checkout Started",
    CHECKOUT_STEP_VIEWED: "Checkout Step Viewed",
    CHECKOUT_STEP_COMPLETED: "Checkout Step Completed",
    PAYMENT_INFO_ENTERED: "Payment Info Entered",
    ORDER_UPDATED: "Order Updated",
    ORDER_COMPLETED: "Order Completed",
    ORDER_REFUNDED: "Order Refunded",
    ORDER_CANCELLED: "Order Cancelled",
    COUPON_ENTERED: "Coupon Entered",
    COUPON_APPLIED: "Coupon Applied",
    COUPON_DENIED: "Coupon Denied",
    COUPON_REMOVED: "Coupon Removed",
    PRODUCT_ADDED_TO_WISHLIST: "Product Added to Wishlist",
    PRODUCT_REMOVED_FROM_WISHLIST: "Product Removed from Wishlist",
    WISH_LIST_PRODUCT_ADDED_TO_CART: "Wishlist Product Added to Cart",
    PRODUCT_SHARED: "Product Shared",
    CART_SHARED: "Cart Shared",
    PRODUCT_REVIEWED: "Product Reviewed"
  }; // Enumeration for integrations supported

  var CONFIG_URL = "https://api.rudderlabs.com/sourceConfig/?p=web&v=1.5.4";
  var MAX_WAIT_FOR_INTEGRATION_LOAD = 10000;
  var INTEGRATION_LOAD_CHECK_INTERVAL = 1000;
  var POLYFILL_URL = "https://polyfill.io/v3/polyfill.min.js?features=Array.prototype.find%2CArray.prototype.includes%2CPromise%2CString.prototype.endsWith%2CString.prototype.includes%2CString.prototype.startsWith%2CObject.entries";
  /* module.exports = {
    MessageType: MessageType,
    ECommerceParamNames: ECommerceParamNames,
    ECommerceEvents: ECommerceEvents,
    RudderIntegrationPlatform: RudderIntegrationPlatform,
    BASE_URL: BASE_URL,
    CONFIG_URL: CONFIG_URL,
    FLUSH_QUEUE_SIZE: FLUSH_QUEUE_SIZE
  }; */

  var core = createCommonjsModule(function (module, exports) {

    (function (root, factory) {
      {
        // CommonJS
        module.exports = exports = factory();
      }
    })(commonjsGlobal, function () {
      /**
       * CryptoJS core components.
       */
      var CryptoJS = CryptoJS || function (Math, undefined$1) {
        /*
         * Local polyfil of Object.create
         */
        var create = Object.create || function () {
          function F() {}
          return function (obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        /**
         * CryptoJS namespace.
         */


        var C = {};
        /**
         * Library namespace.
         */

        var C_lib = C.lib = {};
        /**
         * Base object for prototypal inheritance.
         */

        var Base = C_lib.Base = function () {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function extend(overrides) {
              // Spawn
              var subtype = create(this); // Augment

              if (overrides) {
                subtype.mixIn(overrides);
              } // Create default initializer


              if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
                subtype.init = function () {
                  subtype.$super.init.apply(this, arguments);
                };
              } // Initializer's prototype is the subtype object


              subtype.init.prototype = subtype; // Reference supertype

              subtype.$super = this;
              return subtype;
            },

            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function create() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },

            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function init() {},

            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function mixIn(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              } // IE won't copy toString using the loop above


              if (properties.hasOwnProperty('toString')) {
                this.toString = properties.toString;
              }
            },

            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function clone() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        /**
         * An array of 32-bit words.
         *
         * @property {Array} words The array of 32-bit words.
         * @property {number} sigBytes The number of significant bytes in this word array.
         */


        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function init(words, sigBytes) {
            words = this.words = words || [];

            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },

          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function toString(encoder) {
            return (encoder || Hex).stringify(this);
          },

          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function concat(wordArray) {
            // Shortcuts
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes; // Clamp excess bits

            this.clamp(); // Concat

            if (thisSigBytes % 4) {
              // Copy one byte at a time
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              // Copy one word at a time
              for (var i = 0; i < thatSigBytes; i += 4) {
                thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
              }
            }

            this.sigBytes += thatSigBytes; // Chainable

            return this;
          },

          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function clamp() {
            // Shortcuts
            var words = this.words;
            var sigBytes = this.sigBytes; // Clamp

            words[sigBytes >>> 2] &= 0xffffffff << 32 - sigBytes % 4 * 8;
            words.length = Math.ceil(sigBytes / 4);
          },

          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function clone() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },

          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function random(nBytes) {
            var words = [];

            var r = function r(m_w) {
              var m_w = m_w;
              var m_z = 0x3ade68b1;
              var mask = 0xffffffff;
              return function () {
                m_z = 0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10) & mask;
                m_w = 0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10) & mask;
                var result = (m_z << 0x10) + m_w & mask;
                result /= 0x100000000;
                result += 0.5;
                return result * (Math.random() > .5 ? 1 : -1);
              };
            };

            for (var i = 0, rcache; i < nBytes; i += 4) {
              var _r = r((rcache || Math.random()) * 0x100000000);

              rcache = _r() * 0x3ade67b7;
              words.push(_r() * 0x100000000 | 0);
            }

            return new WordArray.init(words, nBytes);
          }
        });
        /**
         * Encoder namespace.
         */

        var C_enc = C.enc = {};
        /**
         * Hex encoding strategy.
         */

        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function stringify(wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes; // Convert

            var hexChars = [];

            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 0x0f).toString(16));
            }

            return hexChars.join('');
          },

          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function parse(hexStr) {
            // Shortcut
            var hexStrLength = hexStr.length; // Convert

            var words = [];

            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }

            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        /**
         * Latin1 encoding strategy.
         */

        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function stringify(wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes; // Convert

            var latin1Chars = [];

            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
              latin1Chars.push(String.fromCharCode(bite));
            }

            return latin1Chars.join('');
          },

          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function parse(latin1Str) {
            // Shortcut
            var latin1StrLength = latin1Str.length; // Convert

            var words = [];

            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << 24 - i % 4 * 8;
            }

            return new WordArray.init(words, latin1StrLength);
          }
        };
        /**
         * UTF-8 encoding strategy.
         */

        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function stringify(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error('Malformed UTF-8 data');
            }
          },

          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function parse(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        /**
         * Abstract buffered block algorithm template.
         *
         * The property blockSize must be implemented in a concrete subtype.
         *
         * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
         */

        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function reset() {
            // Initial values
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },

          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function _append(data) {
            // Convert string to WordArray, else assume WordArray already
            if (typeof data == 'string') {
              data = Utf8.parse(data);
            } // Append


            this._data.concat(data);

            this._nDataBytes += data.sigBytes;
          },

          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function _process(doFlush) {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4; // Count blocks ready

            var nBlocksReady = dataSigBytes / blockSizeBytes;

            if (doFlush) {
              // Round up to include partial blocks
              nBlocksReady = Math.ceil(nBlocksReady);
            } else {
              // Round down to include only full blocks,
              // less the number of blocks that must remain in the buffer
              nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
            } // Count words ready


            var nWordsReady = nBlocksReady * blockSize; // Count bytes ready

            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes); // Process blocks

            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                // Perform concrete-algorithm logic
                this._doProcessBlock(dataWords, offset);
              } // Remove processed words


              var processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            } // Return processed words


            return new WordArray.init(processedWords, nBytesReady);
          },

          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function clone() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        /**
         * Abstract hasher template.
         *
         * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
         */

        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),

          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function init(cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg); // Set initial values

            this.reset();
          },

          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function reset() {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this); // Perform concrete-hasher logic

            this._doReset();
          },

          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function update(messageUpdate) {
            // Append
            this._append(messageUpdate); // Update the hash


            this._process(); // Chainable


            return this;
          },

          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function finalize(messageUpdate) {
            // Final message update
            if (messageUpdate) {
              this._append(messageUpdate);
            } // Perform concrete-hasher logic


            var hash = this._doFinalize();

            return hash;
          },
          blockSize: 512 / 32,

          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function _createHelper(hasher) {
            return function (message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },

          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function _createHmacHelper(hasher) {
            return function (message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        /**
         * Algorithm namespace.
         */

        var C_algo = C.algo = {};
        return C;
      }(Math);

      return CryptoJS;
    });
  });

  var encBase64 = createCommonjsModule(function (module, exports) {

    (function (root, factory) {
      {
        // CommonJS
        module.exports = exports = factory(core);
      }
    })(commonjsGlobal, function (CryptoJS) {
      (function () {
        // Shortcuts
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        /**
         * Base64 encoding strategy.
         */

        var Base64 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function stringify(wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map; // Clamp excess bits

            wordArray.clamp(); // Convert

            var base64Chars = [];

            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 0xff;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 0xff;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;

              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 0x3f));
              }
            } // Add padding


            var paddingChar = map.charAt(64);

            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }

            return base64Chars.join('');
          },

          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function parse(base64Str) {
            // Shortcuts
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;

            if (!reverseMap) {
              reverseMap = this._reverseMap = [];

              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            } // Ignore padding


            var paddingChar = map.charAt(64);

            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);

              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            } // Convert


            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
        };

        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;

          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }

          return WordArray.create(words, nBytes);
        }
      })();

      return CryptoJS.enc.Base64;
    });
  });

  var md5 = createCommonjsModule(function (module, exports) {

    (function (root, factory) {
      {
        // CommonJS
        module.exports = exports = factory(core);
      }
    })(commonjsGlobal, function (CryptoJS) {
      (function (Math) {
        // Shortcuts
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo; // Constants table

        var T = []; // Compute constants

        (function () {
          for (var i = 0; i < 64; i++) {
            T[i] = Math.abs(Math.sin(i + 1)) * 0x100000000 | 0;
          }
        })();
        /**
         * MD5 hash algorithm.
         */


        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function _doReset() {
            this._hash = new WordArray.init([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]);
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            // Swap endian
            for (var i = 0; i < 16; i++) {
              // Shortcuts
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 0x00ff00ff | (M_offset_i << 24 | M_offset_i >>> 8) & 0xff00ff00;
            } // Shortcuts


            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15]; // Working varialbes

            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3]; // Computation

            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]); // Intermediate hash value

            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function _doFinalize() {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8; // Add padding

            dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 0x00ff00ff | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 0xff00ff00;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 0x00ff00ff | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 0xff00ff00;
            data.sigBytes = (dataWords.length + 1) * 4; // Hash final blocks

            this._process(); // Shortcuts


            var hash = this._hash;
            var H = hash.words; // Swap endian

            for (var i = 0; i < 4; i++) {
              // Shortcut
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 0x00ff00ff | (H_i << 24 | H_i >>> 8) & 0xff00ff00;
            } // Return final computed hash


            return hash;
          },
          clone: function clone() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });

        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }

        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }

        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }

        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        /**
         * Shortcut function to the hasher's object interface.
         *
         * @param {WordArray|string} message The message to hash.
         *
         * @return {WordArray} The hash.
         *
         * @static
         *
         * @example
         *
         *     var hash = CryptoJS.MD5('message');
         *     var hash = CryptoJS.MD5(wordArray);
         */


        C.MD5 = Hasher._createHelper(MD5);
        /**
         * Shortcut function to the HMAC's object interface.
         *
         * @param {WordArray|string} message The message to hash.
         * @param {WordArray|string} key The secret key.
         *
         * @return {WordArray} The HMAC.
         *
         * @static
         *
         * @example
         *
         *     var hmac = CryptoJS.HmacMD5(message, key);
         */

        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);

      return CryptoJS.MD5;
    });
  });

  var sha1 = createCommonjsModule(function (module, exports) {

    (function (root, factory) {
      {
        // CommonJS
        module.exports = exports = factory(core);
      }
    })(commonjsGlobal, function (CryptoJS) {
      (function () {
        // Shortcuts
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo; // Reusable object

        var W = [];
        /**
         * SHA-1 hash algorithm.
         */

        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function _doReset() {
            this._hash = new WordArray.init([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            // Shortcut
            var H = this._hash.words; // Working variables

            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4]; // Computation

            for (var i = 0; i < 80; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = n << 1 | n >>> 31;
              }

              var t = (a << 5 | a >>> 27) + e + W[i];

              if (i < 20) {
                t += (b & c | ~b & d) + 0x5a827999;
              } else if (i < 40) {
                t += (b ^ c ^ d) + 0x6ed9eba1;
              } else if (i < 60) {
                t += (b & c | b & d | c & d) - 0x70e44324;
              } else
                /* if (i < 80) */
                {
                  t += (b ^ c ^ d) - 0x359d3e2a;
                }

              e = d;
              d = c;
              c = b << 30 | b >>> 2;
              b = a;
              a = t;
            } // Intermediate hash value


            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e | 0;
          },
          _doFinalize: function _doFinalize() {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8; // Add padding

            dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4; // Hash final blocks

            this._process(); // Return final computed hash


            return this._hash;
          },
          clone: function clone() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        /**
         * Shortcut function to the hasher's object interface.
         *
         * @param {WordArray|string} message The message to hash.
         *
         * @return {WordArray} The hash.
         *
         * @static
         *
         * @example
         *
         *     var hash = CryptoJS.SHA1('message');
         *     var hash = CryptoJS.SHA1(wordArray);
         */

        C.SHA1 = Hasher._createHelper(SHA1);
        /**
         * Shortcut function to the HMAC's object interface.
         *
         * @param {WordArray|string} message The message to hash.
         * @param {WordArray|string} key The secret key.
         *
         * @return {WordArray} The HMAC.
         *
         * @static
         *
         * @example
         *
         *     var hmac = CryptoJS.HmacSHA1(message, key);
         */

        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();

      return CryptoJS.SHA1;
    });
  });

  var hmac = createCommonjsModule(function (module, exports) {

    (function (root, factory) {
      {
        // CommonJS
        module.exports = exports = factory(core);
      }
    })(commonjsGlobal, function (CryptoJS) {
      (function () {
        // Shortcuts
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        /**
         * HMAC algorithm.
         */

        var HMAC = C_algo.HMAC = Base.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function init(hasher, key) {
            // Init hasher
            hasher = this._hasher = new hasher.init(); // Convert string to WordArray, else assume WordArray already

            if (typeof key == 'string') {
              key = Utf8.parse(key);
            } // Shortcuts


            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4; // Allow arbitrary length keys

            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            } // Clamp excess bits


            key.clamp(); // Clone key for inner and outer pads

            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone(); // Shortcuts

            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words; // XOR keys with pad constants

            for (var i = 0; i < hasherBlockSize; i++) {
              oKeyWords[i] ^= 0x5c5c5c5c;
              iKeyWords[i] ^= 0x36363636;
            }

            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes; // Set initial values

            this.reset();
          },

          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function reset() {
            // Shortcut
            var hasher = this._hasher; // Reset

            hasher.reset();
            hasher.update(this._iKey);
          },

          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function update(messageUpdate) {
            this._hasher.update(messageUpdate); // Chainable


            return this;
          },

          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function finalize(messageUpdate) {
            // Shortcut
            var hasher = this._hasher; // Compute HMAC

            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
      })();
    });
  });

  var evpkdf = createCommonjsModule(function (module, exports) {

    (function (root, factory, undef) {
      {
        // CommonJS
        module.exports = exports = factory(core, sha1, hmac);
      }
    })(commonjsGlobal, function (CryptoJS) {
      (function () {
        // Shortcuts
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD5 = C_algo.MD5;
        /**
         * This key derivation function is meant to conform with EVP_BytesToKey.
         * www.openssl.org/docs/crypto/EVP_BytesToKey.html
         */

        var EvpKDF = C_algo.EvpKDF = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),

          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function init(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },

          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function compute(password, salt) {
            // Shortcut
            var cfg = this.cfg; // Init hasher

            var hasher = cfg.hasher.create(); // Initial values

            var derivedKey = WordArray.create(); // Shortcuts

            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations; // Generate key

            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }

              var block = hasher.update(password).finalize(salt);
              hasher.reset(); // Iterations

              for (var i = 1; i < iterations; i++) {
                block = hasher.finalize(block);
                hasher.reset();
              }

              derivedKey.concat(block);
            }

            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        /**
         * Derives a key from a password.
         *
         * @param {WordArray|string} password The password.
         * @param {WordArray|string} salt A salt.
         * @param {Object} cfg (Optional) The configuration options to use for this computation.
         *
         * @return {WordArray} The derived key.
         *
         * @static
         *
         * @example
         *
         *     var key = CryptoJS.EvpKDF(password, salt);
         *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
         *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
         */

        C.EvpKDF = function (password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();

      return CryptoJS.EvpKDF;
    });
  });

  var cipherCore = createCommonjsModule(function (module, exports) {

    (function (root, factory, undef) {
      {
        // CommonJS
        module.exports = exports = factory(core, evpkdf);
      }
    })(commonjsGlobal, function (CryptoJS) {
      /**
       * Cipher core components.
       */
      CryptoJS.lib.Cipher || function (undefined$1) {
        // Shortcuts
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        /**
         * Abstract base cipher template.
         *
         * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
         * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
         * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
         * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
         */

        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base.extend(),

          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function createEncryptor(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },

          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function createDecryptor(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },

          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function init(xformMode, key, cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg); // Store transform mode and key

            this._xformMode = xformMode;
            this._key = key; // Set initial values

            this.reset();
          },

          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function reset() {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this); // Perform concrete-cipher logic

            this._doReset();
          },

          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function process(dataUpdate) {
            // Append
            this._append(dataUpdate); // Process available blocks


            return this._process();
          },

          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function finalize(dataUpdate) {
            // Final data update
            if (dataUpdate) {
              this._append(dataUpdate);
            } // Perform concrete-cipher logic


            var finalProcessedData = this._doFinalize();

            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,

          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: function () {
            function selectCipherStrategy(key) {
              if (typeof key == 'string') {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }

            return function (cipher) {
              return {
                encrypt: function encrypt(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function decrypt(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        /**
         * Abstract base stream cipher template.
         *
         * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
         */

        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function _doFinalize() {
            // Process partial blocks
            var finalProcessedBlocks = this._process(!!'flush');

            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        /**
         * Mode namespace.
         */

        var C_mode = C.mode = {};
        /**
         * Abstract base block cipher mode template.
         */

        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function createEncryptor(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },

          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function createDecryptor(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },

          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function init(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        /**
         * Cipher Block Chaining mode.
         */

        var CBC = C_mode.CBC = function () {
          /**
           * Abstract base CBC mode.
           */
          var CBC = BlockCipherMode.extend();
          /**
           * CBC encryptor.
           */

          CBC.Encryptor = CBC.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function processBlock(words, offset) {
              // Shortcuts
              var cipher = this._cipher;
              var blockSize = cipher.blockSize; // XOR and encrypt

              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset); // Remember this block to use with next block

              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          /**
           * CBC decryptor.
           */

          CBC.Decryptor = CBC.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function processBlock(words, offset) {
              // Shortcuts
              var cipher = this._cipher;
              var blockSize = cipher.blockSize; // Remember this block to use with next block

              var thisBlock = words.slice(offset, offset + blockSize); // Decrypt and XOR

              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize); // This block becomes the previous block

              this._prevBlock = thisBlock;
            }
          });

          function xorBlock(words, offset, blockSize) {
            // Shortcut
            var iv = this._iv; // Choose mixing block

            if (iv) {
              var block = iv; // Remove IV for subsequent blocks

              this._iv = undefined$1;
            } else {
              var block = this._prevBlock;
            } // XOR blocks


            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= block[i];
            }
          }

          return CBC;
        }();
        /**
         * Padding namespace.
         */


        var C_pad = C.pad = {};
        /**
         * PKCS #5/7 padding strategy.
         */

        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function pad(data, blockSize) {
            // Shortcut
            var blockSizeBytes = blockSize * 4; // Count padding bytes

            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes; // Create padding word

            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes; // Create padding

            var paddingWords = [];

            for (var i = 0; i < nPaddingBytes; i += 4) {
              paddingWords.push(paddingWord);
            }

            var padding = WordArray.create(paddingWords, nPaddingBytes); // Add padding

            data.concat(padding);
          },

          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function unpad(data) {
            // Get number of padding bytes from last byte
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 0xff; // Remove padding

            data.sigBytes -= nPaddingBytes;
          }
        };
        /**
         * Abstract base block cipher template.
         *
         * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
         */

        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function reset() {
            // Reset cipher
            Cipher.reset.call(this); // Shortcuts

            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode; // Reset block mode

            if (this._xformMode == this._ENC_XFORM_MODE) {
              var modeCreator = mode.createEncryptor;
            } else
              /* if (this._xformMode == this._DEC_XFORM_MODE) */
              {
                var modeCreator = mode.createDecryptor; // Keep at least one block in the buffer for unpadding

                this._minBufferSize = 1;
              }

            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function _doProcessBlock(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function _doFinalize() {
            // Shortcut
            var padding = this.cfg.padding; // Finalize

            if (this._xformMode == this._ENC_XFORM_MODE) {
              // Pad data
              padding.pad(this._data, this.blockSize); // Process final blocks

              var finalProcessedBlocks = this._process(!!'flush');
            } else
              /* if (this._xformMode == this._DEC_XFORM_MODE) */
              {
                // Process final blocks
                var finalProcessedBlocks = this._process(!!'flush'); // Unpad data


                padding.unpad(finalProcessedBlocks);
              }

            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        /**
         * A collection of cipher parameters.
         *
         * @property {WordArray} ciphertext The raw ciphertext.
         * @property {WordArray} key The key to this ciphertext.
         * @property {WordArray} iv The IV used in the ciphering operation.
         * @property {WordArray} salt The salt used with a key derivation function.
         * @property {Cipher} algorithm The cipher algorithm.
         * @property {Mode} mode The block mode used in the ciphering operation.
         * @property {Padding} padding The padding scheme used in the ciphering operation.
         * @property {number} blockSize The block size of the cipher.
         * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
         */

        var CipherParams = C_lib.CipherParams = Base.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function init(cipherParams) {
            this.mixIn(cipherParams);
          },

          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function toString(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        /**
         * Format namespace.
         */

        var C_format = C.format = {};
        /**
         * OpenSSL formatting strategy.
         */

        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function stringify(cipherParams) {
            // Shortcuts
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt; // Format

            if (salt) {
              var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
            } else {
              var wordArray = ciphertext;
            }

            return wordArray.toString(Base64);
          },

          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function parse(openSSLStr) {
            // Parse base64
            var ciphertext = Base64.parse(openSSLStr); // Shortcut

            var ciphertextWords = ciphertext.words; // Test for salt

            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
              // Extract salt
              var salt = WordArray.create(ciphertextWords.slice(2, 4)); // Remove salt from ciphertext

              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }

            return CipherParams.create({
              ciphertext: ciphertext,
              salt: salt
            });
          }
        };
        /**
         * A cipher wrapper that returns ciphertext as a serializable cipher params object.
         */

        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),

          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function encrypt(cipher, message, key, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg); // Encrypt

            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message); // Shortcut

            var cipherCfg = encryptor.cfg; // Create and return serializable cipher params

            return CipherParams.create({
              ciphertext: ciphertext,
              key: key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },

          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function decrypt(cipher, ciphertext, key, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg); // Convert string to CipherParams

            ciphertext = this._parse(ciphertext, cfg.format); // Decrypt

            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },

          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function _parse(ciphertext, format) {
            if (typeof ciphertext == 'string') {
              return format.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        /**
         * Key derivation function namespace.
         */

        var C_kdf = C.kdf = {};
        /**
         * OpenSSL key derivation function.
         */

        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function execute(password, keySize, ivSize, salt) {
            // Generate random salt
            if (!salt) {
              salt = WordArray.random(64 / 8);
            } // Derive key and IV


            var key = EvpKDF.create({
              keySize: keySize + ivSize
            }).compute(password, salt); // Separate key and IV

            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4; // Return params

            return CipherParams.create({
              key: key,
              iv: iv,
              salt: salt
            });
          }
        };
        /**
         * A serializable cipher wrapper that derives the key from a password,
         * and returns ciphertext as a serializable cipher params object.
         */

        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),

          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function encrypt(cipher, message, password, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg); // Derive key and other params

            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize); // Add IV to config

            cfg.iv = derivedParams.iv; // Encrypt

            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg); // Mix in derived params

            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },

          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function decrypt(cipher, ciphertext, password, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg); // Convert string to CipherParams

            ciphertext = this._parse(ciphertext, cfg.format); // Derive key and other params

            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt); // Add IV to config

            cfg.iv = derivedParams.iv; // Decrypt

            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  });

  var aes = createCommonjsModule(function (module, exports) {

    (function (root, factory, undef) {
      {
        // CommonJS
        module.exports = exports = factory(core, encBase64, md5, evpkdf, cipherCore);
      }
    })(commonjsGlobal, function (CryptoJS) {
      (function () {
        // Shortcuts
        var C = CryptoJS;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo; // Lookup tables

        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = []; // Compute lookup tables

        (function () {
          // Compute double table
          var d = [];

          for (var i = 0; i < 256; i++) {
            if (i < 128) {
              d[i] = i << 1;
            } else {
              d[i] = i << 1 ^ 0x11b;
            }
          } // Walk GF(2^8)


          var x = 0;
          var xi = 0;

          for (var i = 0; i < 256; i++) {
            // Compute sbox
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
            SBOX[x] = sx;
            INV_SBOX[sx] = x; // Compute multiplication

            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4]; // Compute sub bytes, mix columns tables

            var t = d[sx] * 0x101 ^ sx * 0x1010100;
            SUB_MIX_0[x] = t << 24 | t >>> 8;
            SUB_MIX_1[x] = t << 16 | t >>> 16;
            SUB_MIX_2[x] = t << 8 | t >>> 24;
            SUB_MIX_3[x] = t; // Compute inv sub bytes, inv mix columns tables

            var t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
            INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
            INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
            INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
            INV_SUB_MIX_3[sx] = t; // Compute next counter

            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d[d[d[x8 ^ x2]]];
              xi ^= d[d[xi]];
            }
          }
        })(); // Precomputed Rcon lookup


        var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
        /**
         * AES block cipher algorithm.
         */

        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function _doReset() {
            // Skip reset of nRounds has been set before and key did not change
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            } // Shortcuts


            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4; // Compute number of rounds

            var nRounds = this._nRounds = keySize + 6; // Compute number of key schedule rows

            var ksRows = (nRounds + 1) * 4; // Compute key schedule

            var keySchedule = this._keySchedule = [];

            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                var t = keySchedule[ksRow - 1];

                if (!(ksRow % keySize)) {
                  // Rot word
                  t = t << 8 | t >>> 24; // Sub word

                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 0xff] << 16 | SBOX[t >>> 8 & 0xff] << 8 | SBOX[t & 0xff]; // Mix Rcon

                  t ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  // Sub word
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 0xff] << 16 | SBOX[t >>> 8 & 0xff] << 8 | SBOX[t & 0xff];
                }

                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
              }
            } // Compute inv key schedule


            var invKeySchedule = this._invKeySchedule = [];

            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;

              if (invKsRow % 4) {
                var t = keySchedule[ksRow];
              } else {
                var t = keySchedule[ksRow - 4];
              }

              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 0xff]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
              }
            }
          },
          encryptBlock: function encryptBlock(M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function decryptBlock(M, offset) {
            // Swap 2nd and 4th rows
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;

            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX); // Inv swap 2nd and 4th rows


            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
          },
          _doCryptBlock: function _doCryptBlock(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
            // Shortcut
            var nRounds = this._nRounds; // Get input, add round key

            var s0 = M[offset] ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3]; // Key schedule row counter

            var ksRow = 4; // Rounds

            for (var round = 1; round < nRounds; round++) {
              // Shift rows, sub bytes, mix columns, add round key
              var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[s1 >>> 16 & 0xff] ^ SUB_MIX_2[s2 >>> 8 & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[s2 >>> 16 & 0xff] ^ SUB_MIX_2[s3 >>> 8 & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[s3 >>> 16 & 0xff] ^ SUB_MIX_2[s0 >>> 8 & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[s0 >>> 16 & 0xff] ^ SUB_MIX_2[s1 >>> 8 & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++]; // Update state

              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            } // Shift rows, sub bytes, add round key


            var t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 0xff] << 16 | SBOX[s2 >>> 8 & 0xff] << 8 | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
            var t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 0xff] << 16 | SBOX[s3 >>> 8 & 0xff] << 8 | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
            var t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 0xff] << 16 | SBOX[s0 >>> 8 & 0xff] << 8 | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
            var t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 0xff] << 16 | SBOX[s1 >>> 8 & 0xff] << 8 | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]; // Set output

            M[offset] = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        /**
         * Shortcut functions to the cipher's object interface.
         *
         * @example
         *
         *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
         *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
         */

        C.AES = BlockCipher._createHelper(AES);
      })();

      return CryptoJS.AES;
    });
  });

  var encUtf8 = createCommonjsModule(function (module, exports) {

    (function (root, factory) {
      {
        // CommonJS
        module.exports = exports = factory(core);
      }
    })(commonjsGlobal, function (CryptoJS) {
      return CryptoJS.enc.Utf8;
    });
  });

  /**
   * toString ref.
   */
  var toString$1 = Object.prototype.toString;
  /**
   * Return the type of `val`.
   *
   * @param {Mixed} val
   * @return {String}
   * @api public
   */

  var componentType$1 = function componentType(val) {
    switch (toString$1.call(val)) {
      case '[object Date]':
        return 'date';

      case '[object RegExp]':
        return 'regexp';

      case '[object Arguments]':
        return 'arguments';

      case '[object Array]':
        return 'array';

      case '[object Error]':
        return 'error';
    }

    if (val === null) return 'null';
    if (val === undefined) return 'undefined';
    if (val !== val) return 'nan';
    if (val && val.nodeType === 1) return 'element';
    if (isBuffer(val)) return 'buffer';
    val = val.valueOf ? val.valueOf() : Object.prototype.valueOf.apply(val);
    return _typeof(val);
  }; // code borrowed from https://github.com/feross/is-buffer/blob/master/index.js


  function isBuffer(obj) {
    return !!(obj != null && (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
    obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)));
  }

  /*
   * Module dependencies.
   */

  /**
   * Deeply clone an object.
   *
   * @param {*} obj Any object.
   */


  var clone = function clone(obj) {
    var t = componentType$1(obj);

    if (t === 'object') {
      var copy = {};

      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          copy[key] = clone(obj[key]);
        }
      }

      return copy;
    }

    if (t === 'array') {
      var copy = new Array(obj.length);

      for (var i = 0, l = obj.length; i < l; i++) {
        copy[i] = clone(obj[i]);
      }

      return copy;
    }

    if (t === 'regexp') {
      // from millermedeiros/amd-utils - MIT
      var flags = '';
      flags += obj.multiline ? 'm' : '';
      flags += obj.global ? 'g' : '';
      flags += obj.ignoreCase ? 'i' : '';
      return new RegExp(obj.source, flags);
    }

    if (t === 'date') {
      return new Date(obj.getTime());
    } // string, number, boolean, etc.


    return obj;
  };
  /*
   * Exports.
   */


  var clone_1 = clone;

  /**
   * Helpers.
   */
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} options
   * @return {String|Number}
   * @api public
   */

  var ms = function ms(val, options) {
    options = options || {};
    if ('string' == typeof val) return parse$2(val);
    return options.long ? long(val) : short(val);
  };
  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */


  function parse$2(str) {
    str = '' + str;
    if (str.length > 10000) return;
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) return;
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();

    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;

      case 'days':
      case 'day':
      case 'd':
        return n * d;

      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;

      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;

      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;

      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
    }
  }
  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */


  function short(ms) {
    if (ms >= d) return Math.round(ms / d) + 'd';
    if (ms >= h) return Math.round(ms / h) + 'h';
    if (ms >= m) return Math.round(ms / m) + 'm';
    if (ms >= s) return Math.round(ms / s) + 's';
    return ms + 'ms';
  }
  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */


  function long(ms) {
    return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
  }
  /**
   * Pluralization helper.
   */


  function plural(ms, n, name) {
    if (ms < n) return;
    if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
    return Math.ceil(ms / n) + ' ' + name + 's';
  }

  var debug_1 = createCommonjsModule(function (module, exports) {
    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     *
     * Expose `debug()` as the module.
     */
    exports = module.exports = debug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = ms;
    /**
     * The currently active debug mode names, and names to skip.
     */

    exports.names = [];
    exports.skips = [];
    /**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lowercased letter, i.e. "n".
     */

    exports.formatters = {};
    /**
     * Previously assigned color.
     */

    var prevColor = 0;
    /**
     * Previous log timestamp.
     */

    var prevTime;
    /**
     * Select a color.
     *
     * @return {Number}
     * @api private
     */

    function selectColor() {
      return exports.colors[prevColor++ % exports.colors.length];
    }
    /**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */


    function debug(namespace) {
      // define the `disabled` version
      function disabled() {}

      disabled.enabled = false; // define the `enabled` version

      function enabled() {
        var self = enabled; // set `diff` timestamp

        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr; // add the `color` if not set

        if (null == self.useColors) self.useColors = exports.useColors();
        if (null == self.color && self.useColors) self.color = selectColor();
        var args = Array.prototype.slice.call(arguments);
        args[0] = exports.coerce(args[0]);

        if ('string' !== typeof args[0]) {
          // anything else let's inspect with %o
          args = ['%o'].concat(args);
        } // apply any `formatters` transformations


        var index = 0;
        args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
          // if we encounter an escaped % then don't increase the array index
          if (match === '%%') return match;
          index++;
          var formatter = exports.formatters[format];

          if ('function' === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val); // now we need to remove `args[index]` since it's inlined in the `format`

            args.splice(index, 1);
            index--;
          }

          return match;
        });

        if ('function' === typeof exports.formatArgs) {
          args = exports.formatArgs.apply(self, args);
        }

        var logFn = enabled.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }

      enabled.enabled = true;
      var fn = exports.enabled(namespace) ? enabled : disabled;
      fn.namespace = namespace;
      return fn;
    }
    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */


    function enable(namespaces) {
      exports.save(namespaces);
      var split = (namespaces || '').split(/[\s,]+/);
      var len = split.length;

      for (var i = 0; i < len; i++) {
        if (!split[i]) continue; // ignore empty strings

        namespaces = split[i].replace(/\*/g, '.*?');

        if (namespaces[0] === '-') {
          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          exports.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }
    /**
     * Disable debug output.
     *
     * @api public
     */


    function disable() {
      exports.enable('');
    }
    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */


    function enabled(name) {
      var i, len;

      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }

      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }

      return false;
    }
    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */


    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  });
  var debug_2 = debug_1.coerce;
  var debug_3 = debug_1.disable;
  var debug_4 = debug_1.enable;
  var debug_5 = debug_1.enabled;
  var debug_6 = debug_1.humanize;
  var debug_7 = debug_1.names;
  var debug_8 = debug_1.skips;
  var debug_9 = debug_1.formatters;

  var browser = createCommonjsModule(function (module, exports) {
    /**
     * This is the web browser implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */
    exports = module.exports = debug_1;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
    /**
     * Colors.
     */

    exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    function useColors() {
      // is webkit? http://stackoverflow.com/a/16459606/376773
      return 'WebkitAppearance' in document.documentElement.style || // is firebug? http://stackoverflow.com/a/398120/376773
      window.console && (console.firebug || console.exception && console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
    }
    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */


    exports.formatters.j = function (v) {
      return JSON.stringify(v);
    };
    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */


    function formatArgs() {
      var args = arguments;
      var useColors = this.useColors;
      args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
      if (!useColors) return args;
      var c = 'color: ' + this.color;
      args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1)); // the final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into

      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-z%]/g, function (match) {
        if ('%%' === match) return;
        index++;

        if ('%c' === match) {
          // we only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
      return args;
    }
    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */


    function log() {
      // this hackery is required for IE8/9, where
      // the `console.log` function doesn't have 'apply'
      return 'object' === (typeof console === "undefined" ? "undefined" : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */


    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem('debug');
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {}
    }
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */


    function load() {
      var r;

      try {
        r = exports.storage.debug;
      } catch (e) {}

      return r;
    }
    /**
     * Enable namespaces listed in `localStorage.debug` initially.
     */


    exports.enable(load());
    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {}
    }
  });
  var browser_1 = browser.log;
  var browser_2 = browser.formatArgs;
  var browser_3 = browser.save;
  var browser_4 = browser.load;
  var browser_5 = browser.useColors;
  var browser_6 = browser.storage;
  var browser_7 = browser.colors;

  /**
   * Module dependencies.
   */

  var debug = browser('cookie');
  /**
   * Set or get cookie `name` with `value` and `options` object.
   *
   * @param {String} name
   * @param {String} value
   * @param {Object} options
   * @return {Mixed}
   * @api public
   */

  var rudderComponentCookie = function rudderComponentCookie(name, value, options) {
    switch (arguments.length) {
      case 3:
      case 2:
        return set(name, value, options);

      case 1:
        return get(name);

      default:
        return all();
    }
  };
  /**
   * Set cookie `name` to `value`.
   *
   * @param {String} name
   * @param {String} value
   * @param {Object} options
   * @api private
   */


  function set(name, value, options) {
    options = options || {};
    var str = encode$1(name) + '=' + encode$1(value);
    if (null == value) options.maxage = -1;

    if (options.maxage) {
      options.expires = new Date(+new Date() + options.maxage);
    }

    if (options.path) str += '; path=' + options.path;
    if (options.domain) str += '; domain=' + options.domain;
    if (options.expires) str += '; expires=' + options.expires.toUTCString();
    if (options.samesite) str += '; samesite=' + options.samesite;
    if (options.secure) str += '; secure';
    document.cookie = str;
  }
  /**
   * Return all cookies.
   *
   * @return {Object}
   * @api private
   */


  function all() {
    var str;

    try {
      str = document.cookie;
    } catch (err) {
      if (typeof console !== 'undefined' && typeof console.error === 'function') {
        console.error(err.stack || err);
      }

      return {};
    }

    return parse$3(str);
  }
  /**
   * Get cookie `name`.
   *
   * @param {String} name
   * @return {String}
   * @api private
   */


  function get(name) {
    return all()[name];
  }
  /**
   * Parse cookie `str`.
   *
   * @param {String} str
   * @return {Object}
   * @api private
   */


  function parse$3(str) {
    var obj = {};
    var pairs = str.split(/ *; */);
    var pair;
    if ('' == pairs[0]) return obj;

    for (var i = 0; i < pairs.length; ++i) {
      pair = pairs[i].split('=');
      obj[decode$1(pair[0])] = decode$1(pair[1]);
    }

    return obj;
  }
  /**
   * Encode.
   */


  function encode$1(value) {
    try {
      return encodeURIComponent(value);
    } catch (e) {
      debug('error `encode(%o)` - %o', value, e);
    }
  }
  /**
   * Decode.
   */


  function decode$1(value) {
    try {
      return decodeURIComponent(value);
    } catch (e) {
      debug('error `decode(%o)` - %o', value, e);
    }
  }

  var max = Math.max;
  /**
   * Produce a new array composed of all but the first `n` elements of an input `collection`.
   *
   * @name drop
   * @api public
   * @param {number} count The number of elements to drop.
   * @param {Array} collection The collection to iterate over.
   * @return {Array} A new array containing all but the first element from `collection`.
   * @example
   * drop(0, [1, 2, 3]); // => [1, 2, 3]
   * drop(1, [1, 2, 3]); // => [2, 3]
   * drop(2, [1, 2, 3]); // => [3]
   * drop(3, [1, 2, 3]); // => []
   * drop(4, [1, 2, 3]); // => []
   */

  var drop = function drop(count, collection) {
    var length = collection ? collection.length : 0;

    if (!length) {
      return [];
    } // Preallocating an array *significantly* boosts performance when dealing with
    // `arguments` objects on v8. For a summary, see:
    // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments


    var toDrop = max(Number(count) || 0, 0);
    var resultsLength = max(length - toDrop, 0);
    var results = new Array(resultsLength);

    for (var i = 0; i < resultsLength; i += 1) {
      results[i] = collection[i + toDrop];
    }

    return results;
  };
  /*
   * Exports.
   */


  var drop_1 = drop;

  var max$1 = Math.max;
  /**
   * Produce a new array by passing each value in the input `collection` through a transformative
   * `iterator` function. The `iterator` function is passed three arguments:
   * `(value, index, collection)`.
   *
   * @name rest
   * @api public
   * @param {Array} collection The collection to iterate over.
   * @return {Array} A new array containing all but the first element from `collection`.
   * @example
   * rest([1, 2, 3]); // => [2, 3]
   */

  var rest = function rest(collection) {
    if (collection == null || !collection.length) {
      return [];
    } // Preallocating an array *significantly* boosts performance when dealing with
    // `arguments` objects on v8. For a summary, see:
    // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments


    var results = new Array(max$1(collection.length - 2, 0));

    for (var i = 1; i < collection.length; i += 1) {
      results[i - 1] = collection[i];
    }

    return results;
  };
  /*
   * Exports.
   */


  var rest_1 = rest;

  /*
   * Module dependencies.
   */


  var has$2 = Object.prototype.hasOwnProperty;
  var objToString$1 = Object.prototype.toString;
  /**
   * Returns `true` if a value is an object, otherwise `false`.
   *
   * @name isObject
   * @api private
   * @param {*} val The value to test.
   * @return {boolean}
   */
  // TODO: Move to a library

  var isObject = function isObject(value) {
    return Boolean(value) && _typeof(value) === 'object';
  };
  /**
   * Returns `true` if a value is a plain object, otherwise `false`.
   *
   * @name isPlainObject
   * @api private
   * @param {*} val The value to test.
   * @return {boolean}
   */
  // TODO: Move to a library


  var isPlainObject = function isPlainObject(value) {
    return Boolean(value) && objToString$1.call(value) === '[object Object]';
  };
  /**
   * Assigns a key-value pair to a target object when the value assigned is owned,
   * and where target[key] is undefined.
   *
   * @name shallowCombiner
   * @api private
   * @param {Object} target
   * @param {Object} source
   * @param {*} value
   * @param {string} key
   */


  var shallowCombiner = function shallowCombiner(target, source, value, key) {
    if (has$2.call(source, key) && target[key] === undefined) {
      target[key] = value;
    }

    return source;
  };
  /**
   * Assigns a key-value pair to a target object when the value assigned is owned,
   * and where target[key] is undefined; also merges objects recursively.
   *
   * @name deepCombiner
   * @api private
   * @param {Object} target
   * @param {Object} source
   * @param {*} value
   * @param {string} key
   * @return {Object}
   */


  var deepCombiner = function deepCombiner(target, source, value, key) {
    if (has$2.call(source, key)) {
      if (isPlainObject(target[key]) && isPlainObject(value)) {
        target[key] = defaultsDeep(target[key], value);
      } else if (target[key] === undefined) {
        target[key] = value;
      }
    }

    return source;
  };
  /**
   * TODO: Document
   *
   * @name defaultsWith
   * @api private
   * @param {Function} combiner
   * @param {Object} target
   * @param {...Object} sources
   * @return {Object} Return the input `target`.
   */


  var defaultsWith = function defaultsWith(combiner, target
  /*, ...sources */
  ) {
    if (!isObject(target)) {
      return target;
    }

    combiner = combiner || shallowCombiner;
    var sources = drop_1(2, arguments);

    for (var i = 0; i < sources.length; i += 1) {
      for (var key in sources[i]) {
        combiner(target, sources[i], sources[i][key], key);
      }
    }

    return target;
  };
  /**
   * Copies owned, enumerable properties from a source object(s) to a target
   * object when the value of that property on the source object is `undefined`.
   * Recurses on objects.
   *
   * @name defaultsDeep
   * @api public
   * @param {Object} target
   * @param {...Object} sources
   * @return {Object} The input `target`.
   */


  var defaultsDeep = function defaultsDeep(target
  /*, sources */
  ) {
    // TODO: Replace with `partial` call?
    return defaultsWith.apply(null, [deepCombiner, target].concat(rest_1(arguments)));
  };
  /**
   * Copies owned, enumerable properties from a source object(s) to a target
   * object when the value of that property on the source object is `undefined`.
   *
   * @name defaults
   * @api public
   * @param {Object} target
   * @param {...Object} sources
   * @return {Object}
   * @example
   * var a = { a: 1 };
   * var b = { a: 2, b: 2 };
   *
   * defaults(a, b);
   * console.log(a); //=> { a: 1, b: 2 }
   */


  var defaults = function defaults(target
  /*, ...sources */
  ) {
    // TODO: Replace with `partial` call?
    return defaultsWith.apply(null, [null, target].concat(rest_1(arguments)));
  };
  /*
   * Exports.
   */


  var defaults_1 = defaults;
  var deep = defaultsDeep;
  defaults_1.deep = deep;

  var json3 = createCommonjsModule(function (module, exports) {
    (function () {
      // Detect the `define` function exposed by asynchronous module loaders. The
      // strict `define` check is necessary for compatibility with `r.js`.
      var isLoader = typeof undefined === "function" ; // A set of types used to distinguish objects from primitives.

      var objectTypes = {
        "function": true,
        "object": true
      }; // Detect the `exports` object exposed by CommonJS implementations.

      var freeExports = objectTypes['object'] && exports && !exports.nodeType && exports; // Use the `global` object exposed by Node (including Browserify via
      // `insert-module-globals`), Narwhal, and Ringo as the default context,
      // and the `window` object in browsers. Rhino exports a `global` function
      // instead.

      var root = objectTypes[typeof window === "undefined" ? "undefined" : _typeof(window)] && window || this,
          freeGlobal = freeExports && objectTypes['object'] && module && !module.nodeType && _typeof(commonjsGlobal) == "object" && commonjsGlobal;

      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
        root = freeGlobal;
      } // Public: Initializes JSON 3 using the given `context` object, attaching the
      // `stringify` and `parse` functions to the specified `exports` object.


      function runInContext(context, exports) {
        context || (context = root.Object());
        exports || (exports = root.Object()); // Native constructor aliases.

        var Number = context.Number || root.Number,
            String = context.String || root.String,
            Object = context.Object || root.Object,
            Date = context.Date || root.Date,
            SyntaxError = context.SyntaxError || root.SyntaxError,
            TypeError = context.TypeError || root.TypeError,
            Math = context.Math || root.Math,
            nativeJSON = context.JSON || root.JSON; // Delegate to the native `stringify` and `parse` implementations.

        if (_typeof(nativeJSON) == "object" && nativeJSON) {
          exports.stringify = nativeJSON.stringify;
          exports.parse = nativeJSON.parse;
        } // Convenience aliases.


        var objectProto = Object.prototype,
            getClass = objectProto.toString,
            isProperty = objectProto.hasOwnProperty,
            undefined$1; // Internal: Contains `try...catch` logic used by other functions.
        // This prevents other functions from being deoptimized.

        function attempt(func, errorFunc) {
          try {
            func();
          } catch (exception) {
            if (errorFunc) {
              errorFunc();
            }
          }
        } // Test the `Date#getUTC*` methods. Based on work by @Yaffle.


        var isExtended = new Date(-3509827334573292);
        attempt(function () {
          // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
          // results for certain dates in Opera >= 10.53.
          isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 && isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
        }); // Internal: Determines whether the native `JSON.stringify` and `parse`
        // implementations are spec-compliant. Based on work by Ken Snyder.

        function has(name) {
          if (has[name] != null) {
            // Return cached feature test result.
            return has[name];
          }

          var isSupported;

          if (name == "bug-string-char-index") {
            // IE <= 7 doesn't support accessing string characters using square
            // bracket notation. IE 8 only supports this for primitives.
            isSupported = "a"[0] != "a";
          } else if (name == "json") {
            // Indicates whether both `JSON.stringify` and `JSON.parse` are
            // supported.
            isSupported = has("json-stringify") && has("date-serialization") && has("json-parse");
          } else if (name == "date-serialization") {
            // Indicates whether `Date`s can be serialized accurately by `JSON.stringify`.
            isSupported = has("json-stringify") && isExtended;

            if (isSupported) {
              var stringify = exports.stringify;
              attempt(function () {
                isSupported = // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' && // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' && // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' && // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
              });
            }
          } else {
            var value,
                serialized = "{\"a\":[1,true,false,null,\"\\u0000\\b\\n\\f\\r\\t\"]}"; // Test `JSON.stringify`.

            if (name == "json-stringify") {
              var stringify = exports.stringify,
                  stringifySupported = typeof stringify == "function";

              if (stringifySupported) {
                // A test function object with a custom `toJSON` method.
                (value = function value() {
                  return 1;
                }).toJSON = value;
                attempt(function () {
                  stringifySupported = // Firefox 3.1b1 and b2 serialize string, number, and boolean
                  // primitives as object literals.
                  stringify(0) === "0" && // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                  // literals.
                  stringify(new Number()) === "0" && stringify(new String()) == '""' && // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                  // does not define a canonical JSON representation (this applies to
                  // objects with `toJSON` properties as well, *unless* they are nested
                  // within an object or array).
                  stringify(getClass) === undefined$1 && // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                  // FF 3.1b3 pass this test.
                  stringify(undefined$1) === undefined$1 && // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                  // respectively, if the value is omitted entirely.
                  stringify() === undefined$1 && // FF 3.1b1, 2 throw an error if the given value is not a number,
                  // string, array, object, Boolean, or `null` literal. This applies to
                  // objects with custom `toJSON` methods as well, unless they are nested
                  // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                  // methods entirely.
                  stringify(value) === "1" && stringify([value]) == "[1]" && // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                  // `"[null]"`.
                  stringify([undefined$1]) == "[null]" && // YUI 3.0.0b1 fails to serialize `null` literals.
                  stringify(null) == "null" && // FF 3.1b1, 2 halts serialization if an array contains a function:
                  // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                  // elides non-JSON values from objects and arrays, unless they
                  // define custom `toJSON` methods.
                  stringify([undefined$1, getClass, null]) == "[null,null,null]" && // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                  // where character escape codes are expected (e.g., `\b` => `\u0008`).
                  stringify({
                    "a": [value, true, false, null, "\x00\b\n\f\r\t"]
                  }) == serialized && // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                  stringify(null, value) === "1" && stringify([1, 2], null, 1) == "[\n 1,\n 2\n]";
                }, function () {
                  stringifySupported = false;
                });
              }

              isSupported = stringifySupported;
            } // Test `JSON.parse`.


            if (name == "json-parse") {
              var parse = exports.parse,
                  parseSupported;

              if (typeof parse == "function") {
                attempt(function () {
                  // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
                  // Conforming implementations should also coerce the initial argument to
                  // a string prior to parsing.
                  if (parse("0") === 0 && !parse(false)) {
                    // Simple parsing test.
                    value = parse(serialized);
                    parseSupported = value["a"].length == 5 && value["a"][0] === 1;

                    if (parseSupported) {
                      attempt(function () {
                        // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                        parseSupported = !parse('"\t"');
                      });

                      if (parseSupported) {
                        attempt(function () {
                          // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                          // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                          // certain octal literals.
                          parseSupported = parse("01") !== 1;
                        });
                      }

                      if (parseSupported) {
                        attempt(function () {
                          // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                          // points. These environments, along with FF 3.1b1 and 2,
                          // also allow trailing commas in JSON objects and arrays.
                          parseSupported = parse("1.") !== 1;
                        });
                      }
                    }
                  }
                }, function () {
                  parseSupported = false;
                });
              }

              isSupported = parseSupported;
            }
          }

          return has[name] = !!isSupported;
        }

        has["bug-string-char-index"] = has["date-serialization"] = has["json"] = has["json-stringify"] = has["json-parse"] = null;

        if (!has("json")) {
          // Common `[[Class]]` name aliases.
          var functionClass = "[object Function]",
              dateClass = "[object Date]",
              numberClass = "[object Number]",
              stringClass = "[object String]",
              arrayClass = "[object Array]",
              booleanClass = "[object Boolean]"; // Detect incomplete support for accessing string characters by index.

          var charIndexBuggy = has("bug-string-char-index"); // Internal: Normalizes the `for...in` iteration algorithm across
          // environments. Each enumerated key is yielded to a `callback` function.

          var _forOwn = function forOwn(object, callback) {
            var size = 0,
                Properties,
                dontEnums,
                property; // Tests for bugs in the current environment's `for...in` algorithm. The
            // `valueOf` property inherits the non-enumerable flag from
            // `Object.prototype` in older versions of IE, Netscape, and Mozilla.

            (Properties = function Properties() {
              this.valueOf = 0;
            }).prototype.valueOf = 0; // Iterate over a new instance of the `Properties` class.

            dontEnums = new Properties();

            for (property in dontEnums) {
              // Ignore all properties inherited from `Object.prototype`.
              if (isProperty.call(dontEnums, property)) {
                size++;
              }
            }

            Properties = dontEnums = null; // Normalize the iteration algorithm.

            if (!size) {
              // A list of non-enumerable properties inherited from `Object.prototype`.
              dontEnums = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"]; // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
              // properties.

              _forOwn = function forOwn(object, callback) {
                var isFunction = getClass.call(object) == functionClass,
                    property,
                    length;
                var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[_typeof(object.hasOwnProperty)] && object.hasOwnProperty || isProperty;

                for (property in object) {
                  // Gecko <= 1.0 enumerates the `prototype` property of functions under
                  // certain conditions; IE does not.
                  if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                    callback(property);
                  }
                } // Manually invoke the callback for each non-enumerable property.


                for (length = dontEnums.length; property = dontEnums[--length];) {
                  if (hasProperty.call(object, property)) {
                    callback(property);
                  }
                }
              };
            } else {
              // No bugs detected; use the standard `for...in` algorithm.
              _forOwn = function forOwn(object, callback) {
                var isFunction = getClass.call(object) == functionClass,
                    property,
                    isConstructor;

                for (property in object) {
                  if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                    callback(property);
                  }
                } // Manually invoke the callback for the `constructor` property due to
                // cross-environment inconsistencies.


                if (isConstructor || isProperty.call(object, property = "constructor")) {
                  callback(property);
                }
              };
            }

            return _forOwn(object, callback);
          }; // Public: Serializes a JavaScript `value` as a JSON string. The optional
          // `filter` argument may specify either a function that alters how object and
          // array members are serialized, or an array of strings and numbers that
          // indicates which properties should be serialized. The optional `width`
          // argument may be either a string or number that specifies the indentation
          // level of the output.


          if (!has("json-stringify") && !has("date-serialization")) {
            // Internal: A map of control characters and their escaped equivalents.
            var Escapes = {
              92: "\\\\",
              34: '\\"',
              8: "\\b",
              12: "\\f",
              10: "\\n",
              13: "\\r",
              9: "\\t"
            }; // Internal: Converts `value` into a zero-padded string such that its
            // length is at least equal to `width`. The `width` must be <= 6.

            var leadingZeroes = "000000";

            var toPaddedString = function toPaddedString(width, value) {
              // The `|| 0` expression is necessary to work around a bug in
              // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
              return (leadingZeroes + (value || 0)).slice(-width);
            }; // Internal: Serializes a date object.


            var _serializeDate = function serializeDate(value) {
              var getData, year, month, date, time, hours, minutes, seconds, milliseconds; // Define additional utility methods if the `Date` methods are buggy.

              if (!isExtended) {
                var floor = Math.floor; // A mapping between the months of the year and the number of days between
                // January 1st and the first of the respective month.

                var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]; // Internal: Calculates the number of days between the Unix epoch and the
                // first day of the given month.

                var getDay = function getDay(year, month) {
                  return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
                };

                getData = function getData(value) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);

                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++) {
                  }

                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++) {
                  }

                  date = 1 + date - getDay(year, month); // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.

                  time = (value % 864e5 + 864e5) % 864e5; // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.

                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                };
              } else {
                getData = function getData(value) {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                };
              }

              _serializeDate = function serializeDate(value) {
                if (value > -1 / 0 && value < 1 / 0) {
                  // Dates are serialized according to the `Date#toJSON` method
                  // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                  // for the ISO 8601 date time string format.
                  getData(value); // Serialize extended years correctly.

                  value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) + // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) + // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
                  year = month = date = hours = minutes = seconds = milliseconds = null;
                } else {
                  value = null;
                }

                return value;
              };

              return _serializeDate(value);
            }; // For environments with `JSON.stringify` but buggy date serialization,
            // we override the native `Date#toJSON` implementation with a
            // spec-compliant one.


            if (has("json-stringify") && !has("date-serialization")) {
              // Internal: the `Date#toJSON` implementation used to override the native one.
              var dateToJSON = function dateToJSON(key) {
                return _serializeDate(this);
              }; // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.


              var nativeStringify = exports.stringify;

              exports.stringify = function (source, filter, width) {
                var nativeToJSON = Date.prototype.toJSON;
                Date.prototype.toJSON = dateToJSON;
                var result = nativeStringify(source, filter, width);
                Date.prototype.toJSON = nativeToJSON;
                return result;
              };
            } else {
              // Internal: Double-quotes a string `value`, replacing all ASCII control
              // characters (characters with code unit values between 0 and 31) with
              // their escaped equivalents. This is an implementation of the
              // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
              var unicodePrefix = "\\u00";

              var escapeChar = function escapeChar(character) {
                var charCode = character.charCodeAt(0),
                    escaped = Escapes[charCode];

                if (escaped) {
                  return escaped;
                }

                return unicodePrefix + toPaddedString(2, charCode.toString(16));
              };

              var reEscape = /[\x00-\x1f\x22\x5c]/g;

              var quote = function quote(value) {
                reEscape.lastIndex = 0;
                return '"' + (reEscape.test(value) ? value.replace(reEscape, escapeChar) : value) + '"';
              }; // Internal: Recursively serializes an object. Implements the
              // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.


              var serialize = function serialize(property, object, callback, properties, whitespace, indentation, stack) {
                var value, type, className, results, element, index, length, prefix, result;
                attempt(function () {
                  // Necessary for host object support.
                  value = object[property];
                });

                if (_typeof(value) == "object" && value) {
                  if (value.getUTCFullYear && getClass.call(value) == dateClass && value.toJSON === Date.prototype.toJSON) {
                    value = _serializeDate(value);
                  } else if (typeof value.toJSON == "function") {
                    value = value.toJSON(property);
                  }
                }

                if (callback) {
                  // If a replacement function was provided, call it to obtain the value
                  // for serialization.
                  value = callback.call(object, property, value);
                } // Exit early if value is `undefined` or `null`.


                if (value == undefined$1) {
                  return value === undefined$1 ? value : "null";
                }

                type = _typeof(value); // Only call `getClass` if the value is an object.

                if (type == "object") {
                  className = getClass.call(value);
                }

                switch (className || type) {
                  case "boolean":
                  case booleanClass:
                    // Booleans are represented literally.
                    return "" + value;

                  case "number":
                  case numberClass:
                    // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
                    // `"null"`.
                    return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";

                  case "string":
                  case stringClass:
                    // Strings are double-quoted and escaped.
                    return quote("" + value);
                } // Recursively serialize objects and arrays.


                if (_typeof(value) == "object") {
                  // Check for cyclic structures. This is a linear search; performance
                  // is inversely proportional to the number of unique nested objects.
                  for (length = stack.length; length--;) {
                    if (stack[length] === value) {
                      // Cyclic structures cannot be serialized by `JSON.stringify`.
                      throw TypeError();
                    }
                  } // Add the object to the stack of traversed objects.


                  stack.push(value);
                  results = []; // Save the current indentation level and indent one additional level.

                  prefix = indentation;
                  indentation += whitespace;

                  if (className == arrayClass) {
                    // Recursively serialize array elements.
                    for (index = 0, length = value.length; index < length; index++) {
                      element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                      results.push(element === undefined$1 ? "null" : element);
                    }

                    result = results.length ? whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : "[" + results.join(",") + "]" : "[]";
                  } else {
                    // Recursively serialize object members. Members are selected from
                    // either a user-specified list of property names, or the object
                    // itself.
                    _forOwn(properties || value, function (property) {
                      var element = serialize(property, value, callback, properties, whitespace, indentation, stack);

                      if (element !== undefined$1) {
                        // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                        // is not the empty string, let `member` {quote(property) + ":"}
                        // be the concatenation of `member` and the `space` character."
                        // The "`space` character" refers to the literal space
                        // character, not the `space` {width} argument provided to
                        // `JSON.stringify`.
                        results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                      }
                    });

                    result = results.length ? whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : "{" + results.join(",") + "}" : "{}";
                  } // Remove the object from the traversed object stack.


                  stack.pop();
                  return result;
                }
              }; // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.


              exports.stringify = function (source, filter, width) {
                var whitespace, callback, properties, className;

                if (objectTypes[_typeof(filter)] && filter) {
                  className = getClass.call(filter);

                  if (className == functionClass) {
                    callback = filter;
                  } else if (className == arrayClass) {
                    // Convert the property names array into a makeshift set.
                    properties = {};

                    for (var index = 0, length = filter.length, value; index < length;) {
                      value = filter[index++];
                      className = getClass.call(value);

                      if (className == "[object String]" || className == "[object Number]") {
                        properties[value] = 1;
                      }
                    }
                  }
                }

                if (width) {
                  className = getClass.call(width);

                  if (className == numberClass) {
                    // Convert the `width` to an integer and create a string containing
                    // `width` number of space characters.
                    if ((width -= width % 1) > 0) {
                      if (width > 10) {
                        width = 10;
                      }

                      for (whitespace = ""; whitespace.length < width;) {
                        whitespace += " ";
                      }
                    }
                  } else if (className == stringClass) {
                    whitespace = width.length <= 10 ? width : width.slice(0, 10);
                  }
                } // Opera <= 7.54u2 discards the values associated with empty string keys
                // (`""`) only if they are used directly within an object member list
                // (e.g., `!("" in { "": 1})`).


                return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
              };
            }
          } // Public: Parses a JSON source string.


          if (!has("json-parse")) {
            var fromCharCode = String.fromCharCode; // Internal: A map of escaped control characters and their unescaped
            // equivalents.

            var Unescapes = {
              92: "\\",
              34: '"',
              47: "/",
              98: "\b",
              116: "\t",
              110: "\n",
              102: "\f",
              114: "\r"
            }; // Internal: Stores the parser state.

            var Index, Source; // Internal: Resets the parser state and throws a `SyntaxError`.

            var abort = function abort() {
              Index = Source = null;
              throw SyntaxError();
            }; // Internal: Returns the next token, or `"$"` if the parser has reached
            // the end of the source string. A token may be a string, number, `null`
            // literal, or Boolean literal.


            var lex = function lex() {
              var source = Source,
                  length = source.length,
                  value,
                  begin,
                  position,
                  isSigned,
                  charCode;

              while (Index < length) {
                charCode = source.charCodeAt(Index);

                switch (charCode) {
                  case 9:
                  case 10:
                  case 13:
                  case 32:
                    // Skip whitespace tokens, including tabs, carriage returns, line
                    // feeds, and space characters.
                    Index++;
                    break;

                  case 123:
                  case 125:
                  case 91:
                  case 93:
                  case 58:
                  case 44:
                    // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                    // the current position.
                    value = charIndexBuggy ? source.charAt(Index) : source[Index];
                    Index++;
                    return value;

                  case 34:
                    // `"` delimits a JSON string; advance to the next character and
                    // begin parsing the string. String tokens are prefixed with the
                    // sentinel `@` character to distinguish them from punctuators and
                    // end-of-string tokens.
                    for (value = "@", Index++; Index < length;) {
                      charCode = source.charCodeAt(Index);

                      if (charCode < 32) {
                        // Unescaped ASCII control characters (those with a code unit
                        // less than the space character) are not permitted.
                        abort();
                      } else if (charCode == 92) {
                        // A reverse solidus (`\`) marks the beginning of an escaped
                        // control character (including `"`, `\`, and `/`) or Unicode
                        // escape sequence.
                        charCode = source.charCodeAt(++Index);

                        switch (charCode) {
                          case 92:
                          case 34:
                          case 47:
                          case 98:
                          case 116:
                          case 110:
                          case 102:
                          case 114:
                            // Revive escaped control characters.
                            value += Unescapes[charCode];
                            Index++;
                            break;

                          case 117:
                            // `\u` marks the beginning of a Unicode escape sequence.
                            // Advance to the first character and validate the
                            // four-digit code point.
                            begin = ++Index;

                            for (position = Index + 4; Index < position; Index++) {
                              charCode = source.charCodeAt(Index); // A valid sequence comprises four hexdigits (case-
                              // insensitive) that form a single hexadecimal value.

                              if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                                // Invalid Unicode escape sequence.
                                abort();
                              }
                            } // Revive the escaped character.


                            value += fromCharCode("0x" + source.slice(begin, Index));
                            break;

                          default:
                            // Invalid escape sequence.
                            abort();
                        }
                      } else {
                        if (charCode == 34) {
                          // An unescaped double-quote character marks the end of the
                          // string.
                          break;
                        }

                        charCode = source.charCodeAt(Index);
                        begin = Index; // Optimize for the common case where a string is valid.

                        while (charCode >= 32 && charCode != 92 && charCode != 34) {
                          charCode = source.charCodeAt(++Index);
                        } // Append the string as-is.


                        value += source.slice(begin, Index);
                      }
                    }

                    if (source.charCodeAt(Index) == 34) {
                      // Advance to the next character and return the revived string.
                      Index++;
                      return value;
                    } // Unterminated string.


                    abort();

                  default:
                    // Parse numbers and literals.
                    begin = Index; // Advance past the negative sign, if one is specified.

                    if (charCode == 45) {
                      isSigned = true;
                      charCode = source.charCodeAt(++Index);
                    } // Parse an integer or floating-point value.


                    if (charCode >= 48 && charCode <= 57) {
                      // Leading zeroes are interpreted as octal literals.
                      if (charCode == 48 && (charCode = source.charCodeAt(Index + 1), charCode >= 48 && charCode <= 57)) {
                        // Illegal octal literal.
                        abort();
                      }

                      isSigned = false; // Parse the integer component.

                      for (; Index < length && (charCode = source.charCodeAt(Index), charCode >= 48 && charCode <= 57); Index++) {
                      } // Floats cannot contain a leading decimal point; however, this
                      // case is already accounted for by the parser.


                      if (source.charCodeAt(Index) == 46) {
                        position = ++Index; // Parse the decimal component.

                        for (; position < length; position++) {
                          charCode = source.charCodeAt(position);

                          if (charCode < 48 || charCode > 57) {
                            break;
                          }
                        }

                        if (position == Index) {
                          // Illegal trailing decimal.
                          abort();
                        }

                        Index = position;
                      } // Parse exponents. The `e` denoting the exponent is
                      // case-insensitive.


                      charCode = source.charCodeAt(Index);

                      if (charCode == 101 || charCode == 69) {
                        charCode = source.charCodeAt(++Index); // Skip past the sign following the exponent, if one is
                        // specified.

                        if (charCode == 43 || charCode == 45) {
                          Index++;
                        } // Parse the exponential component.


                        for (position = Index; position < length; position++) {
                          charCode = source.charCodeAt(position);

                          if (charCode < 48 || charCode > 57) {
                            break;
                          }
                        }

                        if (position == Index) {
                          // Illegal empty exponent.
                          abort();
                        }

                        Index = position;
                      } // Coerce the parsed value to a JavaScript number.


                      return +source.slice(begin, Index);
                    } // A negative sign may only precede numbers.


                    if (isSigned) {
                      abort();
                    } // `true`, `false`, and `null` literals.


                    var temp = source.slice(Index, Index + 4);

                    if (temp == "true") {
                      Index += 4;
                      return true;
                    } else if (temp == "fals" && source.charCodeAt(Index + 4) == 101) {
                      Index += 5;
                      return false;
                    } else if (temp == "null") {
                      Index += 4;
                      return null;
                    } // Unrecognized token.


                    abort();
                }
              } // Return the sentinel `$` character if the parser has reached the end
              // of the source string.


              return "$";
            }; // Internal: Parses a JSON `value` token.


            var get = function get(value) {
              var results, hasMembers;

              if (value == "$") {
                // Unexpected end of input.
                abort();
              }

              if (typeof value == "string") {
                if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
                  // Remove the sentinel `@` character.
                  return value.slice(1);
                } // Parse object and array literals.


                if (value == "[") {
                  // Parses a JSON array, returning a new JavaScript array.
                  results = [];

                  for (;;) {
                    value = lex(); // A closing square bracket marks the end of the array literal.

                    if (value == "]") {
                      break;
                    } // If the array literal contains elements, the current token
                    // should be a comma separating the previous element from the
                    // next.


                    if (hasMembers) {
                      if (value == ",") {
                        value = lex();

                        if (value == "]") {
                          // Unexpected trailing `,` in array literal.
                          abort();
                        }
                      } else {
                        // A `,` must separate each array element.
                        abort();
                      }
                    } else {
                      hasMembers = true;
                    } // Elisions and leading commas are not permitted.


                    if (value == ",") {
                      abort();
                    }

                    results.push(get(value));
                  }

                  return results;
                } else if (value == "{") {
                  // Parses a JSON object, returning a new JavaScript object.
                  results = {};

                  for (;;) {
                    value = lex(); // A closing curly brace marks the end of the object literal.

                    if (value == "}") {
                      break;
                    } // If the object literal contains members, the current token
                    // should be a comma separator.


                    if (hasMembers) {
                      if (value == ",") {
                        value = lex();

                        if (value == "}") {
                          // Unexpected trailing `,` in object literal.
                          abort();
                        }
                      } else {
                        // A `,` must separate each object member.
                        abort();
                      }
                    } else {
                      hasMembers = true;
                    } // Leading commas are not permitted, object property names must be
                    // double-quoted strings, and a `:` must separate each property
                    // name and value.


                    if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                      abort();
                    }

                    results[value.slice(1)] = get(lex());
                  }

                  return results;
                } // Unexpected token encountered.


                abort();
              }

              return value;
            }; // Internal: Updates a traversed object member.


            var update = function update(source, property, callback) {
              var element = walk(source, property, callback);

              if (element === undefined$1) {
                delete source[property];
              } else {
                source[property] = element;
              }
            }; // Internal: Recursively traverses a parsed JSON object, invoking the
            // `callback` function for each value. This is an implementation of the
            // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.


            var walk = function walk(source, property, callback) {
              var value = source[property],
                  length;

              if (_typeof(value) == "object" && value) {
                // `forOwn` can't be used to traverse an array in Opera <= 8.54
                // because its `Object#hasOwnProperty` implementation returns `false`
                // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
                if (getClass.call(value) == arrayClass) {
                  for (length = value.length; length--;) {
                    update(getClass, _forOwn, value, length, callback);
                  }
                } else {
                  _forOwn(value, function (property) {
                    update(value, property, callback);
                  });
                }
              }

              return callback.call(source, property, value);
            }; // Public: `JSON.parse`. See ES 5.1 section 15.12.2.


            exports.parse = function (source, callback) {
              var result, value;
              Index = 0;
              Source = "" + source;
              result = get(lex()); // If a JSON string contains multiple tokens, it is invalid.

              if (lex() != "$") {
                abort();
              } // Reset the parser state.


              Index = Source = null;
              return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
            };
          }
        }

        exports.runInContext = runInContext;
        return exports;
      }

      if (freeExports && !isLoader) {
        // Export for CommonJS environments.
        runInContext(root, freeExports);
      } else {
        // Export for web browsers and JavaScript engines.
        var nativeJSON = root.JSON,
            previousJSON = root.JSON3,
            isRestored = false;
        var JSON3 = runInContext(root, root.JSON3 = {
          // Public: Restores the original value of the global `JSON` object and
          // returns a reference to the `JSON3` object.
          "noConflict": function noConflict() {
            if (!isRestored) {
              isRestored = true;
              root.JSON = nativeJSON;
              root.JSON3 = previousJSON;
              nativeJSON = previousJSON = null;
            }

            return JSON3;
          }
        });
        root.JSON = {
          "parse": JSON3.parse,
          "stringify": JSON3.stringify
        };
      } // Export for asynchronous module loaders.
    }).call(commonjsGlobal);
  });

  var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

  function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
  }

  function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
  }

  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;

  if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
  }

  if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
  }

  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      //normal enviroments in sane situations
      return setTimeout(fun, 0);
    } // if setTimeout wasn't available but was latter defined


    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }

    try {
      // when when somebody has screwed with setTimeout but no I.E. maddness
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e) {
        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }

  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      //normal enviroments in sane situations
      return clearTimeout(marker);
    } // if clearTimeout wasn't available but was latter defined


    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }

    try {
      // when when somebody has screwed with setTimeout but no I.E. maddness
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
        return cachedClearTimeout.call(null, marker);
      } catch (e) {
        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
        // Some versions of I.E. have different rules for clearTimeout vs setTimeout
        return cachedClearTimeout.call(this, marker);
      }
    }
  }

  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }

    draining = false;

    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }

    if (queue.length) {
      drainQueue();
    }
  }

  function drainQueue() {
    if (draining) {
      return;
    }

    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;

    while (len) {
      currentQueue = queue;
      queue = [];

      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }

      queueIndex = -1;
      len = queue.length;
    }

    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }

  function nextTick(fun) {
    var args = new Array(arguments.length - 1);

    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }

    queue.push(new Item(fun, args));

    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  } // v8 likes predictible objects

  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }

  Item.prototype.run = function () {
    this.fun.apply(null, this.array);
  };

  var title = 'browser';
  var platform = 'browser';
  var browser$1 = true;
  var env = {};
  var argv = [];
  var version = ''; // empty string to avoid regexp issues

  var versions = {};
  var release = {};
  var config = {};

  function noop$1() {}

  var on = noop$1;
  var addListener = noop$1;
  var once = noop$1;
  var off = noop$1;
  var removeListener = noop$1;
  var removeAllListeners = noop$1;
  var emit = noop$1;
  function binding(name) {
    throw new Error('process.binding is not supported');
  }
  function cwd() {
    return '/';
  }
  function chdir(dir) {
    throw new Error('process.chdir is not supported');
  }
  function umask() {
    return 0;
  } // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js

  var performance$1 = global$1.performance || {};

  var performanceNow = performance$1.now || performance$1.mozNow || performance$1.msNow || performance$1.oNow || performance$1.webkitNow || function () {
    return new Date().getTime();
  }; // generate timestamp or delta
  // see http://nodejs.org/api/process.html#process_process_hrtime


  function hrtime(previousTimestamp) {
    var clocktime = performanceNow.call(performance$1) * 1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);

    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];

      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }

    return [seconds, nanoseconds];
  }
  var startTime = new Date();
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1000;
  }
  var process = {
    nextTick: nextTick,
    title: title,
    browser: browser$1,
    env: env,
    argv: argv,
    version: version,
    versions: versions,
    on: on,
    addListener: addListener,
    once: once,
    off: off,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    emit: emit,
    binding: binding,
    cwd: cwd,
    chdir: chdir,
    umask: umask,
    hrtime: hrtime,
    platform: platform,
    release: release,
    config: config,
    uptime: uptime
  };

  /**
   * Helpers.
   */
  var s$1 = 1000;
  var m$1 = s$1 * 60;
  var h$1 = m$1 * 60;
  var d$1 = h$1 * 24;
  var y$1 = d$1 * 365.25;
  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  var ms$1 = function ms(val, options) {
    options = options || {};

    var type = _typeof(val);

    if (type === 'string' && val.length > 0) {
      return parse$4(val);
    } else if (type === 'number' && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }

    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
  };
  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */


  function parse$4(str) {
    str = String(str);

    if (str.length > 100) {
      return;
    }

    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);

    if (!match) {
      return;
    }

    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();

    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y$1;

      case 'days':
      case 'day':
      case 'd':
        return n * d$1;

      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h$1;

      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m$1;

      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s$1;

      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;

      default:
        return undefined;
    }
  }
  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */


  function fmtShort(ms) {
    if (ms >= d$1) {
      return Math.round(ms / d$1) + 'd';
    }

    if (ms >= h$1) {
      return Math.round(ms / h$1) + 'h';
    }

    if (ms >= m$1) {
      return Math.round(ms / m$1) + 'm';
    }

    if (ms >= s$1) {
      return Math.round(ms / s$1) + 's';
    }

    return ms + 'ms';
  }
  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */


  function fmtLong(ms) {
    return plural$1(ms, d$1, 'day') || plural$1(ms, h$1, 'hour') || plural$1(ms, m$1, 'minute') || plural$1(ms, s$1, 'second') || ms + ' ms';
  }
  /**
   * Pluralization helper.
   */


  function plural$1(ms, n, name) {
    if (ms < n) {
      return;
    }

    if (ms < n * 1.5) {
      return Math.floor(ms / n) + ' ' + name;
    }

    return Math.ceil(ms / n) + ' ' + name + 's';
  }

  var debug$1 = createCommonjsModule(function (module, exports) {
    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     *
     * Expose `debug()` as the module.
     */
    exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = ms$1;
    /**
     * The currently active debug mode names, and names to skip.
     */

    exports.names = [];
    exports.skips = [];
    /**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
     */

    exports.formatters = {};
    /**
     * Previous log timestamp.
     */

    var prevTime;
    /**
     * Select a color.
     * @param {String} namespace
     * @return {Number}
     * @api private
     */

    function selectColor(namespace) {
      var hash = 0,
          i;

      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }

      return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    /**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */


    function createDebug(namespace) {
      function debug() {
        // disabled?
        if (!debug.enabled) return;
        var self = debug; // set `diff` timestamp

        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr; // turn the `arguments` into a proper Array

        var args = new Array(arguments.length);

        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }

        args[0] = exports.coerce(args[0]);

        if ('string' !== typeof args[0]) {
          // anything else let's inspect with %O
          args.unshift('%O');
        } // apply any `formatters` transformations


        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
          // if we encounter an escaped % then don't increase the array index
          if (match === '%%') return match;
          index++;
          var formatter = exports.formatters[format];

          if ('function' === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val); // now we need to remove `args[index]` since it's inlined in the `format`

            args.splice(index, 1);
            index--;
          }

          return match;
        }); // apply env-specific formatting (colors, etc.)

        exports.formatArgs.call(self, args);
        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }

      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace); // env-specific initialization logic for debug instances

      if ('function' === typeof exports.init) {
        exports.init(debug);
      }

      return debug;
    }
    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */


    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;

      for (var i = 0; i < len; i++) {
        if (!split[i]) continue; // ignore empty strings

        namespaces = split[i].replace(/\*/g, '.*?');

        if (namespaces[0] === '-') {
          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          exports.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }
    /**
     * Disable debug output.
     *
     * @api public
     */


    function disable() {
      exports.enable('');
    }
    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */


    function enabled(name) {
      var i, len;

      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }

      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }

      return false;
    }
    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */


    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  });
  var debug_1$1 = debug$1.coerce;
  var debug_2$1 = debug$1.disable;
  var debug_3$1 = debug$1.enable;
  var debug_4$1 = debug$1.enabled;
  var debug_5$1 = debug$1.humanize;
  var debug_6$1 = debug$1.names;
  var debug_7$1 = debug$1.skips;
  var debug_8$1 = debug$1.formatters;

  var browser$2 = createCommonjsModule(function (module, exports) {
    /**
     * This is the web browser implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */
    exports = module.exports = debug$1;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
    /**
     * Colors.
     */

    exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
        return true;
      } // is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */


    exports.formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return '[UnexpectedJSONParseError]: ' + err.message;
      }
    };
    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */


    function formatArgs(args) {
      var useColors = this.useColors;
      args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
      if (!useColors) return;
      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit'); // the final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into

      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function (match) {
        if ('%%' === match) return;
        index++;

        if ('%c' === match) {
          // we only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */


    function log() {
      // this hackery is required for IE8/9, where
      // the `console.log` function doesn't have 'apply'
      return 'object' === (typeof console === "undefined" ? "undefined" : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */


    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem('debug');
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {}
    }
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */


    function load() {
      var r;

      try {
        r = exports.storage.debug;
      } catch (e) {} // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }

      return r;
    }
    /**
     * Enable namespaces listed in `localStorage.debug` initially.
     */


    exports.enable(load());
    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {}
    }
  });
  var browser_1$1 = browser$2.log;
  var browser_2$1 = browser$2.formatArgs;
  var browser_3$1 = browser$2.save;
  var browser_4$1 = browser$2.load;
  var browser_5$1 = browser$2.useColors;
  var browser_6$1 = browser$2.storage;
  var browser_7$1 = browser$2.colors;

  /**
   * Module dependencies.
   */

  var debug$2 = browser$2('cookie');
  /**
   * Set or get cookie `name` with `value` and `options` object.
   *
   * @param {String} name
   * @param {String} value
   * @param {Object} options
   * @return {Mixed}
   * @api public
   */

  var componentCookie = function componentCookie(name, value, options) {
    switch (arguments.length) {
      case 3:
      case 2:
        return set$1(name, value, options);

      case 1:
        return get$1(name);

      default:
        return all$1();
    }
  };
  /**
   * Set cookie `name` to `value`.
   *
   * @param {String} name
   * @param {String} value
   * @param {Object} options
   * @api private
   */


  function set$1(name, value, options) {
    options = options || {};
    var str = encode$2(name) + '=' + encode$2(value);
    if (null == value) options.maxage = -1;

    if (options.maxage) {
      options.expires = new Date(+new Date() + options.maxage);
    }

    if (options.path) str += '; path=' + options.path;
    if (options.domain) str += '; domain=' + options.domain;
    if (options.expires) str += '; expires=' + options.expires.toUTCString();
    if (options.secure) str += '; secure';
    document.cookie = str;
  }
  /**
   * Return all cookies.
   *
   * @return {Object}
   * @api private
   */


  function all$1() {
    var str;

    try {
      str = document.cookie;
    } catch (err) {
      if (typeof console !== 'undefined' && typeof console.error === 'function') {
        console.error(err.stack || err);
      }

      return {};
    }

    return parse$5(str);
  }
  /**
   * Get cookie `name`.
   *
   * @param {String} name
   * @return {String}
   * @api private
   */


  function get$1(name) {
    return all$1()[name];
  }
  /**
   * Parse cookie `str`.
   *
   * @param {String} str
   * @return {Object}
   * @api private
   */


  function parse$5(str) {
    var obj = {};
    var pairs = str.split(/ *; */);
    var pair;
    if ('' == pairs[0]) return obj;

    for (var i = 0; i < pairs.length; ++i) {
      pair = pairs[i].split('=');
      obj[decode$2(pair[0])] = decode$2(pair[1]);
    }

    return obj;
  }
  /**
   * Encode.
   */


  function encode$2(value) {
    try {
      return encodeURIComponent(value);
    } catch (e) {
      debug$2('error `encode(%o)` - %o', value, e);
    }
  }
  /**
   * Decode.
   */


  function decode$2(value) {
    try {
      return decodeURIComponent(value);
    } catch (e) {
      debug$2('error `decode(%o)` - %o', value, e);
    }
  }

  var lib$1 = createCommonjsModule(function (module, exports) {
    /**
     * Module dependencies.
     */

    var parse = componentUrl.parse;
    /**
     * Get the top domain.
     *
     * The function constructs the levels of domain and attempts to set a global
     * cookie on each one when it succeeds it returns the top level domain.
     *
     * The method returns an empty string when the hostname is an ip or `localhost`.
     *
     * Example levels:
     *
     *      domain.levels('http://www.google.co.uk');
     *      // => ["co.uk", "google.co.uk", "www.google.co.uk"]
     *
     * Example:
     *
     *      domain('http://localhost:3000/baz');
     *      // => ''
     *      domain('http://dev:3000/baz');
     *      // => ''
     *      domain('http://127.0.0.1:3000/baz');
     *      // => ''
     *      domain('http://segment.io/baz');
     *      // => 'segment.io'
     *
     * @param {string} url
     * @return {string}
     * @api public
     */

    function domain(url) {
      var cookie = exports.cookie;
      var levels = exports.levels(url); // Lookup the real top level one.

      for (var i = 0; i < levels.length; ++i) {
        var cname = '__tld__';
        var domain = levels[i];
        var opts = {
          domain: '.' + domain
        };
        cookie(cname, 1, opts);

        if (cookie(cname)) {
          cookie(cname, null, opts);
          return domain;
        }
      }

      return '';
    }
    /**
     * Levels returns all levels of the given url.
     *
     * @param {string} url
     * @return {Array}
     * @api public
     */


    domain.levels = function (url) {
      var host = parse(url).hostname;
      var parts = host.split('.');
      var last = parts[parts.length - 1];
      var levels = []; // Ip address.

      if (parts.length === 4 && last === parseInt(last, 10)) {
        return levels;
      } // Localhost.


      if (parts.length <= 1) {
        return levels;
      } // Create levels.


      for (var i = parts.length - 2; i >= 0; --i) {
        levels.push(parts.slice(i).join('.'));
      }

      return levels;
    };
    /**
     * Expose cookie on domain.
     */


    domain.cookie = componentCookie;
    /*
     * Exports.
     */

    exports = module.exports = domain;
  });

  /**
   * An object utility to persist values in cookies
   */

  var CookieLocal = /*#__PURE__*/function () {
    function CookieLocal(options) {
      _classCallCheck(this, CookieLocal);

      this._options = {};
      this.options(options);
    }
    /**
     *
     * @param {*} options
     */


    _createClass(CookieLocal, [{
      key: "options",
      value: function options() {
        var _options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (arguments.length === 0) return this._options;
        var domain = ".".concat(lib$1(window.location.href));
        if (domain === ".") domain = null; // the default maxage and path

        this._options = defaults_1(_options, {
          maxage: 31536000000,
          path: "/",
          domain: domain,
          samesite: "Lax"
        }); // try setting a cookie first

        this.set("test_rudder", true);

        if (!this.get("test_rudder")) {
          this._options.domain = null;
        }

        this.remove("test_rudder");
      }
      /**
       *
       * @param {*} key
       * @param {*} value
       */

    }, {
      key: "set",
      value: function set(key, value) {
        try {
          rudderComponentCookie(key, value, clone_1(this._options));
          return true;
        } catch (e) {
          logger.error(e);
          return false;
        }
      }
      /**
       *
       * @param {*} key
       */

    }, {
      key: "get",
      value: function get(key) {
        return rudderComponentCookie(key);
      }
      /**
       *
       * @param {*} key
       */

    }, {
      key: "remove",
      value: function remove(key) {
        try {
          rudderComponentCookie(key, null, clone_1(this._options));
          return true;
        } catch (e) {
          return false;
        }
      }
    }]);

    return CookieLocal;
  }(); // Exporting only the instance


  var Cookie = new CookieLocal({});

  var store = function () {
    // Store.js
    var store = {},
        win = typeof window != 'undefined' ? window : commonjsGlobal,
        doc = win.document,
        localStorageName = 'localStorage',
        scriptTag = 'script',
        storage;
    store.disabled = false;
    store.version = '1.3.20';

    store.set = function (key, value) {};

    store.get = function (key, defaultVal) {};

    store.has = function (key) {
      return store.get(key) !== undefined;
    };

    store.remove = function (key) {};

    store.clear = function () {};

    store.transact = function (key, defaultVal, transactionFn) {
      if (transactionFn == null) {
        transactionFn = defaultVal;
        defaultVal = null;
      }

      if (defaultVal == null) {
        defaultVal = {};
      }

      var val = store.get(key, defaultVal);
      transactionFn(val);
      store.set(key, val);
    };

    store.getAll = function () {
      var ret = {};
      store.forEach(function (key, val) {
        ret[key] = val;
      });
      return ret;
    };

    store.forEach = function () {};

    store.serialize = function (value) {
      return json3.stringify(value);
    };

    store.deserialize = function (value) {
      if (typeof value != 'string') {
        return undefined;
      }

      try {
        return json3.parse(value);
      } catch (e) {
        return value || undefined;
      }
    }; // Functions to encapsulate questionable FireFox 3.6.13 behavior
    // when about.config::dom.storage.enabled === false
    // See https://github.com/marcuswestin/store.js/issues#issue/13


    function isLocalStorageNameSupported() {
      try {
        return localStorageName in win && win[localStorageName];
      } catch (err) {
        return false;
      }
    }

    if (isLocalStorageNameSupported()) {
      storage = win[localStorageName];

      store.set = function (key, val) {
        if (val === undefined) {
          return store.remove(key);
        }

        storage.setItem(key, store.serialize(val));
        return val;
      };

      store.get = function (key, defaultVal) {
        var val = store.deserialize(storage.getItem(key));
        return val === undefined ? defaultVal : val;
      };

      store.remove = function (key) {
        storage.removeItem(key);
      };

      store.clear = function () {
        storage.clear();
      };

      store.forEach = function (callback) {
        for (var i = 0; i < storage.length; i++) {
          var key = storage.key(i);
          callback(key, store.get(key));
        }
      };
    } else if (doc && doc.documentElement.addBehavior) {
      var storageOwner, storageContainer; // Since #userData storage applies only to specific paths, we need to
      // somehow link our data to a specific path.  We choose /favicon.ico
      // as a pretty safe option, since all browsers already make a request to
      // this URL anyway and being a 404 will not hurt us here.  We wrap an
      // iframe pointing to the favicon in an ActiveXObject(htmlfile) object
      // (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
      // since the iframe access rules appear to allow direct access and
      // manipulation of the document element, even for a 404 page.  This
      // document can be used instead of the current document (which would
      // have been limited to the current path) to perform #userData storage.

      try {
        storageContainer = new ActiveXObject('htmlfile');
        storageContainer.open();
        storageContainer.write('<' + scriptTag + '>document.w=window</' + scriptTag + '><iframe src="/favicon.ico"></iframe>');
        storageContainer.close();
        storageOwner = storageContainer.w.frames[0].document;
        storage = storageOwner.createElement('div');
      } catch (e) {
        // somehow ActiveXObject instantiation failed (perhaps some special
        // security settings or otherwse), fall back to per-path storage
        storage = doc.createElement('div');
        storageOwner = doc.body;
      }

      var withIEStorage = function withIEStorage(storeFunction) {
        return function () {
          var args = Array.prototype.slice.call(arguments, 0);
          args.unshift(storage); // See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
          // and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx

          storageOwner.appendChild(storage);
          storage.addBehavior('#default#userData');
          storage.load(localStorageName);
          var result = storeFunction.apply(store, args);
          storageOwner.removeChild(storage);
          return result;
        };
      }; // In IE7, keys cannot start with a digit or contain certain chars.
      // See https://github.com/marcuswestin/store.js/issues/40
      // See https://github.com/marcuswestin/store.js/issues/83


      var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g");

      var ieKeyFix = function ieKeyFix(key) {
        return key.replace(/^d/, '___$&').replace(forbiddenCharsRegex, '___');
      };

      store.set = withIEStorage(function (storage, key, val) {
        key = ieKeyFix(key);

        if (val === undefined) {
          return store.remove(key);
        }

        storage.setAttribute(key, store.serialize(val));
        storage.save(localStorageName);
        return val;
      });
      store.get = withIEStorage(function (storage, key, defaultVal) {
        key = ieKeyFix(key);
        var val = store.deserialize(storage.getAttribute(key));
        return val === undefined ? defaultVal : val;
      });
      store.remove = withIEStorage(function (storage, key) {
        key = ieKeyFix(key);
        storage.removeAttribute(key);
        storage.save(localStorageName);
      });
      store.clear = withIEStorage(function (storage) {
        var attributes = storage.XMLDocument.documentElement.attributes;
        storage.load(localStorageName);

        for (var i = attributes.length - 1; i >= 0; i--) {
          storage.removeAttribute(attributes[i].name);
        }

        storage.save(localStorageName);
      });
      store.forEach = withIEStorage(function (storage, callback) {
        var attributes = storage.XMLDocument.documentElement.attributes;

        for (var i = 0, attr; attr = attributes[i]; ++i) {
          callback(attr.name, store.deserialize(storage.getAttribute(attr.name)));
        }
      });
    }

    try {
      var testKey = '__storejs__';
      store.set(testKey, testKey);

      if (store.get(testKey) != testKey) {
        store.disabled = true;
      }

      store.remove(testKey);
    } catch (e) {
      store.disabled = true;
    }

    store.enabled = !store.disabled;
    return store;
  }();

  /**
   * An object utility to persist user and other values in localstorage
   */

  var StoreLocal = /*#__PURE__*/function () {
    function StoreLocal(options) {
      _classCallCheck(this, StoreLocal);

      this._options = {};
      this.enabled = false;
      this.options(options);
    }
    /**
     *
     * @param {*} options
     */


    _createClass(StoreLocal, [{
      key: "options",
      value: function options() {
        var _options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (arguments.length === 0) return this._options;
        defaults_1(_options, {
          enabled: true
        });
        this.enabled = _options.enabled && store.enabled;
        this._options = _options;
      }
      /**
       *
       * @param {*} key
       * @param {*} value
       */

    }, {
      key: "set",
      value: function set(key, value) {
        if (!this.enabled) return false;
        return store.set(key, value);
      }
      /**
       *
       * @param {*} key
       */

    }, {
      key: "get",
      value: function get(key) {
        if (!this.enabled) return null;
        return store.get(key);
      }
      /**
       *
       * @param {*} key
       */

    }, {
      key: "remove",
      value: function remove(key) {
        if (!this.enabled) return false;
        return store.remove(key);
      }
    }]);

    return StoreLocal;
  }(); // Exporting only the instance


  var Store = new StoreLocal({});

  var defaults$1 = {
    user_storage_key: "rl_user_id",
    user_storage_trait: "rl_trait",
    user_storage_anonymousId: "rl_anonymous_id",
    group_storage_key: "rl_group_id",
    group_storage_trait: "rl_group_trait",
    page_storage_init_referrer: "rl_page_init_referrer",
    page_storage_init_referring_domain: "rl_page_init_referring_domain",
    prefix: "RudderEncrypt:",
    key: "Rudder"
  };
  /**
   * An object that handles persisting key-val from Analytics
   */

  var Storage = /*#__PURE__*/function () {
    function Storage() {
      _classCallCheck(this, Storage);

      // First try setting the storage to cookie else to localstorage
      Cookie.set("rudder_cookies", true);

      if (Cookie.get("rudder_cookies")) {
        Cookie.remove("rudder_cookies");
        this.storage = Cookie;
        return;
      } // localStorage is enabled.


      if (Store.enabled) {
        this.storage = Store;
      }

      if (!this.storage) {
        throw Error("Could not initialize the SDK :: no storage is available");
      }
    }

    _createClass(Storage, [{
      key: "options",
      value: function options() {
        var _options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        this.storage.options(_options);
      }
      /**
       * Json stringify the given value
       * @param {*} value
       */

    }, {
      key: "stringify",
      value: function stringify(value) {
        return JSON.stringify(value);
      }
      /**
       * JSON parse the value
       * @param {*} value
       */

    }, {
      key: "parse",
      value: function parse(value) {
        // if not parseable, return as is without json parse
        try {
          return value ? JSON.parse(value) : null;
        } catch (e) {
          logger.error(e);
          return value || null;
        }
      }
      /**
       * trim using regex for browser polyfill
       * @param {*} value
       */

    }, {
      key: "trim",
      value: function trim(value) {
        return value.replace(/^\s+|\s+$/gm, "");
      }
      /**
       * AES encrypt value with constant prefix
       * @param {*} value
       */

    }, {
      key: "encryptValue",
      value: function encryptValue(value) {
        if (this.trim(value) == "") {
          return value;
        }

        var prefixedVal = "".concat(defaults$1.prefix).concat(aes.encrypt(value, defaults$1.key).toString());
        return prefixedVal;
      }
      /**
       * decrypt value
       * @param {*} value
       */

    }, {
      key: "decryptValue",
      value: function decryptValue(value) {
        if (!value || typeof value === "string" && this.trim(value) == "") {
          return value;
        }

        if (value.substring(0, defaults$1.prefix.length) == defaults$1.prefix) {
          return aes.decrypt(value.substring(defaults$1.prefix.length), defaults$1.key).toString(encUtf8);
        }

        return value;
      }
      /**
       *
       * @param {*} key
       * @param {*} value
       */

    }, {
      key: "setItem",
      value: function setItem(key, value) {
        this.storage.set(key, this.encryptValue(this.stringify(value)));
      }
      /**
       *
       * @param {*} value
       */

    }, {
      key: "setUserId",
      value: function setUserId(value) {
        if (typeof value !== "string") {
          logger.error("[Storage] setUserId:: userId should be string");
          return;
        }

        this.storage.set(defaults$1.user_storage_key, this.encryptValue(this.stringify(value)));
      }
      /**
       *
       * @param {*} value
       */

    }, {
      key: "setUserTraits",
      value: function setUserTraits(value) {
        this.storage.set(defaults$1.user_storage_trait, this.encryptValue(this.stringify(value)));
      }
      /**
       *
       * @param {*} value
       */

    }, {
      key: "setGroupId",
      value: function setGroupId(value) {
        if (typeof value !== "string") {
          logger.error("[Storage] setGroupId:: groupId should be string");
          return;
        }

        this.storage.set(defaults$1.group_storage_key, this.encryptValue(this.stringify(value)));
      }
      /**
       *
       * @param {*} value
       */

    }, {
      key: "setGroupTraits",
      value: function setGroupTraits(value) {
        this.storage.set(defaults$1.group_storage_trait, this.encryptValue(this.stringify(value)));
      }
      /**
       *
       * @param {*} value
       */

    }, {
      key: "setAnonymousId",
      value: function setAnonymousId(value) {
        if (typeof value !== "string") {
          logger.error("[Storage] setAnonymousId:: anonymousId should be string");
          return;
        }

        this.storage.set(defaults$1.user_storage_anonymousId, this.encryptValue(this.stringify(value)));
      }
      /**
       * @param {*} value
       */

    }, {
      key: "setInitialReferrer",
      value: function setInitialReferrer(value) {
        this.storage.set(defaults$1.page_storage_init_referrer, this.encryptValue(this.stringify(value)));
      }
      /**
       * @param {*} value
       */

    }, {
      key: "setInitialReferringDomain",
      value: function setInitialReferringDomain(value) {
        this.storage.set(defaults$1.page_storage_init_referring_domain, this.encryptValue(this.stringify(value)));
      }
      /**
       *
       * @param {*} key
       */

    }, {
      key: "getItem",
      value: function getItem(key) {
        return this.parse(this.decryptValue(this.storage.get(key)));
      }
      /**
       * get the stored userId
       */

    }, {
      key: "getUserId",
      value: function getUserId() {
        return this.parse(this.decryptValue(this.storage.get(defaults$1.user_storage_key)));
      }
      /**
       * get the stored user traits
       */

    }, {
      key: "getUserTraits",
      value: function getUserTraits() {
        return this.parse(this.decryptValue(this.storage.get(defaults$1.user_storage_trait)));
      }
      /**
       * get the stored userId
       */

    }, {
      key: "getGroupId",
      value: function getGroupId() {
        return this.parse(this.decryptValue(this.storage.get(defaults$1.group_storage_key)));
      }
      /**
       * get the stored user traits
       */

    }, {
      key: "getGroupTraits",
      value: function getGroupTraits() {
        return this.parse(this.decryptValue(this.storage.get(defaults$1.group_storage_trait)));
      }
      /**
       * get stored anonymous id
       */

    }, {
      key: "getAnonymousId",
      value: function getAnonymousId() {
        return this.parse(this.decryptValue(this.storage.get(defaults$1.user_storage_anonymousId)));
      }
      /**
       * get stored initial referrer
       */

    }, {
      key: "getInitialReferrer",
      value: function getInitialReferrer(value) {
        return this.parse(this.decryptValue(this.storage.get(defaults$1.page_storage_init_referrer)));
      }
      /**
       * get stored initial referring domain
       */

    }, {
      key: "getInitialReferringDomain",
      value: function getInitialReferringDomain(value) {
        return this.parse(this.decryptValue(this.storage.get(defaults$1.page_storage_init_referring_domain)));
      }
      /**
       *
       * @param {*} key
       */

    }, {
      key: "removeItem",
      value: function removeItem(key) {
        return this.storage.remove(key);
      }
      /**
       * remove stored keys
       */

    }, {
      key: "clear",
      value: function clear(flag) {
        this.storage.remove(defaults$1.user_storage_key);
        this.storage.remove(defaults$1.user_storage_trait);
        this.storage.remove(defaults$1.group_storage_key);
        this.storage.remove(defaults$1.group_storage_trait);

        if (flag) {
          this.storage.remove(defaults$1.user_storage_anonymousId);
        }
      }
    }]);

    return Storage;
  }();

  var Storage$1 = new Storage();

  /**
   *
   * Utility method for excluding null and empty values in JSON
   * @param {*} key
   * @param {*} value
   * @returns
   */

  function replacer(key, value) {
    if (value === null || value === undefined) {
      return undefined;
    }

    return value;
  }
  /**
   *
   * Utility function for UUID genration
   * @returns
   */


  function generateUUID() {
    // Public Domain/MIT
    var d = new Date().getTime();

    if (typeof performance !== "undefined" && typeof performance.now === "function") {
      d += performance.now(); // use high-precision timer if available
    }

    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
      var r = (d + Math.random() * 16) % 16 | 0;
      d = Math.floor(d / 16);
      return (c === "x" ? r : r & 0x3 | 0x8).toString(16);
    });
  }
  /**
   *
   * Utility function to get current time (formatted) for including in sent_at field
   * @returns
   */


  function getCurrentTimeFormatted() {
    var curDateTime = new Date().toISOString(); // Keeping same as iso string

    /* let curDate = curDateTime.split("T")[0];
    let curTimeExceptMillis = curDateTime
      .split("T")[1]
      .split("Z")[0]
      .split(".")[0];
    let curTimeMillis = curDateTime.split("Z")[0].split(".")[1];
    return curDate + " " + curTimeExceptMillis + "+" + curTimeMillis; */

    return curDateTime;
  }
  /**
   *
   * Utility function to retrieve configuration JSON from server
   * @param {*} context
   * @param {*} url
   * @param {*} callback
   */


  function getJSONTrimmed(context, url, writeKey, callback) {
    // server-side integration, XHR is node module
    var cb_ = callback.bind(context);
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);
    xhr.setRequestHeader("Authorization", "Basic ".concat(btoa("".concat(writeKey, ":"))));

    xhr.onload = function () {
      var status = xhr.status;

      if (status == 200) {
        logger.debug("status 200 " + "calling callback");
        cb_(200, xhr.responseText);
      } else {
        handleError(new Error("request failed with status: ".concat(xhr.status, " for url: ").concat(url)));
        cb_(status);
      }
    };

    xhr.send();
  }

  function handleError(error, analyticsInstance) {
    var errorMessage = error.message ? error.message : undefined;
    var sampleAdBlockTest;

    try {
      if (error instanceof Event) {
        if (error.target && error.target.localName == "script") {
          errorMessage = "error in script loading:: src::  ".concat(error.target.src, " id:: ").concat(error.target.id);

          if (analyticsInstance && error.target.src.includes("adsbygoogle")) {
            sampleAdBlockTest = true;
            analyticsInstance.page("RudderJS-Initiated", "ad-block page request", {
              path: "/ad-blocked",
              title: errorMessage
            }, analyticsInstance.sendAdblockPageOptions);
          }
        }
      }

      if (errorMessage && !sampleAdBlockTest) {
        logger.error("[Util] handleError:: ", errorMessage);
      }
    } catch (e) {
      logger.error("[Util] handleError:: ", e);
    }
  }

  function getDefaultPageProperties() {
    var canonicalUrl = getCanonicalUrl();
    var path = canonicalUrl ? componentUrl_1(canonicalUrl).pathname : window.location.pathname; //const { referrer } = document;

    var search = window.location.search;
    var _document = document,
        title = _document.title;
    var url = getUrl(search);
    var tab_url = window.location.href;
    var referrer = getReferrer();
    var referring_domain = getReferringDomain(referrer);
    var initial_referrer = Storage$1.getInitialReferrer();
    var initial_referring_domain = Storage$1.getInitialReferringDomain();
    return {
      path: path,
      referrer: referrer,
      referring_domain: referring_domain,
      search: search,
      title: title,
      url: url,
      tab_url: tab_url,
      initial_referrer: initial_referrer,
      initial_referring_domain: initial_referring_domain
    };
  }

  function getReferrer() {
    return document.referrer || "$direct";
  }

  function getReferringDomain(referrer) {
    var split = referrer.split("/");

    if (split.length >= 3) {
      return split[2];
    }

    return "";
  }

  function getUrl(search) {
    var canonicalUrl = getCanonicalUrl();
    var url = canonicalUrl ? canonicalUrl.indexOf("?") > -1 ? canonicalUrl : canonicalUrl + search : window.location.href;
    var hashIndex = url.indexOf("#");
    return hashIndex > -1 ? url.slice(0, hashIndex) : url;
  }

  function getCanonicalUrl() {
    var tags = document.getElementsByTagName("link");

    for (var i = 0, tag; tag = tags[i]; i++) {
      if (tag.getAttribute("rel") === "canonical") {
        return tag.getAttribute("href");
      }
    }
  }

  function getCurrency(val) {
    if (!val) return;

    if (typeof val === "number") {
      return val;
    }

    if (typeof val !== "string") {
      return;
    }

    val = val.replace(/\$/g, "");
    val = parseFloat(val);

    if (!isNaN(val)) {
      return val;
    }
  }

  function getRevenue(properties, eventName) {
    var revenue = properties.revenue;
    var orderCompletedRegExp = /^[ _]?completed[ _]?order[ _]?|^[ _]?order[ _]?completed[ _]?$/i; // it's always revenue, unless it's called during an order completion.

    if (!revenue && eventName && eventName.match(orderCompletedRegExp)) {
      revenue = properties.total;
    }

    return getCurrency(revenue);
  }
  /**
   *
   *
   * @param {*} integrationObject
   */


  function tranformToRudderNames(integrationObject) {
    Object.keys(integrationObject).forEach(function (key) {
      if (integrationObject.hasOwnProperty(key)) {
        if (commonNames[key]) {
          integrationObject[commonNames[key]] = integrationObject[key];
        }

        if (key != "All") {
          // delete user supplied keys except All and if except those where oldkeys are not present or oldkeys are same as transformed keys
          if (commonNames[key] != undefined && commonNames[key] != key) {
            delete integrationObject[key];
          }
        }
      }
    });
  }

  function transformToServerNames(integrationObject) {
    Object.keys(integrationObject).forEach(function (key) {
      if (integrationObject.hasOwnProperty(key)) {
        if (clientToServerNames[key]) {
          integrationObject[clientToServerNames[key]] = integrationObject[key];
        }

        if (key != "All") {
          // delete user supplied keys except All and if except those where oldkeys are not present or oldkeys are same as transformed keys
          if (clientToServerNames[key] != undefined && clientToServerNames[key] != key) {
            delete integrationObject[key];
          }
        }
      }
    });
  }
  /**
   *
   * @param {*} sdkSuppliedIntegrations
   * @param {*} configPlaneEnabledIntegrations
   */


  function findAllEnabledDestinations(sdkSuppliedIntegrations, configPlaneEnabledIntegrations) {
    var enabledList = [];

    if (!configPlaneEnabledIntegrations || configPlaneEnabledIntegrations.length == 0) {
      return enabledList;
    }

    var allValue = true;

    if (typeof configPlaneEnabledIntegrations[0] === "string") {
      if (sdkSuppliedIntegrations.All != undefined) {
        allValue = sdkSuppliedIntegrations.All;
      }

      configPlaneEnabledIntegrations.forEach(function (intg) {
        if (!allValue) {
          // All false ==> check if intg true supplied
          if (sdkSuppliedIntegrations[intg] != undefined && sdkSuppliedIntegrations[intg] == true) {
            enabledList.push(intg);
          }
        } else {
          // All true ==> intg true by default
          var intgValue = true; // check if intg false supplied

          if (sdkSuppliedIntegrations[intg] != undefined && sdkSuppliedIntegrations[intg] == false) {
            intgValue = false;
          }

          if (intgValue) {
            enabledList.push(intg);
          }
        }
      });
      return enabledList;
    }

    if (_typeof(configPlaneEnabledIntegrations[0]) === "object") {
      if (sdkSuppliedIntegrations.All != undefined) {
        allValue = sdkSuppliedIntegrations.All;
      }

      configPlaneEnabledIntegrations.forEach(function (intg) {
        if (!allValue) {
          // All false ==> check if intg true supplied
          if (sdkSuppliedIntegrations[intg.name] != undefined && sdkSuppliedIntegrations[intg.name] == true) {
            enabledList.push(intg);
          }
        } else {
          // All true ==> intg true by default
          var intgValue = true; // check if intg false supplied

          if (sdkSuppliedIntegrations[intg.name] != undefined && sdkSuppliedIntegrations[intg.name] == false) {
            intgValue = false;
          }

          if (intgValue) {
            enabledList.push(intg);
          }
        }
      });
      return enabledList;
    }
  }
  /**
   * reject all null values from array/object
   * @param  {} obj
   * @param  {} fn
   */


  function rejectArr(obj, fn) {
    fn = fn || compact;
    return type(obj) == "array" ? rejectarray(obj, fn) : rejectobject(obj, fn);
  }
  /**
   * particular case when rejecting an array
   * @param  {} arr
   * @param  {} fn
   */


  var rejectarray = function rejectarray(arr, fn) {
    var ret = [];

    for (var i = 0; i < arr.length; ++i) {
      if (!fn(arr[i], i)) ret[ret.length] = arr[i];
    }

    return ret;
  };
  /**
   * Rejecting null from any object other than arrays
   * @param  {} obj
   * @param  {} fn
   *
   */


  var rejectobject = function rejectobject(obj, fn) {
    var ret = {};

    for (var k in obj) {
      if (obj.hasOwnProperty(k) && !fn(obj[k], k)) {
        ret[k] = obj[k];
      }
    }

    return ret;
  };

  function compact(value) {
    return value == null;
  }
  /**
   * check type of object incoming in the rejectArr function
   * @param  {} val
   */


  function type(val) {
    switch (Object.prototype.toString.call(val)) {
      case "[object Function]":
        return "function";

      case "[object Date]":
        return "date";

      case "[object RegExp]":
        return "regexp";

      case "[object Arguments]":
        return "arguments";

      case "[object Array]":
        return "array";
    }

    if (val === null) return "null";
    if (val === undefined) return "undefined";
    if (val === Object(val)) return "object";
    return _typeof(val);
  }

  function getUserProvidedConfigUrl(configUrl) {
    var url = configUrl;

    if (configUrl.indexOf("sourceConfig") == -1) {
      url = url.slice(-1) == "/" ? url.slice(0, -1) : url;
      url = "".concat(url, "/sourceConfig/");
    }

    url = url.slice(-1) == "/" ? url : "".concat(url, "/");

    if (url.indexOf("?") > -1) {
      if (url.split("?")[1] !== CONFIG_URL.split("?")[1]) {
        url = "".concat(url.split("?")[0], "?").concat(CONFIG_URL.split("?")[1]);
      }
    } else {
      url = "".concat(url, "?").concat(CONFIG_URL.split("?")[1]);
    }

    return url;
  }
  /**
   * Check if a reserved keyword is present in properties/traits
   * @param {*} properties
   * @param {*} reservedKeywords
   * @param {*} type
   */


  function checkReservedKeywords(message, messageType) {
    //  properties, traits, contextualTraits are either undefined or object
    var properties = message.properties,
        traits = message.traits;
    var contextualTraits = message.context.traits;

    if (properties) {
      Object.keys(properties).forEach(function (property) {
        if (ReservedPropertyKeywords.indexOf(property.toLowerCase()) >= 0) {
          logger.error("Warning! : Reserved keyword used in properties--> ".concat(property, " with ").concat(messageType, " call"));
        }
      });
    }

    if (traits) {
      Object.keys(traits).forEach(function (trait) {
        if (ReservedPropertyKeywords.indexOf(trait.toLowerCase()) >= 0) {
          logger.error("Warning! : Reserved keyword used in traits--> ".concat(trait, " with ").concat(messageType, " call"));
        }
      });
    }

    if (contextualTraits) {
      Object.keys(contextualTraits).forEach(function (contextTrait) {
        if (ReservedPropertyKeywords.indexOf(contextTrait.toLowerCase()) >= 0) {
          logger.error("Warning! : Reserved keyword used in traits --> ".concat(contextTrait, " with ").concat(messageType, " call"));
        }
      });
    }
  }
  /* ------- Start FlattenJson -----------
   * This function flatten given json object to single level.
   * So if there is nested object or array, all will apear in first level properties of an object.
   * Following is case we are handling in this function ::
   * condition 1: String
   * condition 2: Array
   * condition 3: Nested object
   */


  function recurse(cur, prop, result) {
    var res = result;

    if (Object(cur) !== cur) {
      res[prop] = cur;
    } else if (Array.isArray(cur)) {
      var l = cur.length;

      for (var i = 0; i < l; i += 1) {
        recurse(cur[i], prop ? "".concat(prop, ".").concat(i) : "".concat(i), res);
      }

      if (l === 0) res[prop] = [];
    } else {
      var isEmpty = true;
      Object.keys(cur).forEach(function (key) {
        isEmpty = false;
        recurse(cur[key], prop ? "".concat(prop, ".").concat(key) : key, res);
      });
      if (isEmpty) res[prop] = {};
    }

    return res;
  }

  function flattenJsonPayload(data) {
    return recurse(data, "", {});
  }
  /* ------- End FlattenJson ----------- */

  /**
   *
   * @param {*} message
   * @param {*} destination
   * @param {*} keys
   * @param {*} exclusionFields
   * Extract fileds from message with exclusions
   * Pass the keys of message for extraction and
   * exclusion fields to exlude and the payload to map into
   * -----------------Example-------------------
   * extractCustomFields(message,payload,["traits", "context.traits", "properties"], "email",
   * ["firstName",
   * "lastName",
   * "phone",
   * "title",
   * "organization",
   * "city",
   * "region",
   * "country",
   * "zip",
   * "image",
   * "timezone"])
   * -------------------------------------------
   * The above call will map the fields other than the
   * exlusion list from the given keys to the destination payload
   *
   */


  function extractCustomFields(message, destination, keys, exclusionFields) {
    keys.map(function (key) {
      var messageContext = getValue(message, key);

      if (messageContext) {
        var objKeys = [];
        Object.keys(messageContext).map(function (k) {
          if (exclusionFields.indexOf(k) < 0) {
            objKeys.push(k);
          }
        });
        objKeys.map(function (k) {
          if (!(typeof messageContext[k] === "undefined")) {
            if (destination) {
              destination[k] = getValue(messageContext, k);
            } else {
              destination = {
                k: getValue(messageContext, k)
              };
            }
          }
        });
      }
    });
    return destination;
  }
  /**
   *
   * @param {*} message
   *
   * Use get-value to retrieve defined trais from message traits
   */


  function getDefinedTraits(message) {
    var traitsValue = {
      userId: getValue(message, "userId") || getValue(message, "context.traits.userId") || getValue(message, "anonymousId"),
      email: getValue(message, "context.traits.email") || getValue(message, "context.traits.Email") || getValue(message, "context.traits.E-mail"),
      phone: getValue(message, "context.traits.phone") || getValue(message, "context.traits.Phone"),
      firstName: getValue(message, "context.traits.firstName") || getValue(message, "context.traits.firstname") || getValue(message, "context.traits.first_name"),
      lastName: getValue(message, "context.traits.lastName") || getValue(message, "context.traits.lastname") || getValue(message, "context.traits.last_name"),
      name: getValue(message, "context.traits.name") || getValue(message, "context.traits.Name"),
      city: getValue(message, "context.traits.city") || getValue(message, "context.traits.City"),
      country: getValue(message, "context.traits.country") || getValue(message, "context.traits.Country")
    };

    if (!getValue(traitsValue, "name") && getValue(traitsValue, "firstName") && getValue(traitsValue, "lastName")) {
      traitsValue.name = "".concat(getValue(traitsValue, "firstName"), " ").concat(getValue(traitsValue, "lastName"));
    }

    return traitsValue;
  }
  /**
   * To check if a variable is storing object or not
   */


  var isObject$1 = function isObject(obj) {
    return type(obj) === "object";
  };
  /**
   * To check if a variable is storing array or not
   */


  var isArray$1 = function isArray(obj) {
    return type(obj) === "array";
  };

  var isDefined = function isDefined(x) {
    return x !== undefined;
  };

  var isNotNull = function isNotNull(x) {
    return x !== null;
  };

  var isDefinedAndNotNull = function isDefinedAndNotNull(x) {
    return isDefined(x) && isNotNull(x);
  };

  var getDataFromSource = function getDataFromSource(src, dest, properties) {
    var data = {};

    if (isArray$1(src)) {
      for (var index = 0; index < src.length; index += 1) {
        if (properties[src[index]]) {
          data[dest] = properties[src[index]];

          if (data) {
            // return only if the value is valid.
            // else look for next possible source in precedence
            return data;
          }
        }
      }
    } else if (typeof src === "string") {
      if (properties[src]) {
        data[dest] = properties[src];
      }
    }

    return data;
  };

  var removeTrailingSlashes = function removeTrailingSlashes(str) {
    return str && str.endsWith("/") ? str.replace(/\/+$/, "") : str;
  };
  /**
   * Using this function we can create a payload from a mapping object.
   * @param {*} object = {
     traits:{
       name: "abcd efgh",
       address: {
         city: "xyz"
       }
     }
    }
   * @param {*} mapper = [
    {
      destKey: "userName",
      sourceKeys: "traits.name",
    },
    {
      destKey: "city",
      sourceKeys: "traits.address.city",
    },
  ]
   * @returns {
     userName : "abcd efgh",
     city : "xyz"
   }

  */


  var constructPayload = function constructPayload(object, mapper) {
    var payload = {};
    if (object) mapper.forEach(function (element) {
      if (!Array.isArray(element.sourceKeys)) {
        payload[element.destKey] = getValue(object, element.sourceKeys);
      } else {
        for (var i = 0; i < element.sourceKeys.length; i += 1) {
          if (getValue(object, element.sourceKeys[i])) {
            payload[element.destKey] = getValue(object, element.sourceKeys[i]);
            break;
          }
        }
      }
    });
    return payload;
  };

  var lodash=createCommonjsModule(function(module,exports){(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined$1;/** Used as the semantic version number. */var VERSION='4.17.21';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function',INVALID_TEMPL_VAR_ERROR_TEXT='Invalid `variable` option passed into `_.template`';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading whitespace. */var reTrimStart=/^\s+/;/** Used to match a single whitespace character. */var reWhitespace=/\s/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/**
     * Used to validate the `validate` option in `_.template` variable.
     *
     * Forbids characters which could potentially change the meaning of the function argument definition:
     * - "()," (modification of function parameters)
     * - "=" (default value)
     * - "[]{}" (destructuring of function parameters)
     * - "/" (beginning of a comment)
     * - whitespace
     */var reForbiddenIdentifierChars=/[()=,{}\[\]\/\s]/;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
     * Used to match
     * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
     */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange="\\ud800-\\udfff",rsComboMarksRange="\\u0300-\\u036f",reComboHalfMarksRange="\\ufe20-\\ufe2f",rsComboSymbolsRange="\\u20d0-\\u20ff",rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange="\\u2700-\\u27bf",rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange="\\u2000-\\u206f",rsSpaceRange=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange="\\ufe0e\\ufe0f",rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz="\\ud83c[\\udffb-\\udfff]",rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional="(?:\\ud83c[\\udde6-\\uddff]){2}",rsSurrPair="[\\ud800-\\udbff][\\udc00-\\udfff]",rsUpper='['+rsUpperRange+']',rsZWJ="\\u200d";/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
     */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
  '\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
  "\u0100":'A',"\u0102":'A',"\u0104":'A',"\u0101":'a',"\u0103":'a',"\u0105":'a',"\u0106":'C',"\u0108":'C',"\u010A":'C',"\u010C":'C',"\u0107":'c',"\u0109":'c',"\u010B":'c',"\u010D":'c',"\u010E":'D',"\u0110":'D',"\u010F":'d',"\u0111":'d',"\u0112":'E',"\u0114":'E',"\u0116":'E',"\u0118":'E',"\u011A":'E',"\u0113":'e',"\u0115":'e',"\u0117":'e',"\u0119":'e',"\u011B":'e',"\u011C":'G',"\u011E":'G',"\u0120":'G',"\u0122":'G',"\u011D":'g',"\u011F":'g',"\u0121":'g',"\u0123":'g',"\u0124":'H',"\u0126":'H',"\u0125":'h',"\u0127":'h',"\u0128":'I',"\u012A":'I',"\u012C":'I',"\u012E":'I',"\u0130":'I',"\u0129":'i',"\u012B":'i',"\u012D":'i',"\u012F":'i',"\u0131":'i',"\u0134":'J',"\u0135":'j',"\u0136":'K',"\u0137":'k',"\u0138":'k',"\u0139":'L',"\u013B":'L',"\u013D":'L',"\u013F":'L',"\u0141":'L',"\u013A":'l',"\u013C":'l',"\u013E":'l',"\u0140":'l',"\u0142":'l',"\u0143":'N',"\u0145":'N',"\u0147":'N',"\u014A":'N',"\u0144":'n',"\u0146":'n',"\u0148":'n',"\u014B":'n',"\u014C":'O',"\u014E":'O',"\u0150":'O',"\u014D":'o',"\u014F":'o',"\u0151":'o',"\u0154":'R',"\u0156":'R',"\u0158":'R',"\u0155":'r',"\u0157":'r',"\u0159":'r',"\u015A":'S',"\u015C":'S',"\u015E":'S',"\u0160":'S',"\u015B":'s',"\u015D":'s',"\u015F":'s',"\u0161":'s',"\u0162":'T',"\u0164":'T',"\u0166":'T',"\u0163":'t',"\u0165":'t',"\u0167":'t',"\u0168":'U',"\u016A":'U',"\u016C":'U',"\u016E":'U',"\u0170":'U',"\u0172":'U',"\u0169":'u',"\u016B":'u',"\u016D":'u',"\u016F":'u',"\u0171":'u',"\u0173":'u',"\u0174":'W',"\u0175":'w',"\u0176":'Y',"\u0177":'y',"\u0178":'Y',"\u0179":'Z',"\u017B":'Z',"\u017D":'Z',"\u017A":'z',"\u017C":'z',"\u017E":'z',"\u0132":'IJ',"\u0133":'ij',"\u0152":'Oe',"\u0153":'oe',"\u0149":"'n","\u017F":'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r',"\u2028":'u2028',"\u2029":'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=_typeof(commonjsGlobal)=='object'&&commonjsGlobal&&commonjsGlobal.Object===Object&&commonjsGlobal;/** Detect free variable `self`. */var freeSelf=(typeof self==="undefined"?"undefined":_typeof(self))=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&'object'=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
  var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
  return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*/ /**
     * A faster alternative to `Function#apply`, this function invokes `func`
     * with the `this` binding of `thisArg` and the arguments of `args`.
     *
     * @private
     * @param {Function} func The function to invoke.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} args The arguments to invoke `func` with.
     * @returns {*} Returns the result of `func`.
     */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
     * A specialized version of `baseAggregator` for arrays.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
     * A specialized version of `_.forEachRight` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
     * A specialized version of `_.every` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
     * A specialized version of `_.includes` for arrays without support for
     * specifying an index to search from.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */function arrayIncludes(array,value){var length=array==null?0:array.length;return !!length&&baseIndexOf(array,value,0)>-1;}/**
     * This function is like `arrayIncludes` except that it accepts a comparator.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @param {Function} comparator The comparator invoked per element.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
     * A specialized version of `_.reduceRight` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the last element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
     * Gets the size of an ASCII `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */var asciiSize=baseProperty('length');/**
     * Converts an ASCII `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */function asciiToArray(string){return string.split('');}/**
     * Splits an ASCII `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
     * The base implementation of methods like `_.findKey` and `_.findLastKey`,
     * without support for iteratee shorthands, which iterates over `collection`
     * using `eachFunc`.
     *
     * @private
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return -1;}/**
     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
     * This function is like `baseIndexOf` except that it accepts a comparator.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @param {Function} comparator The comparator invoked per element.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return -1;}/**
     * The base implementation of `_.isNaN` without support for number objects.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     */function baseIsNaN(value){return value!==value;}/**
     * The base implementation of `_.mean` and `_.meanBy` without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the mean.
     */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function baseProperty(key){return function(object){return object==null?undefined$1:object[key];};}/**
     * The base implementation of `_.propertyOf` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyOf(object){return function(key){return object==null?undefined$1:object[key];};}/**
     * The base implementation of `_.reduce` and `_.reduceRight`, without support
     * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initAccum Specify using the first or last element of
     *  `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
     * The base implementation of `_.sortBy` which uses `comparer` to define the
     * sort order of `array` and replaces criteria objects with their corresponding
     * values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
     * The base implementation of `_.sum` and `_.sumBy` without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined$1){result=result===undefined$1?current:result+current;}}return result;}/**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
     * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
     * of key-value pairs for `object` corresponding to the property names of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the key-value pairs.
     */function baseToPairs(object,props){return arrayMap(props,function(key){return [key,object[key]];});}/**
     * The base implementation of `_.trim`.
     *
     * @private
     * @param {string} string The string to trim.
     * @returns {string} Returns the trimmed string.
     */function baseTrim(string){return string?string.slice(0,trimmedEndIndex(string)+1).replace(reTrimStart,''):string;}/**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */function baseUnary(func){return function(value){return func(value);};}/**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function cacheHas(cache,key){return cache.has(key);}/**
     * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
     * that is not found in the character symbols.
     *
     * @private
     * @param {Array} strSymbols The string symbols to inspect.
     * @param {Array} chrSymbols The character symbols to find.
     * @returns {number} Returns the index of the first unmatched string symbol.
     */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
     * that is not found in the character symbols.
     *
     * @private
     * @param {Array} strSymbols The string symbols to inspect.
     * @param {Array} chrSymbols The character symbols to find.
     * @returns {number} Returns the index of the last unmatched string symbol.
     */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
     * Gets the number of `placeholder` occurrences in `array`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} placeholder The placeholder to search for.
     * @returns {number} Returns the placeholder count.
     */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
     * letters to basic Latin letters.
     *
     * @private
     * @param {string} letter The matched letter to deburr.
     * @returns {string} Returns the deburred letter.
     */var deburrLetter=basePropertyOf(deburredLetters);/**
     * Used by `_.escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} chr The matched character to escape.
     * @returns {string} Returns the escaped character.
     */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
     * Used by `_.template` to escape characters for inclusion in compiled string literals.
     *
     * @private
     * @param {string} chr The matched character to escape.
     * @returns {string} Returns the escaped character.
     */function escapeStringChar(chr){return '\\'+stringEscapes[chr];}/**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function getValue(object,key){return object==null?undefined$1:object[key];}/**
     * Checks if `string` contains Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
     */function hasUnicode(string){return reHasUnicode.test(string);}/**
     * Checks if `string` contains a word composed of Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a word is found, else `false`.
     */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
     * Converts `iterator` to an array.
     *
     * @private
     * @param {Object} iterator The iterator to convert.
     * @returns {Array} Returns the converted array.
     */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
     * Replaces all `placeholder` elements in `array` with an internal placeholder
     * and returns an array of their indexes.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {*} placeholder The placeholder to replace.
     * @returns {Array} Returns the new array of placeholder indexes.
     */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
     * Converts `set` to its value-value pairs.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the value-value pairs.
     */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
     * A specialized version of `_.indexOf` which performs strict equality
     * comparisons of values, i.e. `===`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return -1;}/**
     * A specialized version of `_.lastIndexOf` which performs strict equality
     * comparisons of values, i.e. `===`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
     * Gets the number of symbols in `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the string size.
     */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
     * character of `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the index of the last non-whitespace character.
     */function trimmedEndIndex(string){var index=string.length;while(index--&&reWhitespace.test(string.charAt(index))){}return index;}/**
     * Used by `_.unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} chr The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
     * Gets the size of a Unicode `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
     * Converts a Unicode `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
     * Splits a Unicode `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*/ /**
     * Create a new pristine `lodash` function using the `context` object.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Util
     * @param {Object} [context=root] The context object.
     * @returns {Function} Returns a new `lodash` function.
     * @example
     *
     * _.mixin({ 'foo': _.constant('foo') });
     *
     * var lodash = _.runInContext();
     * lodash.mixin({ 'bar': lodash.constant('bar') });
     *
     * _.isFunction(_.foo);
     * // => true
     * _.isFunction(_.bar);
     * // => false
     *
     * lodash.isFunction(lodash.foo);
     * // => false
     * lodash.isFunction(lodash.bar);
     * // => true
     *
     * // Create a suped-up `defer` in Node.js.
     * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
     */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined$1,_Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined$1,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=_Symbol?_Symbol.isConcatSpreadable:undefined$1,symIterator=_Symbol?_Symbol.iterator:undefined$1,symToStringTag=_Symbol?_Symbol.toStringTag:undefined$1;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined$1,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol?_Symbol.prototype:undefined$1,symbolValueOf=symbolProto?symbolProto.valueOf:undefined$1,symbolToString=symbolProto?symbolProto.toString:undefined$1;/*------------------------------------------------------------------------*/ /**
       * Creates a `lodash` object which wraps `value` to enable implicit method
       * chain sequences. Methods that operate on and return arrays, collections,
       * and functions can be chained together. Methods that retrieve a single value
       * or may return a primitive value will automatically end the chain sequence
       * and return the unwrapped value. Otherwise, the value must be unwrapped
       * with `_#value`.
       *
       * Explicit chain sequences, which must be unwrapped with `_#value`, may be
       * enabled using `_.chain`.
       *
       * The execution of chained methods is lazy, that is, it's deferred until
       * `_#value` is implicitly or explicitly called.
       *
       * Lazy evaluation allows several methods to support shortcut fusion.
       * Shortcut fusion is an optimization to merge iteratee calls; this avoids
       * the creation of intermediate arrays and can greatly reduce the number of
       * iteratee executions. Sections of a chain sequence qualify for shortcut
       * fusion if the section is applied to an array and iteratees accept only
       * one argument. The heuristic for whether a section qualifies for shortcut
       * fusion is subject to change.
       *
       * Chaining is supported in custom builds as long as the `_#value` method is
       * directly or indirectly included in the build.
       *
       * In addition to lodash methods, wrappers have `Array` and `String` methods.
       *
       * The wrapper `Array` methods are:
       * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
       *
       * The wrapper `String` methods are:
       * `replace` and `split`
       *
       * The wrapper methods that support shortcut fusion are:
       * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
       * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
       * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
       *
       * The chainable wrapper methods are:
       * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
       * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
       * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
       * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
       * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
       * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
       * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
       * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
       * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
       * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
       * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
       * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
       * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
       * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
       * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
       * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
       * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
       * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
       * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
       * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
       * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
       * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
       * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
       * `zipObject`, `zipObjectDeep`, and `zipWith`
       *
       * The wrapper methods that are **not** chainable by default are:
       * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
       * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
       * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
       * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
       * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
       * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
       * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
       * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
       * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
       * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
       * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
       * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
       * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
       * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
       * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
       * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
       * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
       * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
       * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
       * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
       * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
       * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
       * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
       * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
       * `upperFirst`, `value`, and `words`
       *
       * @name _
       * @constructor
       * @category Seq
       * @param {*} value The value to wrap in a `lodash` instance.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var wrapped = _([1, 2, 3]);
       *
       * // Returns an unwrapped value.
       * wrapped.reduce(_.add);
       * // => 6
       *
       * // Returns a wrapped value.
       * var squares = wrapped.map(square);
       *
       * _.isArray(squares);
       * // => false
       *
       * _.isArray(squares.value());
       * // => true
       */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
       * The base implementation of `_.create` without support for assigning
       * properties to the created object.
       *
       * @private
       * @param {Object} proto The object to inherit from.
       * @returns {Object} Returns the new object.
       */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return {};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined$1;return result;};}();/**
       * The function whose prototype chain sequence wrappers inherit from.
       *
       * @private
       */function baseLodash(){// No operation performed.
  }/**
       * The base constructor for creating `lodash` wrapper objects.
       *
       * @private
       * @param {*} value The value to wrap.
       * @param {boolean} [chainAll] Enable explicit method chain sequences.
       */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined$1;}/**
       * By default, the template delimiters used by lodash are like those in
       * embedded Ruby (ERB) as well as ES2015 template strings. Change the
       * following template settings to use alternative delimiters.
       *
       * @static
       * @memberOf _
       * @type {Object}
       */lodash.templateSettings={/**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */'escape':reEscape,/**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */'evaluate':reEvaluate,/**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */'interpolate':reInterpolate,/**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */'variable':'',/**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */'imports':{/**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
  lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*/ /**
       * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
       *
       * @private
       * @constructor
       * @param {*} value The value to wrap.
       */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
       * Creates a clone of the lazy wrapper object.
       *
       * @private
       * @name clone
       * @memberOf LazyWrapper
       * @returns {Object} Returns the cloned `LazyWrapper` object.
       */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
       * Reverses the direction of lazy iteration.
       *
       * @private
       * @name reverse
       * @memberOf LazyWrapper
       * @returns {Object} Returns the new reversed `LazyWrapper` object.
       */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else {result=this.clone();result.__dir__*=-1;}return result;}/**
       * Extracts the unwrapped value from its lazy wrapper.
       *
       * @private
       * @name value
       * @memberOf LazyWrapper
       * @returns {*} Returns the unwrapped value.
       */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else {break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
  LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*/ /**
       * Creates a hash object.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
       * Removes all key-value entries from the hash.
       *
       * @private
       * @name clear
       * @memberOf Hash
       */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
       * Removes `key` and its value from the hash.
       *
       * @private
       * @name delete
       * @memberOf Hash
       * @param {Object} hash The hash to modify.
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
       * Gets the hash value for `key`.
       *
       * @private
       * @name get
       * @memberOf Hash
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined$1:result;}return hasOwnProperty.call(data,key)?data[key]:undefined$1;}/**
       * Checks if a hash value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf Hash
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined$1:hasOwnProperty.call(data,key);}/**
       * Sets the hash `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf Hash
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the hash instance.
       */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined$1?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
  Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*/ /**
       * Creates an list cache object.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
       * Removes all key-value entries from the list cache.
       *
       * @private
       * @name clear
       * @memberOf ListCache
       */function listCacheClear(){this.__data__=[];this.size=0;}/**
       * Removes `key` and its value from the list cache.
       *
       * @private
       * @name delete
       * @memberOf ListCache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else {splice.call(data,index,1);}--this.size;return true;}/**
       * Gets the list cache value for `key`.
       *
       * @private
       * @name get
       * @memberOf ListCache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined$1:data[index][1];}/**
       * Checks if a list cache value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf ListCache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
       * Sets the list cache `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf ListCache
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the list cache instance.
       */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else {data[index][1]=value;}return this;}// Add methods to `ListCache`.
  ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*/ /**
       * Creates a map cache object to store key-value pairs.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
       * Removes all key-value entries from the map.
       *
       * @private
       * @name clear
       * @memberOf MapCache
       */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
       * Removes `key` and its value from the map.
       *
       * @private
       * @name delete
       * @memberOf MapCache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
       * Gets the map value for `key`.
       *
       * @private
       * @name get
       * @memberOf MapCache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
       * Checks if a map value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf MapCache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
       * Sets the map `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf MapCache
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the map cache instance.
       */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
  MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*/ /**
       *
       * Creates an array cache object to store unique values.
       *
       * @private
       * @constructor
       * @param {Array} [values] The values to cache.
       */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
       * Adds `value` to the array cache.
       *
       * @private
       * @name add
       * @memberOf SetCache
       * @alias push
       * @param {*} value The value to cache.
       * @returns {Object} Returns the cache instance.
       */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
       * Checks if `value` is in the array cache.
       *
       * @private
       * @name has
       * @memberOf SetCache
       * @param {*} value The value to search for.
       * @returns {number} Returns `true` if `value` is found, else `false`.
       */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
  SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*/ /**
       * Creates a stack cache object to store key-value pairs.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
       * Removes all key-value entries from the stack.
       *
       * @private
       * @name clear
       * @memberOf Stack
       */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
       * Removes `key` and its value from the stack.
       *
       * @private
       * @name delete
       * @memberOf Stack
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
       * Gets the stack value for `key`.
       *
       * @private
       * @name get
       * @memberOf Stack
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */function stackGet(key){return this.__data__.get(key);}/**
       * Checks if a stack value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf Stack
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */function stackHas(key){return this.__data__.has(key);}/**
       * Sets the stack `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf Stack
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the stack cache instance.
       */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
  Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*/ /**
       * Creates an array of the enumerable property names of the array-like `value`.
       *
       * @private
       * @param {*} value The value to query.
       * @param {boolean} inherited Specify returning inherited property names.
       * @returns {Array} Returns the array of property names.
       */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
  key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
  isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
  isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
  isIndex(key,length)))){result.push(key);}}return result;}/**
       * A specialized version of `_.sample` for arrays.
       *
       * @private
       * @param {Array} array The array to sample.
       * @returns {*} Returns the random element.
       */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined$1;}/**
       * A specialized version of `_.sampleSize` for arrays.
       *
       * @private
       * @param {Array} array The array to sample.
       * @param {number} n The number of elements to sample.
       * @returns {Array} Returns the random elements.
       */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
       * A specialized version of `_.shuffle` for arrays.
       *
       * @private
       * @param {Array} array The array to shuffle.
       * @returns {Array} Returns the new shuffled array.
       */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
       * This function is like `assignValue` except that it doesn't assign
       * `undefined` values.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */function assignMergeValue(object,key,value){if(value!==undefined$1&&!eq(object[key],value)||value===undefined$1&&!(key in object)){baseAssignValue(object,key,value);}}/**
       * Assigns `value` to `key` of `object` if the existing value is not equivalent
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined$1&&!(key in object)){baseAssignValue(object,key,value);}}/**
       * Gets the index at which the `key` is found in `array` of key-value pairs.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} key The key to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return -1;}/**
       * Aggregates elements of `collection` on `accumulator` with keys transformed
       * by `iteratee` and values set by `setter`.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform keys.
       * @param {Object} accumulator The initial aggregated object.
       * @returns {Function} Returns `accumulator`.
       */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
       * The base implementation of `_.assign` without support for multiple sources
       * or `customizer` functions.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @returns {Object} Returns `object`.
       */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
       * The base implementation of `_.assignIn` without support for multiple sources
       * or `customizer` functions.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @returns {Object} Returns `object`.
       */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
       * The base implementation of `assignValue` and `assignMergeValue` without
       * value checks.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else {object[key]=value;}}/**
       * The base implementation of `_.at` without support for individual paths.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {string[]} paths The property paths to pick.
       * @returns {Array} Returns the picked elements.
       */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined$1:get(object,paths[index]);}return result;}/**
       * The base implementation of `_.clamp` which doesn't coerce arguments.
       *
       * @private
       * @param {number} number The number to clamp.
       * @param {number} [lower] The lower bound.
       * @param {number} upper The upper bound.
       * @returns {number} Returns the clamped number.
       */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined$1){number=number<=upper?number:upper;}if(lower!==undefined$1){number=number>=lower?number:lower;}}return number;}/**
       * The base implementation of `_.clone` and `_.cloneDeep` which tracks
       * traversed objects.
       *
       * @private
       * @param {*} value The value to clone.
       * @param {boolean} bitmask The bitmask flags.
       *  1 - Deep clone
       *  2 - Flatten inherited properties
       *  4 - Clone symbols
       * @param {Function} [customizer] The function to customize cloning.
       * @param {string} [key] The key of `value`.
       * @param {Object} [object] The parent object of `value`.
       * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
       * @returns {*} Returns the cloned value.
       */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined$1){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else {var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else {if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
  stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined$1:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
  assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
       * The base implementation of `_.conforms` which doesn't clone `source`.
       *
       * @private
       * @param {Object} source The object of property predicates to conform to.
       * @returns {Function} Returns the new spec function.
       */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
       * The base implementation of `_.conformsTo` which accepts `props` to check.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property predicates to conform to.
       * @returns {boolean} Returns `true` if `object` conforms, else `false`.
       */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return !length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined$1&&!(key in object)||!predicate(value)){return false;}}return true;}/**
       * The base implementation of `_.delay` and `_.defer` which accepts `args`
       * to provide to `func`.
       *
       * @private
       * @param {Function} func The function to delay.
       * @param {number} wait The number of milliseconds to delay invocation.
       * @param {Array} args The arguments to provide to `func`.
       * @returns {number|Object} Returns the timer id or timeout object.
       */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined$1,args);},wait);}/**
       * The base implementation of methods like `_.difference` without support
       * for excluding multiple arrays or iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Array} values The values to exclude.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
       * The base implementation of `_.forEach` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       */var baseEach=createBaseEach(baseForOwn);/**
       * The base implementation of `_.forEachRight` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
       * The base implementation of `_.every` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`
       */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
       * The base implementation of methods like `_.max` and `_.min` which accepts a
       * `comparator` to determine the extremum value.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The iteratee invoked per iteration.
       * @param {Function} comparator The comparator used to compare values.
       * @returns {*} Returns the extremum value.
       */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined$1?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
       * The base implementation of `_.fill` without an iteratee call guard.
       *
       * @private
       * @param {Array} array The array to fill.
       * @param {*} value The value to fill `array` with.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns `array`.
       */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined$1||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
       * The base implementation of `_.filter` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
       * The base implementation of `_.flatten` with support for restricting flattening.
       *
       * @private
       * @param {Array} array The array to flatten.
       * @param {number} depth The maximum recursion depth.
       * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
       * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
       * @param {Array} [result=[]] The initial result value.
       * @returns {Array} Returns the new flattened array.
       */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
  baseFlatten(value,depth-1,predicate,isStrict,result);}else {arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
       * The base implementation of `baseForOwn` which iterates over `object`
       * properties returned by `keysFunc` and invokes `iteratee` for each property.
       * Iteratee functions may exit iteration early by explicitly returning `false`.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @returns {Object} Returns `object`.
       */var baseFor=createBaseFor();/**
       * This function is like `baseFor` except that it iterates over properties
       * in the opposite order.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @returns {Object} Returns `object`.
       */var baseForRight=createBaseFor(true);/**
       * The base implementation of `_.forOwn` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Object} Returns `object`.
       */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
       * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Object} Returns `object`.
       */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
       * The base implementation of `_.functions` which creates an array of
       * `object` function property names filtered from `props`.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @param {Array} props The property names to filter.
       * @returns {Array} Returns the function names.
       */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
       * The base implementation of `_.get` without support for default values.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to get.
       * @returns {*} Returns the resolved value.
       */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined$1;}/**
       * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
       * `keysFunc` and `symbolsFunc` to get the enumerable property names and
       * symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @param {Function} symbolsFunc The function to get the symbols of `object`.
       * @returns {Array} Returns the array of property names and symbols.
       */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
       * The base implementation of `getTag` without fallbacks for buggy environments.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */function baseGetTag(value){if(value==null){return value===undefined$1?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
       * The base implementation of `_.gt` which doesn't coerce arguments.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is greater than `other`,
       *  else `false`.
       */function baseGt(value,other){return value>other;}/**
       * The base implementation of `_.has` without support for deep paths.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {Array|string} key The key to check.
       * @returns {boolean} Returns `true` if `key` exists, else `false`.
       */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
       * The base implementation of `_.hasIn` without support for deep paths.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {Array|string} key The key to check.
       * @returns {boolean} Returns `true` if `key` exists, else `false`.
       */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
       * The base implementation of `_.inRange` which doesn't coerce arguments.
       *
       * @private
       * @param {number} number The number to check.
       * @param {number} start The start of the range.
       * @param {number} end The end of the range.
       * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
       */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
       * The base implementation of methods like `_.intersection`, without support
       * for iteratee shorthands, that accepts an array of arrays to inspect.
       *
       * @private
       * @param {Array} arrays The arrays to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of shared values.
       */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined$1;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
       * The base implementation of `_.invert` and `_.invertBy` which inverts
       * `object` with values transformed by `iteratee` and set by `setter`.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform values.
       * @param {Object} accumulator The initial inverted object.
       * @returns {Function} Returns `accumulator`.
       */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
       * The base implementation of `_.invoke` without support for individual
       * method arguments.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the method to invoke.
       * @param {Array} args The arguments to invoke the method with.
       * @returns {*} Returns the result of the invoked method.
       */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined$1:apply(func,object,args);}/**
       * The base implementation of `_.isArguments`.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
       * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
       */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
       * The base implementation of `_.isDate` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
       */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
       * The base implementation of `_.isEqual` which supports partial comparisons
       * and tracks traversed objects.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @param {boolean} bitmask The bitmask flags.
       *  1 - Unordered comparison
       *  2 - Partial comparison
       * @param {Function} [customizer] The function to customize comparisons.
       * @param {Object} [stack] Tracks traversed `value` and `other` objects.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
       * A specialized version of `baseIsEqual` for arrays and objects which performs
       * deep comparisons and tracks traversed objects enabling objects with circular
       * references to be compared.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} [stack] Tracks traversed `object` and `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
       * The base implementation of `_.isMap` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a map, else `false`.
       */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
       * The base implementation of `_.isMatch` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property values to match.
       * @param {Array} matchData The property names, values, and compare flags to match.
       * @param {Function} [customizer] The function to customize comparisons.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return !length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined$1&&!(key in object)){return false;}}else {var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined$1?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
       * The base implementation of `_.isNative` without bad shim checks.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a native function,
       *  else `false`.
       */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
       * The base implementation of `_.isRegExp` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
       */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
       * The base implementation of `_.isSet` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a set, else `false`.
       */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
       * The base implementation of `_.isTypedArray` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
       */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
       * The base implementation of `_.iteratee`.
       *
       * @private
       * @param {*} [value=_.identity] The value to convert to an iteratee.
       * @returns {Function} Returns the iteratee.
       */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if(typeof value=='function'){return value;}if(value==null){return identity;}if(_typeof(value)=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
       * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
       * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
       * The base implementation of `_.lt` which doesn't coerce arguments.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is less than `other`,
       *  else `false`.
       */function baseLt(value,other){return value<other;}/**
       * The base implementation of `_.map` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
       * The base implementation of `_.matches` which doesn't clone `source`.
       *
       * @private
       * @param {Object} source The object of property values to match.
       * @returns {Function} Returns the new spec function.
       */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
       * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
       *
       * @private
       * @param {string} path The path of the property to get.
       * @param {*} srcValue The value to match.
       * @returns {Function} Returns the new spec function.
       */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined$1&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
       * The base implementation of `_.merge` without support for multiple sources.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @param {number} srcIndex The index of `source`.
       * @param {Function} [customizer] The function to customize merged values.
       * @param {Object} [stack] Tracks traversed source values and their merged
       *  counterparts.
       */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else {var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined$1;if(newValue===undefined$1){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
       * A specialized version of `baseMerge` for arrays and objects which performs
       * deep merges and tracks traversed objects enabling objects with circular
       * references to be merged.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @param {string} key The key of the value to merge.
       * @param {number} srcIndex The index of `source`.
       * @param {Function} mergeFunc The function to merge values.
       * @param {Function} [customizer] The function to customize assigned values.
       * @param {Object} [stack] Tracks traversed source values and their merged
       *  counterparts.
       */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined$1;var isCommon=newValue===undefined$1;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else {newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else {isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
  stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
       * The base implementation of `_.nth` which doesn't coerce arguments.
       *
       * @private
       * @param {Array} array The array to query.
       * @param {number} n The index of the element to return.
       * @returns {*} Returns the nth element of `array`.
       */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined$1;}/**
       * The base implementation of `_.orderBy` without param guards.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
       * @param {string[]} orders The sort orders of `iteratees`.
       * @returns {Array} Returns the new sorted array.
       */function baseOrderBy(collection,iteratees,orders){if(iteratees.length){iteratees=arrayMap(iteratees,function(iteratee){if(isArray(iteratee)){return function(value){return baseGet(value,iteratee.length===1?iteratee[0]:iteratee);};}return iteratee;});}else {iteratees=[identity];}var index=-1;iteratees=arrayMap(iteratees,baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return {'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
       * The base implementation of `_.pick` without support for individual
       * property identifiers.
       *
       * @private
       * @param {Object} object The source object.
       * @param {string[]} paths The property paths to pick.
       * @returns {Object} Returns the new object.
       */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
       * The base implementation of  `_.pickBy` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The source object.
       * @param {string[]} paths The property paths to pick.
       * @param {Function} predicate The function invoked per property.
       * @returns {Object} Returns the new object.
       */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
       * A specialized version of `baseProperty` which supports deep paths.
       *
       * @private
       * @param {Array|string} path The path of the property to get.
       * @returns {Function} Returns the new accessor function.
       */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
       * The base implementation of `_.pullAllBy` without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns `array`.
       */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
       * The base implementation of `_.pullAt` without support for individual
       * indexes or capturing the removed elements.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {number[]} indexes The indexes of elements to remove.
       * @returns {Array} Returns `array`.
       */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else {baseUnset(array,index);}}}return array;}/**
       * The base implementation of `_.random` without support for returning
       * floating-point numbers.
       *
       * @private
       * @param {number} lower The lower bound.
       * @param {number} upper The upper bound.
       * @returns {number} Returns the random number.
       */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
       * The base implementation of `_.range` and `_.rangeRight` which doesn't
       * coerce arguments.
       *
       * @private
       * @param {number} start The start of the range.
       * @param {number} end The end of the range.
       * @param {number} step The value to increment or decrement by.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Array} Returns the range of numbers.
       */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
       * The base implementation of `_.repeat` which doesn't coerce arguments.
       *
       * @private
       * @param {string} string The string to repeat.
       * @param {number} n The number of times to repeat the string.
       * @returns {string} Returns the repeated string.
       */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
  do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
       * The base implementation of `_.rest` which doesn't validate or coerce arguments.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @returns {Function} Returns the new function.
       */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
       * The base implementation of `_.sample`.
       *
       * @private
       * @param {Array|Object} collection The collection to sample.
       * @returns {*} Returns the random element.
       */function baseSample(collection){return arraySample(values(collection));}/**
       * The base implementation of `_.sampleSize` without param guards.
       *
       * @private
       * @param {Array|Object} collection The collection to sample.
       * @param {number} n The number of elements to sample.
       * @returns {Array} Returns the random elements.
       */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
       * The base implementation of `_.set`.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {*} value The value to set.
       * @param {Function} [customizer] The function to customize path creation.
       * @returns {Object} Returns `object`.
       */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(key==='__proto__'||key==='constructor'||key==='prototype'){return object;}if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined$1;if(newValue===undefined$1){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
       * The base implementation of `setData` without support for hot loop shorting.
       *
       * @private
       * @param {Function} func The function to associate metadata with.
       * @param {*} data The metadata.
       * @returns {Function} Returns `func`.
       */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
       * The base implementation of `setToString` without support for hot loop shorting.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
       * The base implementation of `_.shuffle`.
       *
       * @private
       * @param {Array|Object} collection The collection to shuffle.
       * @returns {Array} Returns the new shuffled array.
       */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
       * The base implementation of `_.slice` without an iteratee call guard.
       *
       * @private
       * @param {Array} array The array to slice.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns the slice of `array`.
       */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
       * The base implementation of `_.some` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return !result;});return !!result;}/**
       * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
       * performs a binary search of `array` to determine the index at which `value`
       * should be inserted into `array` in order to maintain its sort order.
       *
       * @private
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {boolean} [retHighest] Specify returning the highest qualified index.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else {high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
       * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
       * which invokes `iteratee` for `value` and each element of `array` to compute
       * their sort ranking. The iteratee is invoked with one argument; (value).
       *
       * @private
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {Function} iteratee The iteratee invoked per element.
       * @param {boolean} [retHighest] Specify returning the highest qualified index.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       */function baseSortedIndexBy(array,value,iteratee,retHighest){var low=0,high=array==null?0:array.length;if(high===0){return 0;}value=iteratee(value);var valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined$1;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined$1,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else {setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else {high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
       * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
       * support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
       * The base implementation of `_.toNumber` which doesn't ensure correct
       * conversions of binary, hexadecimal, or octal string values.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {number} Returns the number.
       */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return +value;}/**
       * The base implementation of `_.toString` which doesn't convert nullish
       * values to empty strings.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
  if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
  return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
       * The base implementation of `_.uniqBy` without support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else {seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
       * The base implementation of `_.unset`.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {Array|string} path The property path to unset.
       * @returns {boolean} Returns `true` if the property is deleted, else `false`.
       */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
       * The base implementation of `_.update`.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to update.
       * @param {Function} updater The function to produce the updated value.
       * @param {Function} [customizer] The function to customize path creation.
       * @returns {Object} Returns `object`.
       */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
       * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
       * without support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to query.
       * @param {Function} predicate The function invoked per iteration.
       * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Array} Returns the slice of `array`.
       */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
       * The base implementation of `wrapperValue` which returns the result of
       * performing a sequence of actions on the unwrapped `value`, where each
       * successive action is supplied the return value of the previous.
       *
       * @private
       * @param {*} value The unwrapped value.
       * @param {Array} actions Actions to perform to resolve the unwrapped value.
       * @returns {*} Returns the resolved value.
       */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
       * The base implementation of methods like `_.xor`, without support for
       * iteratee shorthands, that accepts an array of arrays to inspect.
       *
       * @private
       * @param {Array} arrays The arrays to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of values.
       */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
       * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
       *
       * @private
       * @param {Array} props The property identifiers.
       * @param {Array} values The property values.
       * @param {Function} assignFunc The function to assign values.
       * @returns {Object} Returns the new object.
       */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined$1;assignFunc(result,props[index],value);}return result;}/**
       * Casts `value` to an empty array if it's not an array like object.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {Array|Object} Returns the cast array-like object.
       */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
       * Casts `value` to `identity` if it's not a function.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {Function} Returns cast function.
       */function castFunction(value){return typeof value=='function'?value:identity;}/**
       * Casts `value` to a path array if it's not one.
       *
       * @private
       * @param {*} value The value to inspect.
       * @param {Object} [object] The object to query keys on.
       * @returns {Array} Returns the cast property path array.
       */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
       * A `baseRest` alias which can be replaced with `identity` by module
       * replacement plugins.
       *
       * @private
       * @type {Function}
       * @param {Function} func The function to apply a rest parameter to.
       * @returns {Function} Returns the new function.
       */var castRest=baseRest;/**
       * Casts `array` to a slice if it's needed.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {number} start The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns the cast slice.
       */function castSlice(array,start,end){var length=array.length;end=end===undefined$1?length:end;return !start&&end>=length?array:baseSlice(array,start,end);}/**
       * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
       *
       * @private
       * @param {number|Object} id The timer id or timeout object of the timer to clear.
       */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
       * Creates a clone of  `buffer`.
       *
       * @private
       * @param {Buffer} buffer The buffer to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Buffer} Returns the cloned buffer.
       */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
       * Creates a clone of `arrayBuffer`.
       *
       * @private
       * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
       * @returns {ArrayBuffer} Returns the cloned array buffer.
       */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
       * Creates a clone of `dataView`.
       *
       * @private
       * @param {Object} dataView The data view to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the cloned data view.
       */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
       * Creates a clone of `regexp`.
       *
       * @private
       * @param {Object} regexp The regexp to clone.
       * @returns {Object} Returns the cloned regexp.
       */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
       * Creates a clone of the `symbol` object.
       *
       * @private
       * @param {Object} symbol The symbol object to clone.
       * @returns {Object} Returns the cloned symbol object.
       */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
       * Creates a clone of `typedArray`.
       *
       * @private
       * @param {Object} typedArray The typed array to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the cloned typed array.
       */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
       * Compares values to sort them in ascending order.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {number} Returns the sort order indicator for `value`.
       */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined$1,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined$1,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return -1;}}return 0;}/**
       * Used by `_.orderBy` to compare multiple properties of a value to another
       * and stable sort them.
       *
       * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
       * specify an order of "desc" for descending or "asc" for ascending sort order
       * of corresponding values.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {boolean[]|string[]} orders The order to sort by for each property.
       * @returns {number} Returns the sort order indicator for `object`.
       */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index-other.index;}/**
       * Creates an array that is the composition of partially applied arguments,
       * placeholders, and provided arguments into a single array of arguments.
       *
       * @private
       * @param {Array} args The provided arguments.
       * @param {Array} partials The arguments to prepend to those provided.
       * @param {Array} holders The `partials` placeholder indexes.
       * @params {boolean} [isCurried] Specify composing for a curried function.
       * @returns {Array} Returns the new array of composed arguments.
       */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
       * This function is like `composeArgs` except that the arguments composition
       * is tailored for `_.partialRight`.
       *
       * @private
       * @param {Array} args The provided arguments.
       * @param {Array} partials The arguments to append to those provided.
       * @param {Array} holders The `partials` placeholder indexes.
       * @params {boolean} [isCurried] Specify composing for a curried function.
       * @returns {Array} Returns the new array of composed arguments.
       */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
       * Copies the values of `source` to `array`.
       *
       * @private
       * @param {Array} source The array to copy values from.
       * @param {Array} [array=[]] The array to copy values to.
       * @returns {Array} Returns `array`.
       */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
       * Copies properties of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy properties from.
       * @param {Array} props The property identifiers to copy.
       * @param {Object} [object={}] The object to copy properties to.
       * @param {Function} [customizer] The function to customize copied values.
       * @returns {Object} Returns `object`.
       */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined$1;if(newValue===undefined$1){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else {assignValue(object,key,newValue);}}return object;}/**
       * Copies own symbols of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy symbols from.
       * @param {Object} [object={}] The object to copy symbols to.
       * @returns {Object} Returns `object`.
       */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
       * Copies own and inherited symbols of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy symbols from.
       * @param {Object} [object={}] The object to copy symbols to.
       * @returns {Object} Returns `object`.
       */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
       * Creates a function like `_.groupBy`.
       *
       * @private
       * @param {Function} setter The function to set accumulator values.
       * @param {Function} [initializer] The accumulator object initializer.
       * @returns {Function} Returns the new aggregator function.
       */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
       * Creates a function like `_.assign`.
       *
       * @private
       * @param {Function} assigner The function to assign values.
       * @returns {Function} Returns the new assigner function.
       */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined$1,guard=length>2?sources[2]:undefined$1;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined$1;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined$1:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
       * Creates a `baseEach` or `baseEachRight` function.
       *
       * @private
       * @param {Function} eachFunc The function to iterate over a collection.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new base function.
       */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
       * Creates a base function for methods like `_.forIn` and `_.forOwn`.
       *
       * @private
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new base function.
       */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
       * Creates a function that wraps `func` to invoke it with the optional `this`
       * binding of `thisArg`.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
       * Creates a function like `_.lowerFirst`.
       *
       * @private
       * @param {string} methodName The name of the `String` case method to use.
       * @returns {Function} Returns the new case function.
       */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined$1;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
       * Creates a function like `_.camelCase`.
       *
       * @private
       * @param {Function} callback The function to combine each word.
       * @returns {Function} Returns the new compounder function.
       */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
       * Creates a function that produces an instance of `Ctor` regardless of
       * whether it was invoked as part of a `new` expression or by `call` or `apply`.
       *
       * @private
       * @param {Function} Ctor The constructor to wrap.
       * @returns {Function} Returns the new wrapped function.
       */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
  // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
  // for more details.
  var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
  // See https://es5.github.io/#x13.2.2 for more details.
  return isObject(result)?result:thisBinding;};}/**
       * Creates a function that wraps `func` to enable currying.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {number} arity The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined$1,args,holders,undefined$1,undefined$1,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
       * Creates a `_.find` or `_.findLast` function.
       *
       * @private
       * @param {Function} findIndexFunc The function to find the collection index.
       * @returns {Function} Returns the new find function.
       */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function predicate(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined$1;};}/**
       * Creates a `_.flow` or `_.flowRight` function.
       *
       * @private
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new flow function.
       */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined$1;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else {wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
       * Creates a function that wraps `func` to invoke it with optional `this`
       * binding of `thisArg`, partial application, and currying.
       *
       * @private
       * @param {Function|string} func The function or method name to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param {Array} [partials] The arguments to prepend to those provided to
       *  the new function.
       * @param {Array} [holders] The `partials` placeholder indexes.
       * @param {Array} [partialsRight] The arguments to append to those provided
       *  to the new function.
       * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
       * @param {Array} [argPos] The argument positions of the new function.
       * @param {number} [ary] The arity cap of `func`.
       * @param {number} [arity] The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined$1:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
       * Creates a function like `_.invertBy`.
       *
       * @private
       * @param {Function} setter The function to set accumulator values.
       * @param {Function} toIteratee The function to resolve iteratees.
       * @returns {Function} Returns the new inverter function.
       */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
       * Creates a function that performs a mathematical operation on two values.
       *
       * @private
       * @param {Function} operator The function to perform the operation.
       * @param {number} [defaultValue] The value used for `undefined` arguments.
       * @returns {Function} Returns the new mathematical operation function.
       */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined$1&&other===undefined$1){return defaultValue;}if(value!==undefined$1){result=value;}if(other!==undefined$1){if(result===undefined$1){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else {value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
       * Creates a function like `_.over`.
       *
       * @private
       * @param {Function} arrayFunc The function to iterate over iteratees.
       * @returns {Function} Returns the new over function.
       */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
       * Creates the padding for `string` based on `length`. The `chars` string
       * is truncated if the number of characters exceeds `length`.
       *
       * @private
       * @param {number} length The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padding for `string`.
       */function createPadding(length,chars){chars=chars===undefined$1?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
       * Creates a function that wraps `func` to invoke it with the `this` binding
       * of `thisArg` and `partials` prepended to the arguments it receives.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {Array} partials The arguments to prepend to those provided to
       *  the new function.
       * @returns {Function} Returns the new wrapped function.
       */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
       * Creates a `_.range` or `_.rangeRight` function.
       *
       * @private
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new range function.
       */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined$1;}// Ensure the sign of `-0` is preserved.
  start=toFinite(start);if(end===undefined$1){end=start;start=0;}else {end=toFinite(end);}step=step===undefined$1?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
       * Creates a function that performs a relational operation on two values.
       *
       * @private
       * @param {Function} operator The function to perform the operation.
       * @returns {Function} Returns the new relational operation function.
       */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
       * Creates a function that wraps `func` to continue currying.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {Function} wrapFunc The function to create the `func` wrapper.
       * @param {*} placeholder The placeholder value.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param {Array} [partials] The arguments to prepend to those provided to
       *  the new function.
       * @param {Array} [holders] The `partials` placeholder indexes.
       * @param {Array} [argPos] The argument positions of the new function.
       * @param {number} [ary] The arity cap of `func`.
       * @param {number} [arity] The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined$1,newHoldersRight=isCurry?undefined$1:holders,newPartials=isCurry?partials:undefined$1,newPartialsRight=isCurry?undefined$1:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined$1,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
       * Creates a function like `_.round`.
       *
       * @private
       * @param {string} methodName The name of the `Math` method to use when rounding.
       * @returns {Function} Returns the new round function.
       */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision&&nativeIsFinite(number)){// Shift with exponential notation to avoid floating-point issues.
  // See [MDN](https://mdn.io/round#Examples) for more details.
  var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return +(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
       * Creates a set object of `values`.
       *
       * @private
       * @param {Array} values The values to add to the set.
       * @returns {Object} Returns the new set.
       */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
       * Creates a `_.toPairs` or `_.toPairsIn` function.
       *
       * @private
       * @param {Function} keysFunc The function to get the keys of a given object.
       * @returns {Function} Returns the new pairs function.
       */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
       * Creates a function that either curries or invokes `func` with optional
       * `this` binding and partially applied arguments.
       *
       * @private
       * @param {Function|string} func The function or method name to wrap.
       * @param {number} bitmask The bitmask flags.
       *    1 - `_.bind`
       *    2 - `_.bindKey`
       *    4 - `_.curry` or `_.curryRight` of a bound function
       *    8 - `_.curry`
       *   16 - `_.curryRight`
       *   32 - `_.partial`
       *   64 - `_.partialRight`
       *  128 - `_.rearg`
       *  256 - `_.ary`
       *  512 - `_.flip`
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param {Array} [partials] The arguments to be partially applied.
       * @param {Array} [holders] The `partials` placeholder indexes.
       * @param {Array} [argPos] The argument positions of the new function.
       * @param {number} [ary] The arity cap of `func`.
       * @param {number} [arity] The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined$1;}ary=ary===undefined$1?ary:nativeMax(toInteger(ary),0);arity=arity===undefined$1?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined$1;}var data=isBindKey?undefined$1:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined$1?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else {result=createHybrid.apply(undefined$1,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
       * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
       * of source objects to the destination object for all destination properties
       * that resolve to `undefined`.
       *
       * @private
       * @param {*} objValue The destination value.
       * @param {*} srcValue The source value.
       * @param {string} key The key of the property to assign.
       * @param {Object} object The parent object of `objValue`.
       * @returns {*} Returns the value to assign.
       */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined$1||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
       * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
       * objects into destination objects that are passed thru.
       *
       * @private
       * @param {*} objValue The destination value.
       * @param {*} srcValue The source value.
       * @param {string} key The key of the property to merge.
       * @param {Object} object The parent object of `objValue`.
       * @param {Object} source The parent object of `srcValue`.
       * @param {Object} [stack] Tracks traversed source values and their merged
       *  counterparts.
       * @returns {*} Returns the value to assign.
       */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
  stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined$1,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
       * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
       * objects.
       *
       * @private
       * @param {*} value The value to inspect.
       * @param {string} key The key of the property to inspect.
       * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
       */function customOmitClone(value){return isPlainObject(value)?undefined$1:value;}/**
       * A specialized version of `baseIsEqualDeep` for arrays with support for
       * partial deep comparisons.
       *
       * @private
       * @param {Array} array The array to compare.
       * @param {Array} other The other array to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} stack Tracks traversed `array` and `other` objects.
       * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
       */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Check that cyclic values are equal.
  var arrStacked=stack.get(array);var othStacked=stack.get(other);if(arrStacked&&othStacked){return arrStacked==other&&othStacked==array;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined$1;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
  while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined$1){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
  if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
       * A specialized version of `baseIsEqualDeep` for comparing objects of
       * the same `toStringTag`.
       *
       * **Note:** This function only supports comparing values with tags of
       * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {string} tag The `toStringTag` of the objects to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} stack Tracks traversed `object` and `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
  // Invalid dates are coerced to `NaN`.
  return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
  // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
  // for more details.
  return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
  var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
  stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
       * A specialized version of `baseIsEqualDeep` for objects with support for
       * partial deep comparisons.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} stack Tracks traversed `object` and `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Check that cyclic values are equal.
  var objStacked=stack.get(object);var othStacked=stack.get(other);if(objStacked&&othStacked){return objStacked==other&&othStacked==object;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
  if(!(compared===undefined$1?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
  if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
       * A specialized version of `baseRest` which flattens the rest array.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @returns {Function} Returns the new function.
       */function flatRest(func){return setToString(overRest(func,undefined$1,flatten),func+'');}/**
       * Creates an array of own enumerable property names and symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names and symbols.
       */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
       * Creates an array of own and inherited enumerable property names and
       * symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names and symbols.
       */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
       * Gets metadata for `func`.
       *
       * @private
       * @param {Function} func The function to query.
       * @returns {*} Returns the metadata for `func`.
       */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
       * Gets the name of `func`.
       *
       * @private
       * @param {Function} func The function to query.
       * @returns {string} Returns the function name.
       */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
       * Gets the argument placeholder value for `func`.
       *
       * @private
       * @param {Function} func The function to inspect.
       * @returns {*} Returns the placeholder value.
       */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
       * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
       * this function returns the custom method, otherwise it returns `baseIteratee`.
       * If arguments are provided, the chosen function is invoked with them and
       * its result is returned.
       *
       * @private
       * @param {*} [value] The value to convert to an iteratee.
       * @param {number} [arity] The arity of the created iteratee.
       * @returns {Function} Returns the chosen function or its result.
       */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
       * Gets the data for `map`.
       *
       * @private
       * @param {Object} map The map to query.
       * @param {string} key The reference key.
       * @returns {*} Returns the map data.
       */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
       * Gets the property names, values, and compare flags of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the match data of `object`.
       */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
       * Gets the native function at `key` of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {string} key The key of the method to get.
       * @returns {*} Returns the function if it's native, else `undefined`.
       */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined$1;}/**
       * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the raw `toStringTag`.
       */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined$1;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else {delete value[symToStringTag];}}return result;}/**
       * Creates an array of the own enumerable symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of symbols.
       */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return [];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
       * Creates an array of the own and inherited enumerable symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of symbols.
       */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
       * Gets the `toStringTag` of `value`.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function getTag(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined$1,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
       * Gets the view, applying any `transforms` to the `start` and `end` positions.
       *
       * @private
       * @param {number} start The start of the view.
       * @param {number} end The end of the view.
       * @param {Array} transforms The transformations to apply to the view.
       * @returns {Object} Returns an object containing the `start` and `end`
       *  positions of the view.
       */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return {'start':start,'end':end};}/**
       * Extracts wrapper details from the `source` body comment.
       *
       * @private
       * @param {string} source The source to inspect.
       * @returns {Array} Returns the wrapper details.
       */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
       * Checks if `path` exists on `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @param {Function} hasFunc The function to check properties.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return !!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
       * Initializes an array clone.
       *
       * @private
       * @param {Array} array The array to clone.
       * @returns {Array} Returns the initialized clone.
       */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
  if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
       * Initializes an object clone.
       *
       * @private
       * @param {Object} object The object to clone.
       * @returns {Object} Returns the initialized clone.
       */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
       * Initializes an object clone based on its `toStringTag`.
       *
       * **Note:** This function only supports cloning values with tags of
       * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
       *
       * @private
       * @param {Object} object The object to clone.
       * @param {string} tag The `toStringTag` of the object to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the initialized clone.
       */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
       * Inserts wrapper `details` in a comment at the top of the `source` body.
       *
       * @private
       * @param {string} source The source to modify.
       * @returns {Array} details The details to insert.
       * @returns {string} Returns the modified source.
       */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
       * Checks if `value` is a flattenable `arguments` object or array.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
       */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
       * Checks if `value` is a valid array-like index.
       *
       * @private
       * @param {*} value The value to check.
       * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
       * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
       */function isIndex(value,length){var type=_typeof(value);length=length==null?MAX_SAFE_INTEGER:length;return !!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
       * Checks if the given arguments are from an iteratee call.
       *
       * @private
       * @param {*} value The potential iteratee value argument.
       * @param {*} index The potential iteratee index or key argument.
       * @param {*} object The potential iteratee object argument.
       * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
       *  else `false`.
       */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=_typeof(index);if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
       * Checks if `value` is a property name and not a property path.
       *
       * @private
       * @param {*} value The value to check.
       * @param {Object} [object] The object to query keys on.
       * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
       */function isKey(value,object){if(isArray(value)){return false;}var type=_typeof(value);if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
       * Checks if `value` is suitable for use as unique object key.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
       */function isKeyable(value){var type=_typeof(value);return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
       * Checks if `func` has a lazy counterpart.
       *
       * @private
       * @param {Function} func The function to check.
       * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
       *  else `false`.
       */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return !!data&&func===data[0];}/**
       * Checks if `func` has its source masked.
       *
       * @private
       * @param {Function} func The function to check.
       * @returns {boolean} Returns `true` if `func` is masked, else `false`.
       */function isMasked(func){return !!maskSrcKey&&maskSrcKey in func;}/**
       * Checks if `func` is capable of being masked.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
       */var isMaskable=coreJsData?isFunction:stubFalse;/**
       * Checks if `value` is likely a prototype object.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
       */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
       * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` if suitable for strict
       *  equality comparisons, else `false`.
       */function isStrictComparable(value){return value===value&&!isObject(value);}/**
       * A specialized version of `matchesProperty` for source values suitable
       * for strict equality comparisons, i.e. `===`.
       *
       * @private
       * @param {string} key The key of the property to get.
       * @param {*} srcValue The value to match.
       * @returns {Function} Returns the new spec function.
       */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined$1||key in Object(object));};}/**
       * A specialized version of `_.memoize` which clears the memoized function's
       * cache when it exceeds `MAX_MEMOIZE_SIZE`.
       *
       * @private
       * @param {Function} func The function to have its output memoized.
       * @returns {Function} Returns the new memoized function.
       */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
       * Merges the function metadata of `source` into `data`.
       *
       * Merging metadata reduces the number of wrappers used to invoke a function.
       * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
       * may be applied regardless of execution order. Methods like `_.ary` and
       * `_.rearg` modify function arguments, making the order in which they are
       * executed important, preventing the merging of metadata. However, we make
       * an exception for a safe combined case where curried functions have `_.ary`
       * and or `_.rearg` applied.
       *
       * @private
       * @param {Array} data The destination metadata.
       * @param {Array} source The source metadata.
       * @returns {Array} Returns `data`.
       */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
  if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
  if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
  newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
  var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
  value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
  value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
  if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
  if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
  data[0]=source[0];data[1]=newBitmask;return data;}/**
       * This function is like
       * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
       * except that it includes inherited enumerable properties.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
       * Converts `value` to a string using `Object.prototype.toString`.
       *
       * @private
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       */function objectToString(value){return nativeObjectToString.call(value);}/**
       * A specialized version of `baseRest` which transforms the rest array.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @param {Function} transform The rest array transform.
       * @returns {Function} Returns the new function.
       */function overRest(func,start,transform){start=nativeMax(start===undefined$1?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
       * Gets the parent value at `path` of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} path The path to get the parent value of.
       * @returns {*} Returns the parent value.
       */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
       * Reorder `array` according to the specified indexes where the element at
       * the first index is assigned as the first element, the element at
       * the second index is assigned as the second element, and so on.
       *
       * @private
       * @param {Array} array The array to reorder.
       * @param {Array} indexes The arranged array indexes.
       * @returns {Array} Returns `array`.
       */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined$1;}return array;}/**
       * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
       *
       * @private
       * @param {Object} object The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
       * Sets metadata for `func`.
       *
       * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
       * period of time, it will trip its breaker and transition to an identity
       * function to avoid garbage collection pauses in V8. See
       * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
       * for more details.
       *
       * @private
       * @param {Function} func The function to associate metadata with.
       * @param {*} data The metadata.
       * @returns {Function} Returns `func`.
       */var setData=shortOut(baseSetData);/**
       * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
       *
       * @private
       * @param {Function} func The function to delay.
       * @param {number} wait The number of milliseconds to delay invocation.
       * @returns {number|Object} Returns the timer id or timeout object.
       */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
       * Sets the `toString` method of `func` to return `string`.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */var setToString=shortOut(baseSetToString);/**
       * Sets the `toString` method of `wrapper` to mimic the source of `reference`
       * with wrapper details in a comment at the top of the source body.
       *
       * @private
       * @param {Function} wrapper The function to modify.
       * @param {Function} reference The reference function.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @returns {Function} Returns `wrapper`.
       */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
       * Creates a function that'll short out and invoke `identity` instead
       * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
       * milliseconds.
       *
       * @private
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new shortable function.
       */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else {count=0;}return func.apply(undefined$1,arguments);};}/**
       * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
       *
       * @private
       * @param {Array} array The array to shuffle.
       * @param {number} [size=array.length] The size of `array`.
       * @returns {Array} Returns `array`.
       */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined$1?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
       * Converts `string` to a property path array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the property path array.
       */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
       * Converts `value` to a string key if it's not a string or symbol.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {string|symbol} Returns the key.
       */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
       * Converts `func` to its source code.
       *
       * @private
       * @param {Function} func The function to convert.
       * @returns {string} Returns the source code.
       */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return '';}/**
       * Updates wrapper `details` based on `bitmask` flags.
       *
       * @private
       * @returns {Array} details The details to modify.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @returns {Array} Returns `details`.
       */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
       * Creates a clone of `wrapper`.
       *
       * @private
       * @param {Object} wrapper The wrapper to clone.
       * @returns {Object} Returns the cloned wrapper.
       */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*/ /**
       * Creates an array of elements split into groups the length of `size`.
       * If `array` can't be split evenly, the final chunk will be the remaining
       * elements.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to process.
       * @param {number} [size=1] The length of each chunk
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the new array of chunks.
       * @example
       *
       * _.chunk(['a', 'b', 'c', 'd'], 2);
       * // => [['a', 'b'], ['c', 'd']]
       *
       * _.chunk(['a', 'b', 'c', 'd'], 3);
       * // => [['a', 'b', 'c'], ['d']]
       */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined$1){size=1;}else {size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return [];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
       * Creates an array with all falsey values removed. The values `false`, `null`,
       * `0`, `""`, `undefined`, and `NaN` are falsey.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to compact.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * _.compact([0, 1, false, 2, '', 3]);
       * // => [1, 2, 3]
       */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
       * Creates a new array concatenating `array` with any additional arrays
       * and/or values.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to concatenate.
       * @param {...*} [values] The values to concatenate.
       * @returns {Array} Returns the new concatenated array.
       * @example
       *
       * var array = [1];
       * var other = _.concat(array, 2, [3], [[4]]);
       *
       * console.log(other);
       * // => [1, 2, 3, [4]]
       *
       * console.log(array);
       * // => [1]
       */function concat(){var length=arguments.length;if(!length){return [];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
       * Creates an array of `array` values not included in the other given arrays
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons. The order and references of result values are
       * determined by the first array.
       *
       * **Note:** Unlike `_.pullAll`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...Array} [values] The values to exclude.
       * @returns {Array} Returns the new array of filtered values.
       * @see _.without, _.xor
       * @example
       *
       * _.difference([2, 1], [2, 3]);
       * // => [1]
       */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
       * This method is like `_.difference` except that it accepts `iteratee` which
       * is invoked for each element of `array` and `values` to generate the criterion
       * by which they're compared. The order and references of result values are
       * determined by the first array. The iteratee is invoked with one argument:
       * (value).
       *
       * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...Array} [values] The values to exclude.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
       * // => [1.2]
       *
       * // The `_.property` iteratee shorthand.
       * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
       * // => [{ 'x': 2 }]
       */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
       * This method is like `_.difference` except that it accepts `comparator`
       * which is invoked to compare elements of `array` to `values`. The order and
       * references of result values are determined by the first array. The comparator
       * is invoked with two arguments: (arrVal, othVal).
       *
       * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...Array} [values] The values to exclude.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       *
       * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
       * // => [{ 'x': 2, 'y': 1 }]
       */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined$1;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined$1,comparator):[];});/**
       * Creates a slice of `array` with `n` elements dropped from the beginning.
       *
       * @static
       * @memberOf _
       * @since 0.5.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to drop.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.drop([1, 2, 3]);
       * // => [2, 3]
       *
       * _.drop([1, 2, 3], 2);
       * // => [3]
       *
       * _.drop([1, 2, 3], 5);
       * // => []
       *
       * _.drop([1, 2, 3], 0);
       * // => [1, 2, 3]
       */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
       * Creates a slice of `array` with `n` elements dropped from the end.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to drop.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.dropRight([1, 2, 3]);
       * // => [1, 2]
       *
       * _.dropRight([1, 2, 3], 2);
       * // => [1]
       *
       * _.dropRight([1, 2, 3], 5);
       * // => []
       *
       * _.dropRight([1, 2, 3], 0);
       * // => [1, 2, 3]
       */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
       * Creates a slice of `array` excluding elements dropped from the end.
       * Elements are dropped until `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': true },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': false }
       * ];
       *
       * _.dropRightWhile(users, function(o) { return !o.active; });
       * // => objects for ['barney']
       *
       * // The `_.matches` iteratee shorthand.
       * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
       * // => objects for ['barney', 'fred']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.dropRightWhile(users, ['active', false]);
       * // => objects for ['barney']
       *
       * // The `_.property` iteratee shorthand.
       * _.dropRightWhile(users, 'active');
       * // => objects for ['barney', 'fred', 'pebbles']
       */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
       * Creates a slice of `array` excluding elements dropped from the beginning.
       * Elements are dropped until `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * _.dropWhile(users, function(o) { return !o.active; });
       * // => objects for ['pebbles']
       *
       * // The `_.matches` iteratee shorthand.
       * _.dropWhile(users, { 'user': 'barney', 'active': false });
       * // => objects for ['fred', 'pebbles']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.dropWhile(users, ['active', false]);
       * // => objects for ['pebbles']
       *
       * // The `_.property` iteratee shorthand.
       * _.dropWhile(users, 'active');
       * // => objects for ['barney', 'fred', 'pebbles']
       */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
       * Fills elements of `array` with `value` from `start` up to, but not
       * including, `end`.
       *
       * **Note:** This method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 3.2.0
       * @category Array
       * @param {Array} array The array to fill.
       * @param {*} value The value to fill `array` with.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [1, 2, 3];
       *
       * _.fill(array, 'a');
       * console.log(array);
       * // => ['a', 'a', 'a']
       *
       * _.fill(Array(3), 2);
       * // => [2, 2, 2]
       *
       * _.fill([4, 6, 8, 10], '*', 1, 3);
       * // => [4, '*', '*', 10]
       */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return [];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
       * This method is like `_.find` except that it returns the index of the first
       * element `predicate` returns truthy for instead of the element itself.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=0] The index to search from.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * _.findIndex(users, function(o) { return o.user == 'barney'; });
       * // => 0
       *
       * // The `_.matches` iteratee shorthand.
       * _.findIndex(users, { 'user': 'fred', 'active': false });
       * // => 1
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findIndex(users, ['active', false]);
       * // => 0
       *
       * // The `_.property` iteratee shorthand.
       * _.findIndex(users, 'active');
       * // => 2
       */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
       * This method is like `_.findIndex` except that it iterates over elements
       * of `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=array.length-1] The index to search from.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': true },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': false }
       * ];
       *
       * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
       * // => 2
       *
       * // The `_.matches` iteratee shorthand.
       * _.findLastIndex(users, { 'user': 'barney', 'active': true });
       * // => 0
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findLastIndex(users, ['active', false]);
       * // => 2
       *
       * // The `_.property` iteratee shorthand.
       * _.findLastIndex(users, 'active');
       * // => 0
       */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=length-1;if(fromIndex!==undefined$1){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
       * Flattens `array` a single level deep.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to flatten.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * _.flatten([1, [2, [3, [4]], 5]]);
       * // => [1, 2, [3, [4]], 5]
       */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
       * Recursively flattens `array`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to flatten.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * _.flattenDeep([1, [2, [3, [4]], 5]]);
       * // => [1, 2, 3, 4, 5]
       */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
       * Recursively flatten `array` up to `depth` times.
       *
       * @static
       * @memberOf _
       * @since 4.4.0
       * @category Array
       * @param {Array} array The array to flatten.
       * @param {number} [depth=1] The maximum recursion depth.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * var array = [1, [2, [3, [4]], 5]];
       *
       * _.flattenDepth(array, 1);
       * // => [1, 2, [3, [4]], 5]
       *
       * _.flattenDepth(array, 2);
       * // => [1, 2, 3, [4], 5]
       */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return [];}depth=depth===undefined$1?1:toInteger(depth);return baseFlatten(array,depth);}/**
       * The inverse of `_.toPairs`; this method returns an object composed
       * from key-value `pairs`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} pairs The key-value pairs.
       * @returns {Object} Returns the new object.
       * @example
       *
       * _.fromPairs([['a', 1], ['b', 2]]);
       * // => { 'a': 1, 'b': 2 }
       */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
       * Gets the first element of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @alias first
       * @category Array
       * @param {Array} array The array to query.
       * @returns {*} Returns the first element of `array`.
       * @example
       *
       * _.head([1, 2, 3]);
       * // => 1
       *
       * _.head([]);
       * // => undefined
       */function head(array){return array&&array.length?array[0]:undefined$1;}/**
       * Gets the index at which the first occurrence of `value` is found in `array`
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons. If `fromIndex` is negative, it's used as the
       * offset from the end of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} [fromIndex=0] The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.indexOf([1, 2, 1, 2], 2);
       * // => 1
       *
       * // Search from the `fromIndex`.
       * _.indexOf([1, 2, 1, 2], 2, 2);
       * // => 3
       */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
       * Gets all but the last element of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to query.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.initial([1, 2, 3]);
       * // => [1, 2]
       */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
       * Creates an array of unique values that are included in all given arrays
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons. The order and references of result values are
       * determined by the first array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of intersecting values.
       * @example
       *
       * _.intersection([2, 1], [2, 3]);
       * // => [2]
       */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
       * This method is like `_.intersection` except that it accepts `iteratee`
       * which is invoked for each element of each `arrays` to generate the criterion
       * by which they're compared. The order and references of result values are
       * determined by the first array. The iteratee is invoked with one argument:
       * (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of intersecting values.
       * @example
       *
       * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
       * // => [2.1]
       *
       * // The `_.property` iteratee shorthand.
       * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 1 }]
       */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined$1;}else {mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
       * This method is like `_.intersection` except that it accepts `comparator`
       * which is invoked to compare elements of `arrays`. The order and references
       * of result values are determined by the first array. The comparator is
       * invoked with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of intersecting values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.intersectionWith(objects, others, _.isEqual);
       * // => [{ 'x': 1, 'y': 2 }]
       */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined$1;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined$1,comparator):[];});/**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
       * Gets the last element of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to query.
       * @returns {*} Returns the last element of `array`.
       * @example
       *
       * _.last([1, 2, 3]);
       * // => 3
       */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined$1;}/**
       * This method is like `_.indexOf` except that it iterates over elements of
       * `array` from right to left.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} [fromIndex=array.length-1] The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.lastIndexOf([1, 2, 1, 2], 2);
       * // => 3
       *
       * // Search from the `fromIndex`.
       * _.lastIndexOf([1, 2, 1, 2], 2, 2);
       * // => 1
       */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=length;if(fromIndex!==undefined$1){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
       * Gets the element at index `n` of `array`. If `n` is negative, the nth
       * element from the end is returned.
       *
       * @static
       * @memberOf _
       * @since 4.11.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=0] The index of the element to return.
       * @returns {*} Returns the nth element of `array`.
       * @example
       *
       * var array = ['a', 'b', 'c', 'd'];
       *
       * _.nth(array, 1);
       * // => 'b'
       *
       * _.nth(array, -2);
       * // => 'c';
       */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined$1;}/**
       * Removes all given values from `array` using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
       * to remove elements from an array by predicate.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {...*} [values] The values to remove.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
       *
       * _.pull(array, 'a', 'c');
       * console.log(array);
       * // => ['b', 'b']
       */var pull=baseRest(pullAll);/**
       * This method is like `_.pull` except that it accepts an array of values to remove.
       *
       * **Note:** Unlike `_.difference`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
       *
       * _.pullAll(array, ['a', 'c']);
       * console.log(array);
       * // => ['b', 'b']
       */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
       * This method is like `_.pullAll` except that it accepts `iteratee` which is
       * invoked for each element of `array` and `values` to generate the criterion
       * by which they're compared. The iteratee is invoked with one argument: (value).
       *
       * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
       *
       * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
       * console.log(array);
       * // => [{ 'x': 2 }]
       */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
       * This method is like `_.pullAll` except that it accepts `comparator` which
       * is invoked to compare elements of `array` to `values`. The comparator is
       * invoked with two arguments: (arrVal, othVal).
       *
       * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 4.6.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
       *
       * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
       * console.log(array);
       * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
       */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined$1,comparator):array;}/**
       * Removes elements from `array` corresponding to `indexes` and returns an
       * array of removed elements.
       *
       * **Note:** Unlike `_.at`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {...(number|number[])} [indexes] The indexes of elements to remove.
       * @returns {Array} Returns the new array of removed elements.
       * @example
       *
       * var array = ['a', 'b', 'c', 'd'];
       * var pulled = _.pullAt(array, [1, 3]);
       *
       * console.log(array);
       * // => ['a', 'c']
       *
       * console.log(pulled);
       * // => ['b', 'd']
       */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
       * Removes all elements from `array` that `predicate` returns truthy for
       * and returns an array of the removed elements. The predicate is invoked
       * with three arguments: (value, index, array).
       *
       * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
       * to pull elements from an array by value.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new array of removed elements.
       * @example
       *
       * var array = [1, 2, 3, 4];
       * var evens = _.remove(array, function(n) {
       *   return n % 2 == 0;
       * });
       *
       * console.log(array);
       * // => [1, 3]
       *
       * console.log(evens);
       * // => [2, 4]
       */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
       * Reverses `array` so that the first element becomes the last, the second
       * element becomes the second to last, and so on.
       *
       * **Note:** This method mutates `array` and is based on
       * [`Array#reverse`](https://mdn.io/Array/reverse).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [1, 2, 3];
       *
       * _.reverse(array);
       * // => [3, 2, 1]
       *
       * console.log(array);
       * // => [3, 2, 1]
       */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
       * Creates a slice of `array` from `start` up to, but not including, `end`.
       *
       * **Note:** This method is used instead of
       * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
       * returned.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to slice.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns the slice of `array`.
       */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return [];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else {start=start==null?0:toInteger(start);end=end===undefined$1?length:toInteger(end);}return baseSlice(array,start,end);}/**
       * Uses a binary search to determine the lowest index at which `value`
       * should be inserted into `array` in order to maintain its sort order.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * _.sortedIndex([30, 50], 40);
       * // => 1
       */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
       * This method is like `_.sortedIndex` except that it accepts `iteratee`
       * which is invoked for `value` and each element of `array` to compute their
       * sort ranking. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * var objects = [{ 'x': 4 }, { 'x': 5 }];
       *
       * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
       * // => 0
       *
       * // The `_.property` iteratee shorthand.
       * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
       * // => 0
       */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
       * This method is like `_.indexOf` except that it performs a binary
       * search on a sorted `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
       * // => 1
       */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return -1;}/**
       * This method is like `_.sortedIndex` except that it returns the highest
       * index at which `value` should be inserted into `array` in order to
       * maintain its sort order.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
       * // => 4
       */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
       * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
       * which is invoked for `value` and each element of `array` to compute their
       * sort ranking. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * var objects = [{ 'x': 4 }, { 'x': 5 }];
       *
       * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
       * // => 1
       *
       * // The `_.property` iteratee shorthand.
       * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
       * // => 1
       */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
       * This method is like `_.lastIndexOf` except that it performs a binary
       * search on a sorted `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
       * // => 3
       */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return -1;}/**
       * This method is like `_.uniq` except that it's designed and optimized
       * for sorted arrays.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.sortedUniq([1, 1, 2]);
       * // => [1, 2]
       */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
       * This method is like `_.uniqBy` except that it's designed and optimized
       * for sorted arrays.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
       * // => [1.1, 2.3]
       */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
       * Gets all but the first element of `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.tail([1, 2, 3]);
       * // => [2, 3]
       */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
       * Creates a slice of `array` with `n` elements taken from the beginning.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to take.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.take([1, 2, 3]);
       * // => [1]
       *
       * _.take([1, 2, 3], 2);
       * // => [1, 2]
       *
       * _.take([1, 2, 3], 5);
       * // => [1, 2, 3]
       *
       * _.take([1, 2, 3], 0);
       * // => []
       */function take(array,n,guard){if(!(array&&array.length)){return [];}n=guard||n===undefined$1?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
       * Creates a slice of `array` with `n` elements taken from the end.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to take.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.takeRight([1, 2, 3]);
       * // => [3]
       *
       * _.takeRight([1, 2, 3], 2);
       * // => [2, 3]
       *
       * _.takeRight([1, 2, 3], 5);
       * // => [1, 2, 3]
       *
       * _.takeRight([1, 2, 3], 0);
       * // => []
       */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
       * Creates a slice of `array` with elements taken from the end. Elements are
       * taken until `predicate` returns falsey. The predicate is invoked with
       * three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': true },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': false }
       * ];
       *
       * _.takeRightWhile(users, function(o) { return !o.active; });
       * // => objects for ['fred', 'pebbles']
       *
       * // The `_.matches` iteratee shorthand.
       * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
       * // => objects for ['pebbles']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.takeRightWhile(users, ['active', false]);
       * // => objects for ['fred', 'pebbles']
       *
       * // The `_.property` iteratee shorthand.
       * _.takeRightWhile(users, 'active');
       * // => []
       */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
       * Creates a slice of `array` with elements taken from the beginning. Elements
       * are taken until `predicate` returns falsey. The predicate is invoked with
       * three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * _.takeWhile(users, function(o) { return !o.active; });
       * // => objects for ['barney', 'fred']
       *
       * // The `_.matches` iteratee shorthand.
       * _.takeWhile(users, { 'user': 'barney', 'active': false });
       * // => objects for ['barney']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.takeWhile(users, ['active', false]);
       * // => objects for ['barney', 'fred']
       *
       * // The `_.property` iteratee shorthand.
       * _.takeWhile(users, 'active');
       * // => []
       */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
       * Creates an array of unique values, in order, from all given arrays using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of combined values.
       * @example
       *
       * _.union([2], [1, 2]);
       * // => [2, 1]
       */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
       * This method is like `_.union` except that it accepts `iteratee` which is
       * invoked for each element of each `arrays` to generate the criterion by
       * which uniqueness is computed. Result values are chosen from the first
       * array in which the value occurs. The iteratee is invoked with one argument:
       * (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of combined values.
       * @example
       *
       * _.unionBy([2.1], [1.2, 2.3], Math.floor);
       * // => [2.1, 1.2]
       *
       * // The `_.property` iteratee shorthand.
       * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 1 }, { 'x': 2 }]
       */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
       * This method is like `_.union` except that it accepts `comparator` which
       * is invoked to compare elements of `arrays`. Result values are chosen from
       * the first array in which the value occurs. The comparator is invoked
       * with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of combined values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.unionWith(objects, others, _.isEqual);
       * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
       */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined$1;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined$1,comparator);});/**
       * Creates a duplicate-free version of an array, using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons, in which only the first occurrence of each element
       * is kept. The order of result values is determined by the order they occur
       * in the array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.uniq([2, 1, 2]);
       * // => [2, 1]
       */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
       * This method is like `_.uniq` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the criterion by which
       * uniqueness is computed. The order of result values is determined by the
       * order they occur in the array. The iteratee is invoked with one argument:
       * (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
       * // => [2.1, 1.2]
       *
       * // The `_.property` iteratee shorthand.
       * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 1 }, { 'x': 2 }]
       */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
       * This method is like `_.uniq` except that it accepts `comparator` which
       * is invoked to compare elements of `array`. The order of result values is
       * determined by the order they occur in the array.The comparator is invoked
       * with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.uniqWith(objects, _.isEqual);
       * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
       */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined$1;return array&&array.length?baseUniq(array,undefined$1,comparator):[];}/**
       * This method is like `_.zip` except that it accepts an array of grouped
       * elements and creates an array regrouping the elements to their pre-zip
       * configuration.
       *
       * @static
       * @memberOf _
       * @since 1.2.0
       * @category Array
       * @param {Array} array The array of grouped elements to process.
       * @returns {Array} Returns the new array of regrouped elements.
       * @example
       *
       * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
       * // => [['a', 1, true], ['b', 2, false]]
       *
       * _.unzip(zipped);
       * // => [['a', 'b'], [1, 2], [true, false]]
       */function unzip(array){if(!(array&&array.length)){return [];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
       * This method is like `_.unzip` except that it accepts `iteratee` to specify
       * how regrouped values should be combined. The iteratee is invoked with the
       * elements of each group: (...group).
       *
       * @static
       * @memberOf _
       * @since 3.8.0
       * @category Array
       * @param {Array} array The array of grouped elements to process.
       * @param {Function} [iteratee=_.identity] The function to combine
       *  regrouped values.
       * @returns {Array} Returns the new array of regrouped elements.
       * @example
       *
       * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
       * // => [[1, 10, 100], [2, 20, 200]]
       *
       * _.unzipWith(zipped, _.add);
       * // => [3, 30, 300]
       */function unzipWith(array,iteratee){if(!(array&&array.length)){return [];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined$1,group);});}/**
       * Creates an array excluding all given values using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * **Note:** Unlike `_.pull`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...*} [values] The values to exclude.
       * @returns {Array} Returns the new array of filtered values.
       * @see _.difference, _.xor
       * @example
       *
       * _.without([2, 1, 2, 3], 1, 2);
       * // => [3]
       */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
       * Creates an array of unique values that is the
       * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
       * of the given arrays. The order of result values is determined by the order
       * they occur in the arrays.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of filtered values.
       * @see _.difference, _.without
       * @example
       *
       * _.xor([2, 1], [2, 3]);
       * // => [1, 3]
       */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
       * This method is like `_.xor` except that it accepts `iteratee` which is
       * invoked for each element of each `arrays` to generate the criterion by
       * which by which they're compared. The order of result values is determined
       * by the order they occur in the arrays. The iteratee is invoked with one
       * argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
       * // => [1.2, 3.4]
       *
       * // The `_.property` iteratee shorthand.
       * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 2 }]
       */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
       * This method is like `_.xor` except that it accepts `comparator` which is
       * invoked to compare elements of `arrays`. The order of result values is
       * determined by the order they occur in the arrays. The comparator is invoked
       * with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.xorWith(objects, others, _.isEqual);
       * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
       */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined$1;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined$1,comparator);});/**
       * Creates an array of grouped elements, the first of which contains the
       * first elements of the given arrays, the second of which contains the
       * second elements of the given arrays, and so on.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {...Array} [arrays] The arrays to process.
       * @returns {Array} Returns the new array of grouped elements.
       * @example
       *
       * _.zip(['a', 'b'], [1, 2], [true, false]);
       * // => [['a', 1, true], ['b', 2, false]]
       */var zip=baseRest(unzip);/**
       * This method is like `_.fromPairs` except that it accepts two arrays,
       * one of property identifiers and one of corresponding values.
       *
       * @static
       * @memberOf _
       * @since 0.4.0
       * @category Array
       * @param {Array} [props=[]] The property identifiers.
       * @param {Array} [values=[]] The property values.
       * @returns {Object} Returns the new object.
       * @example
       *
       * _.zipObject(['a', 'b'], [1, 2]);
       * // => { 'a': 1, 'b': 2 }
       */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
       * This method is like `_.zipObject` except that it supports property paths.
       *
       * @static
       * @memberOf _
       * @since 4.1.0
       * @category Array
       * @param {Array} [props=[]] The property identifiers.
       * @param {Array} [values=[]] The property values.
       * @returns {Object} Returns the new object.
       * @example
       *
       * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
       * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
       */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
       * This method is like `_.zip` except that it accepts `iteratee` to specify
       * how grouped values should be combined. The iteratee is invoked with the
       * elements of each group: (...group).
       *
       * @static
       * @memberOf _
       * @since 3.8.0
       * @category Array
       * @param {...Array} [arrays] The arrays to process.
       * @param {Function} [iteratee=_.identity] The function to combine
       *  grouped values.
       * @returns {Array} Returns the new array of grouped elements.
       * @example
       *
       * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
       *   return a + b + c;
       * });
       * // => [111, 222]
       */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined$1;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined$1;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*/ /**
       * Creates a `lodash` wrapper instance that wraps `value` with explicit method
       * chain sequences enabled. The result of such sequences must be unwrapped
       * with `_#value`.
       *
       * @static
       * @memberOf _
       * @since 1.3.0
       * @category Seq
       * @param {*} value The value to wrap.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36 },
       *   { 'user': 'fred',    'age': 40 },
       *   { 'user': 'pebbles', 'age': 1 }
       * ];
       *
       * var youngest = _
       *   .chain(users)
       *   .sortBy('age')
       *   .map(function(o) {
       *     return o.user + ' is ' + o.age;
       *   })
       *   .head()
       *   .value();
       * // => 'pebbles is 1'
       */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
       * This method invokes `interceptor` and returns `value`. The interceptor
       * is invoked with one argument; (value). The purpose of this method is to
       * "tap into" a method chain sequence in order to modify intermediate results.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Seq
       * @param {*} value The value to provide to `interceptor`.
       * @param {Function} interceptor The function to invoke.
       * @returns {*} Returns `value`.
       * @example
       *
       * _([1, 2, 3])
       *  .tap(function(array) {
       *    // Mutate input array.
       *    array.pop();
       *  })
       *  .reverse()
       *  .value();
       * // => [2, 1]
       */function tap(value,interceptor){interceptor(value);return value;}/**
       * This method is like `_.tap` except that it returns the result of `interceptor`.
       * The purpose of this method is to "pass thru" values replacing intermediate
       * results in a method chain sequence.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Seq
       * @param {*} value The value to provide to `interceptor`.
       * @param {Function} interceptor The function to invoke.
       * @returns {*} Returns the result of `interceptor`.
       * @example
       *
       * _('  abc  ')
       *  .chain()
       *  .trim()
       *  .thru(function(value) {
       *    return [value];
       *  })
       *  .value();
       * // => ['abc']
       */function thru(value,interceptor){return interceptor(value);}/**
       * This method is the wrapper version of `_.at`.
       *
       * @name at
       * @memberOf _
       * @since 1.0.0
       * @category Seq
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
       *
       * _(object).at(['a[0].b.c', 'a[1]']).value();
       * // => [3, 4]
       */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function interceptor(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined$1});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined$1);}return array;});});/**
       * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
       *
       * @name chain
       * @memberOf _
       * @since 0.1.0
       * @category Seq
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36 },
       *   { 'user': 'fred',   'age': 40 }
       * ];
       *
       * // A sequence without explicit chaining.
       * _(users).head();
       * // => { 'user': 'barney', 'age': 36 }
       *
       * // A sequence with explicit chaining.
       * _(users)
       *   .chain()
       *   .head()
       *   .pick('user')
       *   .value();
       * // => { 'user': 'barney' }
       */function wrapperChain(){return chain(this);}/**
       * Executes the chain sequence and returns the wrapped result.
       *
       * @name commit
       * @memberOf _
       * @since 3.2.0
       * @category Seq
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var array = [1, 2];
       * var wrapped = _(array).push(3);
       *
       * console.log(array);
       * // => [1, 2]
       *
       * wrapped = wrapped.commit();
       * console.log(array);
       * // => [1, 2, 3]
       *
       * wrapped.last();
       * // => 3
       *
       * console.log(array);
       * // => [1, 2, 3]
       */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
       * Gets the next value on a wrapped object following the
       * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
       *
       * @name next
       * @memberOf _
       * @since 4.0.0
       * @category Seq
       * @returns {Object} Returns the next iterator value.
       * @example
       *
       * var wrapped = _([1, 2]);
       *
       * wrapped.next();
       * // => { 'done': false, 'value': 1 }
       *
       * wrapped.next();
       * // => { 'done': false, 'value': 2 }
       *
       * wrapped.next();
       * // => { 'done': true, 'value': undefined }
       */function wrapperNext(){if(this.__values__===undefined$1){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined$1:this.__values__[this.__index__++];return {'done':done,'value':value};}/**
       * Enables the wrapper to be iterable.
       *
       * @name Symbol.iterator
       * @memberOf _
       * @since 4.0.0
       * @category Seq
       * @returns {Object} Returns the wrapper object.
       * @example
       *
       * var wrapped = _([1, 2]);
       *
       * wrapped[Symbol.iterator]() === wrapped;
       * // => true
       *
       * Array.from(wrapped);
       * // => [1, 2]
       */function wrapperToIterator(){return this;}/**
       * Creates a clone of the chain sequence planting `value` as the wrapped value.
       *
       * @name plant
       * @memberOf _
       * @since 3.2.0
       * @category Seq
       * @param {*} value The value to plant.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var wrapped = _([1, 2]).map(square);
       * var other = wrapped.plant([3, 4]);
       *
       * other.value();
       * // => [9, 16]
       *
       * wrapped.value();
       * // => [1, 4]
       */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined$1;if(result){previous.__wrapped__=clone;}else {result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
       * This method is the wrapper version of `_.reverse`.
       *
       * **Note:** This method mutates the wrapped array.
       *
       * @name reverse
       * @memberOf _
       * @since 0.1.0
       * @category Seq
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var array = [1, 2, 3];
       *
       * _(array).reverse().value()
       * // => [3, 2, 1]
       *
       * console.log(array);
       * // => [3, 2, 1]
       */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined$1});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
       * Executes the chain sequence to resolve the unwrapped value.
       *
       * @name value
       * @memberOf _
       * @since 0.1.0
       * @alias toJSON, valueOf
       * @category Seq
       * @returns {*} Returns the resolved unwrapped value.
       * @example
       *
       * _([1, 2, 3]).value();
       * // => [1, 2, 3]
       */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*/ /**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` thru `iteratee`. The corresponding value of
       * each key is the number of times the key was returned by `iteratee`. The
       * iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 0.5.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * _.countBy([6.1, 4.2, 6.3], Math.floor);
       * // => { '4': 1, '6': 2 }
       *
       * // The `_.property` iteratee shorthand.
       * _.countBy(['one', 'two', 'three'], 'length');
       * // => { '3': 2, '5': 1 }
       */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else {baseAssignValue(result,key,1);}});/**
       * Checks if `predicate` returns truthy for **all** elements of `collection`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index|key, collection).
       *
       * **Note:** This method returns `true` for
       * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
       * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
       * elements of empty collections.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * _.every([true, 1, null, 'yes'], Boolean);
       * // => false
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': false },
       *   { 'user': 'fred',   'age': 40, 'active': false }
       * ];
       *
       * // The `_.matches` iteratee shorthand.
       * _.every(users, { 'user': 'barney', 'active': false });
       * // => false
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.every(users, ['active', false]);
       * // => true
       *
       * // The `_.property` iteratee shorthand.
       * _.every(users, 'active');
       * // => false
       */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined$1;}return func(collection,getIteratee(predicate,3));}/**
       * Iterates over elements of `collection`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index|key, collection).
       *
       * **Note:** Unlike `_.remove`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @see _.reject
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': true },
       *   { 'user': 'fred',   'age': 40, 'active': false }
       * ];
       *
       * _.filter(users, function(o) { return !o.active; });
       * // => objects for ['fred']
       *
       * // The `_.matches` iteratee shorthand.
       * _.filter(users, { 'age': 36, 'active': true });
       * // => objects for ['barney']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.filter(users, ['active', false]);
       * // => objects for ['fred']
       *
       * // The `_.property` iteratee shorthand.
       * _.filter(users, 'active');
       * // => objects for ['barney']
       *
       * // Combining several predicates using `_.overEvery` or `_.overSome`.
       * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
       * // => objects for ['fred', 'barney']
       */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
       * Iterates over elements of `collection`, returning the first element
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index|key, collection).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=0] The index to search from.
       * @returns {*} Returns the matched element, else `undefined`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36, 'active': true },
       *   { 'user': 'fred',    'age': 40, 'active': false },
       *   { 'user': 'pebbles', 'age': 1,  'active': true }
       * ];
       *
       * _.find(users, function(o) { return o.age < 40; });
       * // => object for 'barney'
       *
       * // The `_.matches` iteratee shorthand.
       * _.find(users, { 'age': 1, 'active': true });
       * // => object for 'pebbles'
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.find(users, ['active', false]);
       * // => object for 'fred'
       *
       * // The `_.property` iteratee shorthand.
       * _.find(users, 'active');
       * // => object for 'barney'
       */var find=createFind(findIndex);/**
       * This method is like `_.find` except that it iterates over elements of
       * `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=collection.length-1] The index to search from.
       * @returns {*} Returns the matched element, else `undefined`.
       * @example
       *
       * _.findLast([1, 2, 3, 4], function(n) {
       *   return n % 2 == 1;
       * });
       * // => 3
       */var findLast=createFind(findLastIndex);/**
       * Creates a flattened array of values by running each element in `collection`
       * thru `iteratee` and flattening the mapped results. The iteratee is invoked
       * with three arguments: (value, index|key, collection).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * function duplicate(n) {
       *   return [n, n];
       * }
       *
       * _.flatMap([1, 2], duplicate);
       * // => [1, 1, 2, 2]
       */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
       * This method is like `_.flatMap` except that it recursively flattens the
       * mapped results.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * function duplicate(n) {
       *   return [[[n, n]]];
       * }
       *
       * _.flatMapDeep([1, 2], duplicate);
       * // => [1, 1, 2, 2]
       */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
       * This method is like `_.flatMap` except that it recursively flattens the
       * mapped results up to `depth` times.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {number} [depth=1] The maximum recursion depth.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * function duplicate(n) {
       *   return [[[n, n]]];
       * }
       *
       * _.flatMapDepth([1, 2], duplicate, 2);
       * // => [[1, 1], [2, 2]]
       */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined$1?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       * Iteratee functions may exit iteration early by explicitly returning `false`.
       *
       * **Note:** As with other "Collections" methods, objects with a "length"
       * property are iterated like arrays. To avoid this behavior use `_.forIn`
       * or `_.forOwn` for object iteration.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @alias each
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @see _.forEachRight
       * @example
       *
       * _.forEach([1, 2], function(value) {
       *   console.log(value);
       * });
       * // => Logs `1` then `2`.
       *
       * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'a' then 'b' (iteration order is not guaranteed).
       */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
       * This method is like `_.forEach` except that it iterates over elements of
       * `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @alias eachRight
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @see _.forEach
       * @example
       *
       * _.forEachRight([1, 2], function(value) {
       *   console.log(value);
       * });
       * // => Logs `2` then `1`.
       */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` thru `iteratee`. The order of grouped values
       * is determined by the order they occur in `collection`. The corresponding
       * value of each key is an array of elements responsible for generating the
       * key. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * _.groupBy([6.1, 4.2, 6.3], Math.floor);
       * // => { '4': [4.2], '6': [6.1, 6.3] }
       *
       * // The `_.property` iteratee shorthand.
       * _.groupBy(['one', 'two', 'three'], 'length');
       * // => { '3': ['one', 'two'], '5': ['three'] }
       */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else {baseAssignValue(result,key,[value]);}});/**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * is used for equality comparisons. If `fromIndex` is negative, it's used as
       * the offset from the end of `collection`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @param {number} [fromIndex=0] The index to search from.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes([1, 2, 3], 1, 2);
       * // => false
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
       * Invokes the method at `path` of each element in `collection`, returning
       * an array of the results of each invoked method. Any additional arguments
       * are provided to each invoked method. If `path` is a function, it's invoked
       * for, and `this` bound to, each element in `collection`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Array|Function|string} path The path of the method to invoke or
       *  the function invoked per iteration.
       * @param {...*} [args] The arguments to invoke each method with.
       * @returns {Array} Returns the array of results.
       * @example
       *
       * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
       * // => [[1, 5, 7], [1, 2, 3]]
       *
       * _.invokeMap([123, 456], String.prototype.split, '');
       * // => [['1', '2', '3'], ['4', '5', '6']]
       */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` thru `iteratee`. The corresponding value of
       * each key is the last element responsible for generating the key. The
       * iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * var array = [
       *   { 'dir': 'left', 'code': 97 },
       *   { 'dir': 'right', 'code': 100 }
       * ];
       *
       * _.keyBy(array, function(o) {
       *   return String.fromCharCode(o.code);
       * });
       * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
       *
       * _.keyBy(array, 'dir');
       * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
       */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
       * Creates an array of values by running each element in `collection` thru
       * `iteratee`. The iteratee is invoked with three arguments:
       * (value, index|key, collection).
       *
       * Many lodash methods are guarded to work as iteratees for methods like
       * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
       *
       * The guarded methods are:
       * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
       * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
       * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
       * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * _.map([4, 8], square);
       * // => [16, 64]
       *
       * _.map({ 'a': 4, 'b': 8 }, square);
       * // => [16, 64] (iteration order is not guaranteed)
       *
       * var users = [
       *   { 'user': 'barney' },
       *   { 'user': 'fred' }
       * ];
       *
       * // The `_.property` iteratee shorthand.
       * _.map(users, 'user');
       * // => ['barney', 'fred']
       */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
       * This method is like `_.sortBy` except that it allows specifying the sort
       * orders of the iteratees to sort by. If `orders` is unspecified, all values
       * are sorted in ascending order. Otherwise, specify an order of "desc" for
       * descending or "asc" for ascending sort order of corresponding values.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
       *  The iteratees to sort by.
       * @param {string[]} [orders] The sort orders of `iteratees`.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
       * @returns {Array} Returns the new sorted array.
       * @example
       *
       * var users = [
       *   { 'user': 'fred',   'age': 48 },
       *   { 'user': 'barney', 'age': 34 },
       *   { 'user': 'fred',   'age': 40 },
       *   { 'user': 'barney', 'age': 36 }
       * ];
       *
       * // Sort by `user` in ascending order and by `age` in descending order.
       * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
       * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
       */function orderBy(collection,iteratees,orders,guard){if(collection==null){return [];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined$1:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
       * Creates an array of elements split into two groups, the first of which
       * contains elements `predicate` returns truthy for, the second of which
       * contains elements `predicate` returns falsey for. The predicate is
       * invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the array of grouped elements.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36, 'active': false },
       *   { 'user': 'fred',    'age': 40, 'active': true },
       *   { 'user': 'pebbles', 'age': 1,  'active': false }
       * ];
       *
       * _.partition(users, function(o) { return o.active; });
       * // => objects for [['fred'], ['barney', 'pebbles']]
       *
       * // The `_.matches` iteratee shorthand.
       * _.partition(users, { 'age': 1, 'active': false });
       * // => objects for [['pebbles'], ['barney', 'fred']]
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.partition(users, ['active', false]);
       * // => objects for [['barney', 'pebbles'], ['fred']]
       *
       * // The `_.property` iteratee shorthand.
       * _.partition(users, 'active');
       * // => objects for [['fred'], ['barney', 'pebbles']]
       */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return [[],[]];});/**
       * Reduces `collection` to a value which is the accumulated result of running
       * each element in `collection` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `collection` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, collection).
       *
       * Many lodash methods are guarded to work as iteratees for methods like
       * `_.reduce`, `_.reduceRight`, and `_.transform`.
       *
       * The guarded methods are:
       * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
       * and `sortBy`
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @see _.reduceRight
       * @example
       *
       * _.reduce([1, 2], function(sum, n) {
       *   return sum + n;
       * }, 0);
       * // => 3
       *
       * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
       *   (result[value] || (result[value] = [])).push(key);
       *   return result;
       * }, {});
       * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
       */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
       * This method is like `_.reduce` except that it iterates over elements of
       * `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @see _.reduce
       * @example
       *
       * var array = [[0, 1], [2, 3], [4, 5]];
       *
       * _.reduceRight(array, function(flattened, other) {
       *   return flattened.concat(other);
       * }, []);
       * // => [4, 5, 2, 3, 0, 1]
       */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
       * The opposite of `_.filter`; this method returns the elements of `collection`
       * that `predicate` does **not** return truthy for.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @see _.filter
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': false },
       *   { 'user': 'fred',   'age': 40, 'active': true }
       * ];
       *
       * _.reject(users, function(o) { return !o.active; });
       * // => objects for ['fred']
       *
       * // The `_.matches` iteratee shorthand.
       * _.reject(users, { 'age': 40, 'active': true });
       * // => objects for ['barney']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.reject(users, ['active', false]);
       * // => objects for ['fred']
       *
       * // The `_.property` iteratee shorthand.
       * _.reject(users, 'active');
       * // => objects for ['barney']
       */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
       * Gets a random element from `collection`.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to sample.
       * @returns {*} Returns the random element.
       * @example
       *
       * _.sample([1, 2, 3, 4]);
       * // => 2
       */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
       * Gets `n` random elements at unique keys from `collection` up to the
       * size of `collection`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to sample.
       * @param {number} [n=1] The number of elements to sample.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the random elements.
       * @example
       *
       * _.sampleSize([1, 2, 3], 2);
       * // => [3, 1]
       *
       * _.sampleSize([1, 2, 3], 4);
       * // => [2, 3, 1]
       */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined$1){n=1;}else {n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
       * Creates an array of shuffled values, using a version of the
       * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to shuffle.
       * @returns {Array} Returns the new shuffled array.
       * @example
       *
       * _.shuffle([1, 2, 3, 4]);
       * // => [4, 1, 3, 2]
       */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
       * Gets the size of `collection` by returning its length for array-like
       * values or the number of own enumerable string keyed properties for objects.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * _.size([1, 2, 3]);
       * // => 3
       *
       * _.size({ 'a': 1, 'b': 2 });
       * // => 2
       *
       * _.size('pebbles');
       * // => 7
       */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
       * Checks if `predicate` returns truthy for **any** element of `collection`.
       * Iteration is stopped once `predicate` returns truthy. The predicate is
       * invoked with three arguments: (value, index|key, collection).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       * @example
       *
       * _.some([null, 0, 'yes', false], Boolean);
       * // => true
       *
       * var users = [
       *   { 'user': 'barney', 'active': true },
       *   { 'user': 'fred',   'active': false }
       * ];
       *
       * // The `_.matches` iteratee shorthand.
       * _.some(users, { 'user': 'barney', 'active': false });
       * // => false
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.some(users, ['active', false]);
       * // => true
       *
       * // The `_.property` iteratee shorthand.
       * _.some(users, 'active');
       * // => true
       */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined$1;}return func(collection,getIteratee(predicate,3));}/**
       * Creates an array of elements, sorted in ascending order by the results of
       * running each element in a collection thru each iteratee. This method
       * performs a stable sort, that is, it preserves the original sort order of
       * equal elements. The iteratees are invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {...(Function|Function[])} [iteratees=[_.identity]]
       *  The iteratees to sort by.
       * @returns {Array} Returns the new sorted array.
       * @example
       *
       * var users = [
       *   { 'user': 'fred',   'age': 48 },
       *   { 'user': 'barney', 'age': 36 },
       *   { 'user': 'fred',   'age': 30 },
       *   { 'user': 'barney', 'age': 34 }
       * ];
       *
       * _.sortBy(users, [function(o) { return o.user; }]);
       * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
       *
       * _.sortBy(users, ['user', 'age']);
       * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
       */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return [];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*/ /**
       * Gets the timestamp of the number of milliseconds that have elapsed since
       * the Unix epoch (1 January 1970 00:00:00 UTC).
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Date
       * @returns {number} Returns the timestamp.
       * @example
       *
       * _.defer(function(stamp) {
       *   console.log(_.now() - stamp);
       * }, _.now());
       * // => Logs the number of milliseconds it took for the deferred invocation.
       */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*/ /**
       * The opposite of `_.before`; this method creates a function that invokes
       * `func` once it's called `n` or more times.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {number} n The number of calls before `func` is invoked.
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new restricted function.
       * @example
       *
       * var saves = ['profile', 'settings'];
       *
       * var done = _.after(saves.length, function() {
       *   console.log('done saving!');
       * });
       *
       * _.forEach(saves, function(type) {
       *   asyncSave({ 'type': type, 'complete': done });
       * });
       * // => Logs 'done saving!' after the two async saves have completed.
       */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
       * Creates a function that invokes `func`, with up to `n` arguments,
       * ignoring any additional arguments.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} func The function to cap arguments for.
       * @param {number} [n=func.length] The arity cap.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the new capped function.
       * @example
       *
       * _.map(['6', '8', '10'], _.ary(parseInt, 1));
       * // => [6, 8, 10]
       */function ary(func,n,guard){n=guard?undefined$1:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,n);}/**
       * Creates a function that invokes `func`, with the `this` binding and arguments
       * of the created function, while it's called less than `n` times. Subsequent
       * calls to the created function return the result of the last `func` invocation.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {number} n The number of calls at which `func` is no longer invoked.
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new restricted function.
       * @example
       *
       * jQuery(element).on('click', _.before(5, addContactToList));
       * // => Allows adding up to 4 contacts to the list.
       */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined$1;}return result;};}/**
       * Creates a function that invokes `func` with the `this` binding of `thisArg`
       * and `partials` prepended to the arguments it receives.
       *
       * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
       * may be used as a placeholder for partially applied arguments.
       *
       * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
       * property of bound functions.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to bind.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new bound function.
       * @example
       *
       * function greet(greeting, punctuation) {
       *   return greeting + ' ' + this.user + punctuation;
       * }
       *
       * var object = { 'user': 'fred' };
       *
       * var bound = _.bind(greet, object, 'hi');
       * bound('!');
       * // => 'hi fred!'
       *
       * // Bound with placeholders.
       * var bound = _.bind(greet, object, _, '!');
       * bound('hi');
       * // => 'hi fred!'
       */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
       * Creates a function that invokes the method at `object[key]` with `partials`
       * prepended to the arguments it receives.
       *
       * This method differs from `_.bind` by allowing bound functions to reference
       * methods that may be redefined or don't yet exist. See
       * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
       * for more details.
       *
       * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for partially applied arguments.
       *
       * @static
       * @memberOf _
       * @since 0.10.0
       * @category Function
       * @param {Object} object The object to invoke the method on.
       * @param {string} key The key of the method.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new bound function.
       * @example
       *
       * var object = {
       *   'user': 'fred',
       *   'greet': function(greeting, punctuation) {
       *     return greeting + ' ' + this.user + punctuation;
       *   }
       * };
       *
       * var bound = _.bindKey(object, 'greet', 'hi');
       * bound('!');
       * // => 'hi fred!'
       *
       * object.greet = function(greeting, punctuation) {
       *   return greeting + 'ya ' + this.user + punctuation;
       * };
       *
       * bound('!');
       * // => 'hiya fred!'
       *
       * // Bound with placeholders.
       * var bound = _.bindKey(object, 'greet', _, '!');
       * bound('hi');
       * // => 'hiya fred!'
       */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
       * Creates a function that accepts arguments of `func` and either invokes
       * `func` returning its result, if at least `arity` number of arguments have
       * been provided, or returns a function that accepts the remaining `func`
       * arguments, and so on. The arity of `func` may be specified if `func.length`
       * is not sufficient.
       *
       * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
       * may be used as a placeholder for provided arguments.
       *
       * **Note:** This method doesn't set the "length" property of curried functions.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Function
       * @param {Function} func The function to curry.
       * @param {number} [arity=func.length] The arity of `func`.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the new curried function.
       * @example
       *
       * var abc = function(a, b, c) {
       *   return [a, b, c];
       * };
       *
       * var curried = _.curry(abc);
       *
       * curried(1)(2)(3);
       * // => [1, 2, 3]
       *
       * curried(1, 2)(3);
       * // => [1, 2, 3]
       *
       * curried(1, 2, 3);
       * // => [1, 2, 3]
       *
       * // Curried with placeholders.
       * curried(1)(_, 3)(2);
       * // => [1, 2, 3]
       */function curry(func,arity,guard){arity=guard?undefined$1:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,undefined$1,arity);result.placeholder=curry.placeholder;return result;}/**
       * This method is like `_.curry` except that arguments are applied to `func`
       * in the manner of `_.partialRight` instead of `_.partial`.
       *
       * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for provided arguments.
       *
       * **Note:** This method doesn't set the "length" property of curried functions.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} func The function to curry.
       * @param {number} [arity=func.length] The arity of `func`.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the new curried function.
       * @example
       *
       * var abc = function(a, b, c) {
       *   return [a, b, c];
       * };
       *
       * var curried = _.curryRight(abc);
       *
       * curried(3)(2)(1);
       * // => [1, 2, 3]
       *
       * curried(2, 3)(1);
       * // => [1, 2, 3]
       *
       * curried(1, 2, 3);
       * // => [1, 2, 3]
       *
       * // Curried with placeholders.
       * curried(3)(1, _)(2);
       * // => [1, 2, 3]
       */function curryRight(func,arity,guard){arity=guard?undefined$1:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,undefined$1,arity);result.placeholder=curryRight.placeholder;return result;}/**
       * Creates a debounced function that delays invoking `func` until after `wait`
       * milliseconds have elapsed since the last time the debounced function was
       * invoked. The debounced function comes with a `cancel` method to cancel
       * delayed `func` invocations and a `flush` method to immediately invoke them.
       * Provide `options` to indicate whether `func` should be invoked on the
       * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
       * with the last arguments provided to the debounced function. Subsequent
       * calls to the debounced function return the result of the last `func`
       * invocation.
       *
       * **Note:** If `leading` and `trailing` options are `true`, `func` is
       * invoked on the trailing edge of the timeout only if the debounced function
       * is invoked more than once during the `wait` timeout.
       *
       * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
       * until to the next tick, similar to `setTimeout` with a timeout of `0`.
       *
       * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
       * for details over the differences between `_.debounce` and `_.throttle`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to debounce.
       * @param {number} [wait=0] The number of milliseconds to delay.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.leading=false]
       *  Specify invoking on the leading edge of the timeout.
       * @param {number} [options.maxWait]
       *  The maximum time `func` is allowed to be delayed before it's invoked.
       * @param {boolean} [options.trailing=true]
       *  Specify invoking on the trailing edge of the timeout.
       * @returns {Function} Returns the new debounced function.
       * @example
       *
       * // Avoid costly calculations while the window size is in flux.
       * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
       *
       * // Invoke `sendMail` when clicked, debouncing subsequent calls.
       * jQuery(element).on('click', _.debounce(sendMail, 300, {
       *   'leading': true,
       *   'trailing': false
       * }));
       *
       * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
       * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
       * var source = new EventSource('/stream');
       * jQuery(source).on('message', debounced);
       *
       * // Cancel the trailing debounced invocation.
       * jQuery(window).on('popstate', debounced.cancel);
       */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined$1;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
  lastInvokeTime=time;// Start the timer for the trailing edge.
  timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
  return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
  // trailing edge, the system time has gone backwards and we're treating
  // it as the trailing edge, or we've hit the `maxWait` limit.
  return lastCallTime===undefined$1||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
  timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined$1;// Only invoke if we have `lastArgs` which means `func` has been
  // debounced at least once.
  if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined$1;return result;}function cancel(){if(timerId!==undefined$1){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined$1;}function flush(){return timerId===undefined$1?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined$1){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
  clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined$1){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
       * Defers invoking the `func` until the current call stack has cleared. Any
       * additional arguments are provided to `func` when it's invoked.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to defer.
       * @param {...*} [args] The arguments to invoke `func` with.
       * @returns {number} Returns the timer id.
       * @example
       *
       * _.defer(function(text) {
       *   console.log(text);
       * }, 'deferred');
       * // => Logs 'deferred' after one millisecond.
       */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
       * Invokes `func` after `wait` milliseconds. Any additional arguments are
       * provided to `func` when it's invoked.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to delay.
       * @param {number} wait The number of milliseconds to delay invocation.
       * @param {...*} [args] The arguments to invoke `func` with.
       * @returns {number} Returns the timer id.
       * @example
       *
       * _.delay(function(text) {
       *   console.log(text);
       * }, 1000, 'later');
       * // => Logs 'later' after one second.
       */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
       * Creates a function that invokes `func` with arguments reversed.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Function
       * @param {Function} func The function to flip arguments for.
       * @returns {Function} Returns the new flipped function.
       * @example
       *
       * var flipped = _.flip(function() {
       *   return _.toArray(arguments);
       * });
       *
       * flipped('a', 'b', 'c', 'd');
       * // => ['d', 'c', 'b', 'a']
       */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
       * Creates a function that memoizes the result of `func`. If `resolver` is
       * provided, it determines the cache key for storing the result based on the
       * arguments provided to the memoized function. By default, the first argument
       * provided to the memoized function is used as the map cache key. The `func`
       * is invoked with the `this` binding of the memoized function.
       *
       * **Note:** The cache is exposed as the `cache` property on the memoized
       * function. Its creation may be customized by replacing the `_.memoize.Cache`
       * constructor with one whose instances implement the
       * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
       * method interface of `clear`, `delete`, `get`, `has`, and `set`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to have its output memoized.
       * @param {Function} [resolver] The function to resolve the cache key.
       * @returns {Function} Returns the new memoized function.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       * var other = { 'c': 3, 'd': 4 };
       *
       * var values = _.memoize(_.values);
       * values(object);
       * // => [1, 2]
       *
       * values(other);
       * // => [3, 4]
       *
       * object.a = 2;
       * values(object);
       * // => [1, 2]
       *
       * // Modify the result cache.
       * values.cache.set(object, ['a', 'b']);
       * values(object);
       * // => ['a', 'b']
       *
       * // Replace `_.memoize.Cache`.
       * _.memoize.Cache = WeakMap;
       */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function memoized(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
  memoize.Cache=MapCache;/**
       * Creates a function that negates the result of the predicate `func`. The
       * `func` predicate is invoked with the `this` binding and arguments of the
       * created function.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} predicate The predicate to negate.
       * @returns {Function} Returns the new negated function.
       * @example
       *
       * function isEven(n) {
       *   return n % 2 == 0;
       * }
       *
       * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
       * // => [1, 3, 5]
       */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return !predicate.call(this);case 1:return !predicate.call(this,args[0]);case 2:return !predicate.call(this,args[0],args[1]);case 3:return !predicate.call(this,args[0],args[1],args[2]);}return !predicate.apply(this,args);};}/**
       * Creates a function that is restricted to invoking `func` once. Repeat calls
       * to the function return the value of the first invocation. The `func` is
       * invoked with the `this` binding and arguments of the created function.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new restricted function.
       * @example
       *
       * var initialize = _.once(createApplication);
       * initialize();
       * initialize();
       * // => `createApplication` is invoked once
       */function once(func){return before(2,func);}/**
       * Creates a function that invokes `func` with its arguments transformed.
       *
       * @static
       * @since 4.0.0
       * @memberOf _
       * @category Function
       * @param {Function} func The function to wrap.
       * @param {...(Function|Function[])} [transforms=[_.identity]]
       *  The argument transforms.
       * @returns {Function} Returns the new function.
       * @example
       *
       * function doubled(n) {
       *   return n * 2;
       * }
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var func = _.overArgs(function(x, y) {
       *   return [x, y];
       * }, [square, doubled]);
       *
       * func(9, 3);
       * // => [81, 6]
       *
       * func(10, 5);
       * // => [100, 10]
       */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
       * Creates a function that invokes `func` with `partials` prepended to the
       * arguments it receives. This method is like `_.bind` except it does **not**
       * alter the `this` binding.
       *
       * The `_.partial.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for partially applied arguments.
       *
       * **Note:** This method doesn't set the "length" property of partially
       * applied functions.
       *
       * @static
       * @memberOf _
       * @since 0.2.0
       * @category Function
       * @param {Function} func The function to partially apply arguments to.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new partially applied function.
       * @example
       *
       * function greet(greeting, name) {
       *   return greeting + ' ' + name;
       * }
       *
       * var sayHelloTo = _.partial(greet, 'hello');
       * sayHelloTo('fred');
       * // => 'hello fred'
       *
       * // Partially applied with placeholders.
       * var greetFred = _.partial(greet, _, 'fred');
       * greetFred('hi');
       * // => 'hi fred'
       */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined$1,partials,holders);});/**
       * This method is like `_.partial` except that partially applied arguments
       * are appended to the arguments it receives.
       *
       * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for partially applied arguments.
       *
       * **Note:** This method doesn't set the "length" property of partially
       * applied functions.
       *
       * @static
       * @memberOf _
       * @since 1.0.0
       * @category Function
       * @param {Function} func The function to partially apply arguments to.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new partially applied function.
       * @example
       *
       * function greet(greeting, name) {
       *   return greeting + ' ' + name;
       * }
       *
       * var greetFred = _.partialRight(greet, 'fred');
       * greetFred('hi');
       * // => 'hi fred'
       *
       * // Partially applied with placeholders.
       * var sayHelloTo = _.partialRight(greet, 'hello', _);
       * sayHelloTo('fred');
       * // => 'hello fred'
       */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined$1,partials,holders);});/**
       * Creates a function that invokes `func` with arguments arranged according
       * to the specified `indexes` where the argument value at the first index is
       * provided as the first argument, the argument value at the second index is
       * provided as the second argument, and so on.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} func The function to rearrange arguments for.
       * @param {...(number|number[])} indexes The arranged argument indexes.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var rearged = _.rearg(function(a, b, c) {
       *   return [a, b, c];
       * }, [2, 0, 1]);
       *
       * rearged('b', 'c', 'a')
       * // => ['a', 'b', 'c']
       */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined$1,undefined$1,undefined$1,indexes);});/**
       * Creates a function that invokes `func` with the `this` binding of the
       * created function and arguments from `start` and beyond provided as
       * an array.
       *
       * **Note:** This method is based on the
       * [rest parameter](https://mdn.io/rest_parameters).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Function
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var say = _.rest(function(what, names) {
       *   return what + ' ' + _.initial(names).join(', ') +
       *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
       * });
       *
       * say('hello', 'fred', 'barney', 'pebbles');
       * // => 'hello fred, barney, & pebbles'
       */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined$1?start:toInteger(start);return baseRest(func,start);}/**
       * Creates a function that invokes `func` with the `this` binding of the
       * create function and an array of arguments much like
       * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
       *
       * **Note:** This method is based on the
       * [spread operator](https://mdn.io/spread_operator).
       *
       * @static
       * @memberOf _
       * @since 3.2.0
       * @category Function
       * @param {Function} func The function to spread arguments over.
       * @param {number} [start=0] The start position of the spread.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var say = _.spread(function(who, what) {
       *   return who + ' says ' + what;
       * });
       *
       * say(['fred', 'hello']);
       * // => 'fred says hello'
       *
       * var numbers = Promise.all([
       *   Promise.resolve(40),
       *   Promise.resolve(36)
       * ]);
       *
       * numbers.then(_.spread(function(x, y) {
       *   return x + y;
       * }));
       * // => a Promise of 76
       */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
       * Creates a throttled function that only invokes `func` at most once per
       * every `wait` milliseconds. The throttled function comes with a `cancel`
       * method to cancel delayed `func` invocations and a `flush` method to
       * immediately invoke them. Provide `options` to indicate whether `func`
       * should be invoked on the leading and/or trailing edge of the `wait`
       * timeout. The `func` is invoked with the last arguments provided to the
       * throttled function. Subsequent calls to the throttled function return the
       * result of the last `func` invocation.
       *
       * **Note:** If `leading` and `trailing` options are `true`, `func` is
       * invoked on the trailing edge of the timeout only if the throttled function
       * is invoked more than once during the `wait` timeout.
       *
       * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
       * until to the next tick, similar to `setTimeout` with a timeout of `0`.
       *
       * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
       * for details over the differences between `_.throttle` and `_.debounce`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to throttle.
       * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.leading=true]
       *  Specify invoking on the leading edge of the timeout.
       * @param {boolean} [options.trailing=true]
       *  Specify invoking on the trailing edge of the timeout.
       * @returns {Function} Returns the new throttled function.
       * @example
       *
       * // Avoid excessively updating the position while scrolling.
       * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
       *
       * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
       * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
       * jQuery(element).on('click', throttled);
       *
       * // Cancel the trailing throttled invocation.
       * jQuery(window).on('popstate', throttled.cancel);
       */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
       * Creates a function that accepts up to one argument, ignoring any
       * additional arguments.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Function
       * @param {Function} func The function to cap arguments for.
       * @returns {Function} Returns the new capped function.
       * @example
       *
       * _.map(['6', '8', '10'], _.unary(parseInt));
       * // => [6, 8, 10]
       */function unary(func){return ary(func,1);}/**
       * Creates a function that provides `value` to `wrapper` as its first
       * argument. Any additional arguments provided to the function are appended
       * to those provided to the `wrapper`. The wrapper is invoked with the `this`
       * binding of the created function.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {*} value The value to wrap.
       * @param {Function} [wrapper=identity] The wrapper function.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var p = _.wrap(_.escape, function(func, text) {
       *   return '<p>' + func(text) + '</p>';
       * });
       *
       * p('fred, barney, & pebbles');
       * // => '<p>fred, barney, &amp; pebbles</p>'
       */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*/ /**
       * Casts `value` as an array if it's not one.
       *
       * @static
       * @memberOf _
       * @since 4.4.0
       * @category Lang
       * @param {*} value The value to inspect.
       * @returns {Array} Returns the cast array.
       * @example
       *
       * _.castArray(1);
       * // => [1]
       *
       * _.castArray({ 'a': 1 });
       * // => [{ 'a': 1 }]
       *
       * _.castArray('abc');
       * // => ['abc']
       *
       * _.castArray(null);
       * // => [null]
       *
       * _.castArray(undefined);
       * // => [undefined]
       *
       * _.castArray();
       * // => []
       *
       * var array = [1, 2, 3];
       * console.log(_.castArray(array) === array);
       * // => true
       */function castArray(){if(!arguments.length){return [];}var value=arguments[0];return isArray(value)?value:[value];}/**
       * Creates a shallow clone of `value`.
       *
       * **Note:** This method is loosely based on the
       * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
       * and supports cloning arrays, array buffers, booleans, date objects, maps,
       * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
       * arrays. The own enumerable properties of `arguments` objects are cloned
       * as plain objects. An empty object is returned for uncloneable values such
       * as error objects, functions, DOM nodes, and WeakMaps.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to clone.
       * @returns {*} Returns the cloned value.
       * @see _.cloneDeep
       * @example
       *
       * var objects = [{ 'a': 1 }, { 'b': 2 }];
       *
       * var shallow = _.clone(objects);
       * console.log(shallow[0] === objects[0]);
       * // => true
       */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
       * This method is like `_.clone` except that it accepts `customizer` which
       * is invoked to produce the cloned value. If `customizer` returns `undefined`,
       * cloning is handled by the method instead. The `customizer` is invoked with
       * up to four arguments; (value [, index|key, object, stack]).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to clone.
       * @param {Function} [customizer] The function to customize cloning.
       * @returns {*} Returns the cloned value.
       * @see _.cloneDeepWith
       * @example
       *
       * function customizer(value) {
       *   if (_.isElement(value)) {
       *     return value.cloneNode(false);
       *   }
       * }
       *
       * var el = _.cloneWith(document.body, customizer);
       *
       * console.log(el === document.body);
       * // => false
       * console.log(el.nodeName);
       * // => 'BODY'
       * console.log(el.childNodes.length);
       * // => 0
       */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
       * This method is like `_.clone` except that it recursively clones `value`.
       *
       * @static
       * @memberOf _
       * @since 1.0.0
       * @category Lang
       * @param {*} value The value to recursively clone.
       * @returns {*} Returns the deep cloned value.
       * @see _.clone
       * @example
       *
       * var objects = [{ 'a': 1 }, { 'b': 2 }];
       *
       * var deep = _.cloneDeep(objects);
       * console.log(deep[0] === objects[0]);
       * // => false
       */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
       * This method is like `_.cloneWith` except that it recursively clones `value`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to recursively clone.
       * @param {Function} [customizer] The function to customize cloning.
       * @returns {*} Returns the deep cloned value.
       * @see _.cloneWith
       * @example
       *
       * function customizer(value) {
       *   if (_.isElement(value)) {
       *     return value.cloneNode(true);
       *   }
       * }
       *
       * var el = _.cloneDeepWith(document.body, customizer);
       *
       * console.log(el === document.body);
       * // => false
       * console.log(el.nodeName);
       * // => 'BODY'
       * console.log(el.childNodes.length);
       * // => 20
       */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
       * Checks if `object` conforms to `source` by invoking the predicate
       * properties of `source` with the corresponding property values of `object`.
       *
       * **Note:** This method is equivalent to `_.conforms` when `source` is
       * partially applied.
       *
       * @static
       * @memberOf _
       * @since 4.14.0
       * @category Lang
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property predicates to conform to.
       * @returns {boolean} Returns `true` if `object` conforms, else `false`.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       *
       * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
       * // => true
       *
       * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
       * // => false
       */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
       * Performs a
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * comparison between two values to determine if they are equivalent.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * var object = { 'a': 1 };
       * var other = { 'a': 1 };
       *
       * _.eq(object, object);
       * // => true
       *
       * _.eq(object, other);
       * // => false
       *
       * _.eq('a', 'a');
       * // => true
       *
       * _.eq('a', Object('a'));
       * // => false
       *
       * _.eq(NaN, NaN);
       * // => true
       */function eq(value,other){return value===other||value!==value&&other!==other;}/**
       * Checks if `value` is greater than `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is greater than `other`,
       *  else `false`.
       * @see _.lt
       * @example
       *
       * _.gt(3, 1);
       * // => true
       *
       * _.gt(3, 3);
       * // => false
       *
       * _.gt(1, 3);
       * // => false
       */var gt=createRelationalOperation(baseGt);/**
       * Checks if `value` is greater than or equal to `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is greater than or equal to
       *  `other`, else `false`.
       * @see _.lte
       * @example
       *
       * _.gte(3, 1);
       * // => true
       *
       * _.gte(3, 3);
       * // => true
       *
       * _.gte(1, 3);
       * // => false
       */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
       * Checks if `value` is likely an `arguments` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       *  else `false`.
       * @example
       *
       * _.isArguments(function() { return arguments; }());
       * // => true
       *
       * _.isArguments([1, 2, 3]);
       * // => false
       */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
       * Checks if `value` is classified as an `Array` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array, else `false`.
       * @example
       *
       * _.isArray([1, 2, 3]);
       * // => true
       *
       * _.isArray(document.body.children);
       * // => false
       *
       * _.isArray('abc');
       * // => false
       *
       * _.isArray(_.noop);
       * // => false
       */var isArray=Array.isArray;/**
       * Checks if `value` is classified as an `ArrayBuffer` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
       * @example
       *
       * _.isArrayBuffer(new ArrayBuffer(2));
       * // => true
       *
       * _.isArrayBuffer(new Array(2));
       * // => false
       */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
       * Checks if `value` is array-like. A value is considered array-like if it's
       * not a function and has a `value.length` that's an integer greater than or
       * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
       * @example
       *
       * _.isArrayLike([1, 2, 3]);
       * // => true
       *
       * _.isArrayLike(document.body.children);
       * // => true
       *
       * _.isArrayLike('abc');
       * // => true
       *
       * _.isArrayLike(_.noop);
       * // => false
       */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
       * This method is like `_.isArrayLike` except that it also checks if `value`
       * is an object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array-like object,
       *  else `false`.
       * @example
       *
       * _.isArrayLikeObject([1, 2, 3]);
       * // => true
       *
       * _.isArrayLikeObject(document.body.children);
       * // => true
       *
       * _.isArrayLikeObject('abc');
       * // => false
       *
       * _.isArrayLikeObject(_.noop);
       * // => false
       */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
       * Checks if `value` is classified as a boolean primitive or object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
       * @example
       *
       * _.isBoolean(false);
       * // => true
       *
       * _.isBoolean(null);
       * // => false
       */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
       * Checks if `value` is a buffer.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
       * @example
       *
       * _.isBuffer(new Buffer(2));
       * // => true
       *
       * _.isBuffer(new Uint8Array(2));
       * // => false
       */var isBuffer=nativeIsBuffer||stubFalse;/**
       * Checks if `value` is classified as a `Date` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
       * @example
       *
       * _.isDate(new Date);
       * // => true
       *
       * _.isDate('Mon April 23 2012');
       * // => false
       */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
       * Checks if `value` is likely a DOM element.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
       * @example
       *
       * _.isElement(document.body);
       * // => true
       *
       * _.isElement('<body>');
       * // => false
       */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
       * Checks if `value` is an empty object, collection, map, or set.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Array-like values such as `arguments` objects, arrays, buffers, strings, or
       * jQuery-like collections are considered empty if they have a `length` of `0`.
       * Similarly, maps and sets are considered empty if they have a `size` of `0`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * _.isEmpty(null);
       * // => true
       *
       * _.isEmpty(true);
       * // => true
       *
       * _.isEmpty(1);
       * // => true
       *
       * _.isEmpty([1, 2, 3]);
       * // => false
       *
       * _.isEmpty({ 'a': 1 });
       * // => false
       */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return !value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return !value.size;}if(isPrototype(value)){return !baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
       * Performs a deep comparison between two values to determine if they are
       * equivalent.
       *
       * **Note:** This method supports comparing arrays, array buffers, booleans,
       * date objects, error objects, maps, numbers, `Object` objects, regexes,
       * sets, strings, symbols, and typed arrays. `Object` objects are compared
       * by their own, not inherited, enumerable properties. Functions and DOM
       * nodes are compared by strict equality, i.e. `===`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * var object = { 'a': 1 };
       * var other = { 'a': 1 };
       *
       * _.isEqual(object, other);
       * // => true
       *
       * object === other;
       * // => false
       */function isEqual(value,other){return baseIsEqual(value,other);}/**
       * This method is like `_.isEqual` except that it accepts `customizer` which
       * is invoked to compare values. If `customizer` returns `undefined`, comparisons
       * are handled by the method instead. The `customizer` is invoked with up to
       * six arguments: (objValue, othValue [, index|key, object, other, stack]).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @param {Function} [customizer] The function to customize comparisons.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * function isGreeting(value) {
       *   return /^h(?:i|ello)$/.test(value);
       * }
       *
       * function customizer(objValue, othValue) {
       *   if (isGreeting(objValue) && isGreeting(othValue)) {
       *     return true;
       *   }
       * }
       *
       * var array = ['hello', 'goodbye'];
       * var other = ['hi', 'goodbye'];
       *
       * _.isEqualWith(array, other, customizer);
       * // => true
       */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;var result=customizer?customizer(value,other):undefined$1;return result===undefined$1?baseIsEqual(value,other,undefined$1,customizer):!!result;}/**
       * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
       * `SyntaxError`, `TypeError`, or `URIError` object.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
       * @example
       *
       * _.isError(new Error);
       * // => true
       *
       * _.isError(Error);
       * // => false
       */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
       * Checks if `value` is a finite primitive number.
       *
       * **Note:** This method is based on
       * [`Number.isFinite`](https://mdn.io/Number/isFinite).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
       * @example
       *
       * _.isFinite(3);
       * // => true
       *
       * _.isFinite(Number.MIN_VALUE);
       * // => true
       *
       * _.isFinite(Infinity);
       * // => false
       *
       * _.isFinite('3');
       * // => false
       */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
       * Checks if `value` is classified as a `Function` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a function, else `false`.
       * @example
       *
       * _.isFunction(_);
       * // => true
       *
       * _.isFunction(/abc/);
       * // => false
       */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
       * Checks if `value` is an integer.
       *
       * **Note:** This method is based on
       * [`Number.isInteger`](https://mdn.io/Number/isInteger).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
       * @example
       *
       * _.isInteger(3);
       * // => true
       *
       * _.isInteger(Number.MIN_VALUE);
       * // => false
       *
       * _.isInteger(Infinity);
       * // => false
       *
       * _.isInteger('3');
       * // => false
       */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
       * Checks if `value` is a valid array-like length.
       *
       * **Note:** This method is loosely based on
       * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
       * @example
       *
       * _.isLength(3);
       * // => true
       *
       * _.isLength(Number.MIN_VALUE);
       * // => false
       *
       * _.isLength(Infinity);
       * // => false
       *
       * _.isLength('3');
       * // => false
       */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
       * Checks if `value` is the
       * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
       * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an object, else `false`.
       * @example
       *
       * _.isObject({});
       * // => true
       *
       * _.isObject([1, 2, 3]);
       * // => true
       *
       * _.isObject(_.noop);
       * // => true
       *
       * _.isObject(null);
       * // => false
       */function isObject(value){var type=_typeof(value);return value!=null&&(type=='object'||type=='function');}/**
       * Checks if `value` is object-like. A value is object-like if it's not `null`
       * and has a `typeof` result of "object".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       * @example
       *
       * _.isObjectLike({});
       * // => true
       *
       * _.isObjectLike([1, 2, 3]);
       * // => true
       *
       * _.isObjectLike(_.noop);
       * // => false
       *
       * _.isObjectLike(null);
       * // => false
       */function isObjectLike(value){return value!=null&&_typeof(value)=='object';}/**
       * Checks if `value` is classified as a `Map` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a map, else `false`.
       * @example
       *
       * _.isMap(new Map);
       * // => true
       *
       * _.isMap(new WeakMap);
       * // => false
       */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
       * Performs a partial deep comparison between `object` and `source` to
       * determine if `object` contains equivalent property values.
       *
       * **Note:** This method is equivalent to `_.matches` when `source` is
       * partially applied.
       *
       * Partial comparisons will match empty array and empty object `source`
       * values against any array or object value, respectively. See `_.isEqual`
       * for a list of supported value comparisons.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property values to match.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       *
       * _.isMatch(object, { 'b': 2 });
       * // => true
       *
       * _.isMatch(object, { 'b': 1 });
       * // => false
       */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
       * This method is like `_.isMatch` except that it accepts `customizer` which
       * is invoked to compare values. If `customizer` returns `undefined`, comparisons
       * are handled by the method instead. The `customizer` is invoked with five
       * arguments: (objValue, srcValue, index|key, object, source).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property values to match.
       * @param {Function} [customizer] The function to customize comparisons.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       * @example
       *
       * function isGreeting(value) {
       *   return /^h(?:i|ello)$/.test(value);
       * }
       *
       * function customizer(objValue, srcValue) {
       *   if (isGreeting(objValue) && isGreeting(srcValue)) {
       *     return true;
       *   }
       * }
       *
       * var object = { 'greeting': 'hello' };
       * var source = { 'greeting': 'hi' };
       *
       * _.isMatchWith(object, source, customizer);
       * // => true
       */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
       * Checks if `value` is `NaN`.
       *
       * **Note:** This method is based on
       * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
       * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
       * `undefined` and other non-number values.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
       * @example
       *
       * _.isNaN(NaN);
       * // => true
       *
       * _.isNaN(new Number(NaN));
       * // => true
       *
       * isNaN(undefined);
       * // => true
       *
       * _.isNaN(undefined);
       * // => false
       */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
  // Perform the `toStringTag` check first to avoid errors with some
  // ActiveX objects in IE.
  return isNumber(value)&&value!=+value;}/**
       * Checks if `value` is a pristine native function.
       *
       * **Note:** This method can't reliably detect native functions in the presence
       * of the core-js package because core-js circumvents this kind of detection.
       * Despite multiple requests, the core-js maintainer has made it clear: any
       * attempt to fix the detection will be obstructed. As a result, we're left
       * with little choice but to throw an error. Unfortunately, this also affects
       * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
       * which rely on core-js.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a native function,
       *  else `false`.
       * @example
       *
       * _.isNative(Array.prototype.push);
       * // => true
       *
       * _.isNative(_);
       * // => false
       */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
       * Checks if `value` is `null`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
       * @example
       *
       * _.isNull(null);
       * // => true
       *
       * _.isNull(void 0);
       * // => false
       */function isNull(value){return value===null;}/**
       * Checks if `value` is `null` or `undefined`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
       * @example
       *
       * _.isNil(null);
       * // => true
       *
       * _.isNil(void 0);
       * // => true
       *
       * _.isNil(NaN);
       * // => false
       */function isNil(value){return value==null;}/**
       * Checks if `value` is classified as a `Number` primitive or object.
       *
       * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
       * classified as numbers, use the `_.isFinite` method.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a number, else `false`.
       * @example
       *
       * _.isNumber(3);
       * // => true
       *
       * _.isNumber(Number.MIN_VALUE);
       * // => true
       *
       * _.isNumber(Infinity);
       * // => true
       *
       * _.isNumber('3');
       * // => false
       */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
       * Checks if `value` is a plain object, that is, an object created by the
       * `Object` constructor or one with a `[[Prototype]]` of `null`.
       *
       * @static
       * @memberOf _
       * @since 0.8.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * _.isPlainObject(new Foo);
       * // => false
       *
       * _.isPlainObject([1, 2, 3]);
       * // => false
       *
       * _.isPlainObject({ 'x': 0, 'y': 0 });
       * // => true
       *
       * _.isPlainObject(Object.create(null));
       * // => true
       */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
       * Checks if `value` is classified as a `RegExp` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
       * @example
       *
       * _.isRegExp(/abc/);
       * // => true
       *
       * _.isRegExp('/abc/');
       * // => false
       */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
       * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
       * double precision number which isn't the result of a rounded unsafe integer.
       *
       * **Note:** This method is based on
       * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
       * @example
       *
       * _.isSafeInteger(3);
       * // => true
       *
       * _.isSafeInteger(Number.MIN_VALUE);
       * // => false
       *
       * _.isSafeInteger(Infinity);
       * // => false
       *
       * _.isSafeInteger('3');
       * // => false
       */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
       * Checks if `value` is classified as a `Set` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a set, else `false`.
       * @example
       *
       * _.isSet(new Set);
       * // => true
       *
       * _.isSet(new WeakSet);
       * // => false
       */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
       * Checks if `value` is classified as a `String` primitive or object.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a string, else `false`.
       * @example
       *
       * _.isString('abc');
       * // => true
       *
       * _.isString(1);
       * // => false
       */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
       * Checks if `value` is classified as a `Symbol` primitive or object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
       * @example
       *
       * _.isSymbol(Symbol.iterator);
       * // => true
       *
       * _.isSymbol('abc');
       * // => false
       */function isSymbol(value){return _typeof(value)=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
       * Checks if `value` is classified as a typed array.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
       * @example
       *
       * _.isTypedArray(new Uint8Array);
       * // => true
       *
       * _.isTypedArray([]);
       * // => false
       */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
       * Checks if `value` is `undefined`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * _.isUndefined(void 0);
       * // => true
       *
       * _.isUndefined(null);
       * // => false
       */function isUndefined(value){return value===undefined$1;}/**
       * Checks if `value` is classified as a `WeakMap` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
       * @example
       *
       * _.isWeakMap(new WeakMap);
       * // => true
       *
       * _.isWeakMap(new Map);
       * // => false
       */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
       * Checks if `value` is classified as a `WeakSet` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
       * @example
       *
       * _.isWeakSet(new WeakSet);
       * // => true
       *
       * _.isWeakSet(new Set);
       * // => false
       */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
       * Checks if `value` is less than `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is less than `other`,
       *  else `false`.
       * @see _.gt
       * @example
       *
       * _.lt(1, 3);
       * // => true
       *
       * _.lt(3, 3);
       * // => false
       *
       * _.lt(3, 1);
       * // => false
       */var lt=createRelationalOperation(baseLt);/**
       * Checks if `value` is less than or equal to `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is less than or equal to
       *  `other`, else `false`.
       * @see _.gte
       * @example
       *
       * _.lte(1, 3);
       * // => true
       *
       * _.lte(3, 3);
       * // => true
       *
       * _.lte(3, 1);
       * // => false
       */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
       * Converts `value` to an array.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {Array} Returns the converted array.
       * @example
       *
       * _.toArray({ 'a': 1, 'b': 2 });
       * // => [1, 2]
       *
       * _.toArray('abc');
       * // => ['a', 'b', 'c']
       *
       * _.toArray(1);
       * // => []
       *
       * _.toArray(null);
       * // => []
       */function toArray(value){if(!value){return [];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
       * Converts `value` to a finite number.
       *
       * @static
       * @memberOf _
       * @since 4.12.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted number.
       * @example
       *
       * _.toFinite(3.2);
       * // => 3.2
       *
       * _.toFinite(Number.MIN_VALUE);
       * // => 5e-324
       *
       * _.toFinite(Infinity);
       * // => 1.7976931348623157e+308
       *
       * _.toFinite('3.2');
       * // => 3.2
       */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
       * Converts `value` to an integer.
       *
       * **Note:** This method is loosely based on
       * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.toInteger(3.2);
       * // => 3
       *
       * _.toInteger(Number.MIN_VALUE);
       * // => 0
       *
       * _.toInteger(Infinity);
       * // => 1.7976931348623157e+308
       *
       * _.toInteger('3.2');
       * // => 3
       */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
       * Converts `value` to an integer suitable for use as the length of an
       * array-like object.
       *
       * **Note:** This method is based on
       * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.toLength(3.2);
       * // => 3
       *
       * _.toLength(Number.MIN_VALUE);
       * // => 0
       *
       * _.toLength(Infinity);
       * // => 4294967295
       *
       * _.toLength('3.2');
       * // => 3
       */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
       * Converts `value` to a number.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to process.
       * @returns {number} Returns the number.
       * @example
       *
       * _.toNumber(3.2);
       * // => 3.2
       *
       * _.toNumber(Number.MIN_VALUE);
       * // => 5e-324
       *
       * _.toNumber(Infinity);
       * // => Infinity
       *
       * _.toNumber('3.2');
       * // => 3.2
       */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=baseTrim(value);var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
       * Converts `value` to a plain object flattening inherited enumerable string
       * keyed properties of `value` to own properties of the plain object.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {Object} Returns the converted plain object.
       * @example
       *
       * function Foo() {
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.assign({ 'a': 1 }, new Foo);
       * // => { 'a': 1, 'b': 2 }
       *
       * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
       * // => { 'a': 1, 'b': 2, 'c': 3 }
       */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
       * Converts `value` to a safe integer. A safe integer can be compared and
       * represented correctly.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.toSafeInteger(3.2);
       * // => 3
       *
       * _.toSafeInteger(Number.MIN_VALUE);
       * // => 0
       *
       * _.toSafeInteger(Infinity);
       * // => 9007199254740991
       *
       * _.toSafeInteger('3.2');
       * // => 3
       */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
       * Converts `value` to a string. An empty string is returned for `null`
       * and `undefined` values. The sign of `-0` is preserved.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.toString(null);
       * // => ''
       *
       * _.toString(-0);
       * // => '-0'
       *
       * _.toString([1, 2, 3]);
       * // => '1,2,3'
       */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*/ /**
       * Assigns own enumerable string keyed properties of source objects to the
       * destination object. Source objects are applied from left to right.
       * Subsequent sources overwrite property assignments of previous sources.
       *
       * **Note:** This method mutates `object` and is loosely based on
       * [`Object.assign`](https://mdn.io/Object/assign).
       *
       * @static
       * @memberOf _
       * @since 0.10.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.assignIn
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * function Bar() {
       *   this.c = 3;
       * }
       *
       * Foo.prototype.b = 2;
       * Bar.prototype.d = 4;
       *
       * _.assign({ 'a': 0 }, new Foo, new Bar);
       * // => { 'a': 1, 'c': 3 }
       */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
       * This method is like `_.assign` except that it iterates over own and
       * inherited source properties.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias extend
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.assign
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * function Bar() {
       *   this.c = 3;
       * }
       *
       * Foo.prototype.b = 2;
       * Bar.prototype.d = 4;
       *
       * _.assignIn({ 'a': 0 }, new Foo, new Bar);
       * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
       */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
       * This method is like `_.assignIn` except that it accepts `customizer`
       * which is invoked to produce the assigned values. If `customizer` returns
       * `undefined`, assignment is handled by the method instead. The `customizer`
       * is invoked with five arguments: (objValue, srcValue, key, object, source).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias extendWith
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} sources The source objects.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @see _.assignWith
       * @example
       *
       * function customizer(objValue, srcValue) {
       *   return _.isUndefined(objValue) ? srcValue : objValue;
       * }
       *
       * var defaults = _.partialRight(_.assignInWith, customizer);
       *
       * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
       * // => { 'a': 1, 'b': 2 }
       */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
       * This method is like `_.assign` except that it accepts `customizer`
       * which is invoked to produce the assigned values. If `customizer` returns
       * `undefined`, assignment is handled by the method instead. The `customizer`
       * is invoked with five arguments: (objValue, srcValue, key, object, source).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} sources The source objects.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @see _.assignInWith
       * @example
       *
       * function customizer(objValue, srcValue) {
       *   return _.isUndefined(objValue) ? srcValue : objValue;
       * }
       *
       * var defaults = _.partialRight(_.assignWith, customizer);
       *
       * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
       * // => { 'a': 1, 'b': 2 }
       */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
       * Creates an array of values corresponding to `paths` of `object`.
       *
       * @static
       * @memberOf _
       * @since 1.0.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Array} Returns the picked values.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
       *
       * _.at(object, ['a[0].b.c', 'a[1]']);
       * // => [3, 4]
       */var at=flatRest(baseAt);/**
       * Creates an object that inherits from the `prototype` object. If a
       * `properties` object is given, its own enumerable string keyed properties
       * are assigned to the created object.
       *
       * @static
       * @memberOf _
       * @since 2.3.0
       * @category Object
       * @param {Object} prototype The object to inherit from.
       * @param {Object} [properties] The properties to assign to the object.
       * @returns {Object} Returns the new object.
       * @example
       *
       * function Shape() {
       *   this.x = 0;
       *   this.y = 0;
       * }
       *
       * function Circle() {
       *   Shape.call(this);
       * }
       *
       * Circle.prototype = _.create(Shape.prototype, {
       *   'constructor': Circle
       * });
       *
       * var circle = new Circle;
       * circle instanceof Circle;
       * // => true
       *
       * circle instanceof Shape;
       * // => true
       */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
       * Assigns own and inherited enumerable string keyed properties of source
       * objects to the destination object for all destination properties that
       * resolve to `undefined`. Source objects are applied from left to right.
       * Once a property is set, additional values of the same property are ignored.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.defaultsDeep
       * @example
       *
       * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
       * // => { 'a': 1, 'b': 2 }
       */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined$1;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined$1||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
       * This method is like `_.defaults` except that it recursively assigns
       * default properties.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.defaults
       * @example
       *
       * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
       * // => { 'a': { 'b': 2, 'c': 3 } }
       */var defaultsDeep=baseRest(function(args){args.push(undefined$1,customDefaultsMerge);return apply(mergeWith,undefined$1,args);});/**
       * This method is like `_.find` except that it returns the key of the first
       * element `predicate` returns truthy for instead of the element itself.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category Object
       * @param {Object} object The object to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {string|undefined} Returns the key of the matched element,
       *  else `undefined`.
       * @example
       *
       * var users = {
       *   'barney':  { 'age': 36, 'active': true },
       *   'fred':    { 'age': 40, 'active': false },
       *   'pebbles': { 'age': 1,  'active': true }
       * };
       *
       * _.findKey(users, function(o) { return o.age < 40; });
       * // => 'barney' (iteration order is not guaranteed)
       *
       * // The `_.matches` iteratee shorthand.
       * _.findKey(users, { 'age': 1, 'active': true });
       * // => 'pebbles'
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findKey(users, ['active', false]);
       * // => 'fred'
       *
       * // The `_.property` iteratee shorthand.
       * _.findKey(users, 'active');
       * // => 'barney'
       */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
       * This method is like `_.findKey` except that it iterates over elements of
       * a collection in the opposite order.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Object
       * @param {Object} object The object to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {string|undefined} Returns the key of the matched element,
       *  else `undefined`.
       * @example
       *
       * var users = {
       *   'barney':  { 'age': 36, 'active': true },
       *   'fred':    { 'age': 40, 'active': false },
       *   'pebbles': { 'age': 1,  'active': true }
       * };
       *
       * _.findLastKey(users, function(o) { return o.age < 40; });
       * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
       *
       * // The `_.matches` iteratee shorthand.
       * _.findLastKey(users, { 'age': 36, 'active': true });
       * // => 'barney'
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findLastKey(users, ['active', false]);
       * // => 'fred'
       *
       * // The `_.property` iteratee shorthand.
       * _.findLastKey(users, 'active');
       * // => 'pebbles'
       */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
       * Iterates over own and inherited enumerable string keyed properties of an
       * object and invokes `iteratee` for each property. The iteratee is invoked
       * with three arguments: (value, key, object). Iteratee functions may exit
       * iteration early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @since 0.3.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forInRight
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forIn(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
       */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
       * This method is like `_.forIn` except that it iterates over properties of
       * `object` in the opposite order.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forIn
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forInRight(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
       */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
       * Iterates over own enumerable string keyed properties of an object and
       * invokes `iteratee` for each property. The iteratee is invoked with three
       * arguments: (value, key, object). Iteratee functions may exit iteration
       * early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @since 0.3.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forOwnRight
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forOwn(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'a' then 'b' (iteration order is not guaranteed).
       */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
       * This method is like `_.forOwn` except that it iterates over properties of
       * `object` in the opposite order.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forOwn
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forOwnRight(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
       */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
       * Creates an array of function property names from own enumerable properties
       * of `object`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to inspect.
       * @returns {Array} Returns the function names.
       * @see _.functionsIn
       * @example
       *
       * function Foo() {
       *   this.a = _.constant('a');
       *   this.b = _.constant('b');
       * }
       *
       * Foo.prototype.c = _.constant('c');
       *
       * _.functions(new Foo);
       * // => ['a', 'b']
       */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
       * Creates an array of function property names from own and inherited
       * enumerable properties of `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to inspect.
       * @returns {Array} Returns the function names.
       * @see _.functions
       * @example
       *
       * function Foo() {
       *   this.a = _.constant('a');
       *   this.b = _.constant('b');
       * }
       *
       * Foo.prototype.c = _.constant('c');
       *
       * _.functionsIn(new Foo);
       * // => ['a', 'b', 'c']
       */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
       *
       * _.get(object, 'a[0].b.c');
       * // => 3
       *
       * _.get(object, ['a', '0', 'b', 'c']);
       * // => 3
       *
       * _.get(object, 'a.b.c', 'default');
       * // => 'default'
       */function get(object,path,defaultValue){var result=object==null?undefined$1:baseGet(object,path);return result===undefined$1?defaultValue:result;}/**
       * Checks if `path` is a direct property of `object`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       * @example
       *
       * var object = { 'a': { 'b': 2 } };
       * var other = _.create({ 'a': _.create({ 'b': 2 }) });
       *
       * _.has(object, 'a');
       * // => true
       *
       * _.has(object, 'a.b');
       * // => true
       *
       * _.has(object, ['a', 'b']);
       * // => true
       *
       * _.has(other, 'a');
       * // => false
       */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
       * Checks if `path` is a direct or inherited property of `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       * @example
       *
       * var object = _.create({ 'a': _.create({ 'b': 2 }) });
       *
       * _.hasIn(object, 'a');
       * // => true
       *
       * _.hasIn(object, 'a.b');
       * // => true
       *
       * _.hasIn(object, ['a', 'b']);
       * // => true
       *
       * _.hasIn(object, 'b');
       * // => false
       */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
       * Creates an object composed of the inverted keys and values of `object`.
       * If `object` contains duplicate values, subsequent values overwrite
       * property assignments of previous values.
       *
       * @static
       * @memberOf _
       * @since 0.7.0
       * @category Object
       * @param {Object} object The object to invert.
       * @returns {Object} Returns the new inverted object.
       * @example
       *
       * var object = { 'a': 1, 'b': 2, 'c': 1 };
       *
       * _.invert(object);
       * // => { '1': 'c', '2': 'b' }
       */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
       * This method is like `_.invert` except that the inverted object is generated
       * from the results of running each element of `object` thru `iteratee`. The
       * corresponding inverted value of each inverted key is an array of keys
       * responsible for generating the inverted value. The iteratee is invoked
       * with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.1.0
       * @category Object
       * @param {Object} object The object to invert.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Object} Returns the new inverted object.
       * @example
       *
       * var object = { 'a': 1, 'b': 2, 'c': 1 };
       *
       * _.invertBy(object);
       * // => { '1': ['a', 'c'], '2': ['b'] }
       *
       * _.invertBy(object, function(value) {
       *   return 'group' + value;
       * });
       * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
       */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else {result[value]=[key];}},getIteratee);/**
       * Invokes the method at `path` of `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the method to invoke.
       * @param {...*} [args] The arguments to invoke the method with.
       * @returns {*} Returns the result of the invoked method.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
       *
       * _.invoke(object, 'a[0].b.c.slice', 1, 3);
       * // => [2, 3]
       */var invoke=baseRest(baseInvoke);/**
       * Creates an array of the own enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects. See the
       * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
       * for more details.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keys(new Foo);
       * // => ['a', 'b'] (iteration order is not guaranteed)
       *
       * _.keys('hi');
       * // => ['0', '1']
       */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
       * Creates an array of the own and inherited enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keysIn(new Foo);
       * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
       */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
       * The opposite of `_.mapValues`; this method creates an object with the
       * same values as `object` and keys generated by running each own enumerable
       * string keyed property of `object` thru `iteratee`. The iteratee is invoked
       * with three arguments: (value, key, object).
       *
       * @static
       * @memberOf _
       * @since 3.8.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns the new mapped object.
       * @see _.mapValues
       * @example
       *
       * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
       *   return key + value;
       * });
       * // => { 'a1': 1, 'b2': 2 }
       */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
       * Creates an object with the same keys as `object` and values generated
       * by running each own enumerable string keyed property of `object` thru
       * `iteratee`. The iteratee is invoked with three arguments:
       * (value, key, object).
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns the new mapped object.
       * @see _.mapKeys
       * @example
       *
       * var users = {
       *   'fred':    { 'user': 'fred',    'age': 40 },
       *   'pebbles': { 'user': 'pebbles', 'age': 1 }
       * };
       *
       * _.mapValues(users, function(o) { return o.age; });
       * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
       *
       * // The `_.property` iteratee shorthand.
       * _.mapValues(users, 'age');
       * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
       */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
       * This method is like `_.assign` except that it recursively merges own and
       * inherited enumerable string keyed properties of source objects into the
       * destination object. Source properties that resolve to `undefined` are
       * skipped if a destination value exists. Array and plain object properties
       * are merged recursively. Other objects and value types are overridden by
       * assignment. Source objects are applied from left to right. Subsequent
       * sources overwrite property assignments of previous sources.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 0.5.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = {
       *   'a': [{ 'b': 2 }, { 'd': 4 }]
       * };
       *
       * var other = {
       *   'a': [{ 'c': 3 }, { 'e': 5 }]
       * };
       *
       * _.merge(object, other);
       * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
       */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
       * This method is like `_.merge` except that it accepts `customizer` which
       * is invoked to produce the merged values of the destination and source
       * properties. If `customizer` returns `undefined`, merging is handled by the
       * method instead. The `customizer` is invoked with six arguments:
       * (objValue, srcValue, key, object, source, stack).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} sources The source objects.
       * @param {Function} customizer The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @example
       *
       * function customizer(objValue, srcValue) {
       *   if (_.isArray(objValue)) {
       *     return objValue.concat(srcValue);
       *   }
       * }
       *
       * var object = { 'a': [1], 'b': [2] };
       * var other = { 'a': [3], 'b': [4] };
       *
       * _.mergeWith(object, other, customizer);
       * // => { 'a': [1, 3], 'b': [2, 4] }
       */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
       * The opposite of `_.pick`; this method creates an object composed of the
       * own and inherited enumerable property paths of `object` that are not omitted.
       *
       * **Note:** This method is considerably slower than `_.pick`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The source object.
       * @param {...(string|string[])} [paths] The property paths to omit.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.omit(object, ['a', 'c']);
       * // => { 'b': '2' }
       */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
       * The opposite of `_.pickBy`; this method creates an object composed of
       * the own and inherited enumerable string keyed properties of `object` that
       * `predicate` doesn't return truthy for. The predicate is invoked with two
       * arguments: (value, key).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The source object.
       * @param {Function} [predicate=_.identity] The function invoked per property.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.omitBy(object, _.isNumber);
       * // => { 'b': '2' }
       */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
       * Creates an object composed of the picked `object` properties.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The source object.
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.pick(object, ['a', 'c']);
       * // => { 'a': 1, 'c': 3 }
       */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
       * Creates an object composed of the `object` properties `predicate` returns
       * truthy for. The predicate is invoked with two arguments: (value, key).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The source object.
       * @param {Function} [predicate=_.identity] The function invoked per property.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.pickBy(object, _.isNumber);
       * // => { 'a': 1, 'c': 3 }
       */function pickBy(object,predicate){if(object==null){return {};}var props=arrayMap(getAllKeysIn(object),function(prop){return [prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
       * This method is like `_.get` except that if the resolved value is a
       * function it's invoked with the `this` binding of its parent object and
       * its result is returned.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to resolve.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
       *
       * _.result(object, 'a[0].b.c1');
       * // => 3
       *
       * _.result(object, 'a[0].b.c2');
       * // => 4
       *
       * _.result(object, 'a[0].b.c3', 'default');
       * // => 'default'
       *
       * _.result(object, 'a[0].b.c3', _.constant('default'));
       * // => 'default'
       */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
  if(!length){length=1;object=undefined$1;}while(++index<length){var value=object==null?undefined$1:object[toKey(path[index])];if(value===undefined$1){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
       * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
       * it's created. Arrays are created for missing index properties while objects
       * are created for all other missing properties. Use `_.setWith` to customize
       * `path` creation.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
       *
       * _.set(object, 'a[0].b.c', 4);
       * console.log(object.a[0].b.c);
       * // => 4
       *
       * _.set(object, ['x', '0', 'y', 'z'], 5);
       * console.log(object.x[0].y.z);
       * // => 5
       */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
       * This method is like `_.set` except that it accepts `customizer` which is
       * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
       * path creation is handled by the method instead. The `customizer` is invoked
       * with three arguments: (nsValue, key, nsObject).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {*} value The value to set.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = {};
       *
       * _.setWith(object, '[0][1]', 'a', Object);
       * // => { '0': { '1': 'a' } }
       */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return object==null?object:baseSet(object,path,value,customizer);}/**
       * Creates an array of own enumerable string keyed-value pairs for `object`
       * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
       * entries are returned.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias entries
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the key-value pairs.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.toPairs(new Foo);
       * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
       */var toPairs=createToPairs(keys);/**
       * Creates an array of own and inherited enumerable string keyed-value pairs
       * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
       * or set, its entries are returned.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias entriesIn
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the key-value pairs.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.toPairsIn(new Foo);
       * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
       */var toPairsIn=createToPairs(keysIn);/**
       * An alternative to `_.reduce`; this method transforms `object` to a new
       * `accumulator` object which is the result of running each of its own
       * enumerable string keyed properties thru `iteratee`, with each invocation
       * potentially mutating the `accumulator` object. If `accumulator` is not
       * provided, a new object with the same `[[Prototype]]` will be used. The
       * iteratee is invoked with four arguments: (accumulator, value, key, object).
       * Iteratee functions may exit iteration early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @since 1.3.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [accumulator] The custom accumulator value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * _.transform([2, 3, 4], function(result, n) {
       *   result.push(n *= n);
       *   return n % 2 == 0;
       * }, []);
       * // => [4, 9]
       *
       * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
       *   (result[value] || (result[value] = [])).push(key);
       * }, {});
       * // => { '1': ['a', 'c'], '2': ['b'] }
       */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else {accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
       * Removes the property at `path` of `object`.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to unset.
       * @returns {boolean} Returns `true` if the property is deleted, else `false`.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 7 } }] };
       * _.unset(object, 'a[0].b.c');
       * // => true
       *
       * console.log(object);
       * // => { 'a': [{ 'b': {} }] };
       *
       * _.unset(object, ['a', '0', 'b', 'c']);
       * // => true
       *
       * console.log(object);
       * // => { 'a': [{ 'b': {} }] };
       */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
       * This method is like `_.set` except that accepts `updater` to produce the
       * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
       * is invoked with one argument: (value).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.6.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {Function} updater The function to produce the updated value.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
       *
       * _.update(object, 'a[0].b.c', function(n) { return n * n; });
       * console.log(object.a[0].b.c);
       * // => 9
       *
       * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
       * console.log(object.x[0].y.z);
       * // => 0
       */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
       * This method is like `_.update` except that it accepts `customizer` which is
       * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
       * path creation is handled by the method instead. The `customizer` is invoked
       * with three arguments: (nsValue, key, nsObject).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.6.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {Function} updater The function to produce the updated value.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = {};
       *
       * _.updateWith(object, '[0][1]', _.constant('a'), Object);
       * // => { '0': { '1': 'a' } }
       */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
       * Creates an array of the own enumerable string keyed property values of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property values.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.values(new Foo);
       * // => [1, 2] (iteration order is not guaranteed)
       *
       * _.values('hi');
       * // => ['h', 'i']
       */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
       * Creates an array of the own and inherited enumerable string keyed property
       * values of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property values.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.valuesIn(new Foo);
       * // => [1, 2, 3] (iteration order is not guaranteed)
       */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*/ /**
       * Clamps `number` within the inclusive `lower` and `upper` bounds.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Number
       * @param {number} number The number to clamp.
       * @param {number} [lower] The lower bound.
       * @param {number} upper The upper bound.
       * @returns {number} Returns the clamped number.
       * @example
       *
       * _.clamp(-10, -5, 5);
       * // => -5
       *
       * _.clamp(10, -5, 5);
       * // => 5
       */function clamp(number,lower,upper){if(upper===undefined$1){upper=lower;lower=undefined$1;}if(upper!==undefined$1){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined$1){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
       * Checks if `n` is between `start` and up to, but not including, `end`. If
       * `end` is not specified, it's set to `start` with `start` then set to `0`.
       * If `start` is greater than `end` the params are swapped to support
       * negative ranges.
       *
       * @static
       * @memberOf _
       * @since 3.3.0
       * @category Number
       * @param {number} number The number to check.
       * @param {number} [start=0] The start of the range.
       * @param {number} end The end of the range.
       * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
       * @see _.range, _.rangeRight
       * @example
       *
       * _.inRange(3, 2, 4);
       * // => true
       *
       * _.inRange(4, 8);
       * // => true
       *
       * _.inRange(4, 2);
       * // => false
       *
       * _.inRange(2, 2);
       * // => false
       *
       * _.inRange(1.2, 2);
       * // => true
       *
       * _.inRange(5.2, 4);
       * // => false
       *
       * _.inRange(-3, -2, -6);
       * // => true
       */function inRange(number,start,end){start=toFinite(start);if(end===undefined$1){end=start;start=0;}else {end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
       * Produces a random number between the inclusive `lower` and `upper` bounds.
       * If only one argument is provided a number between `0` and the given number
       * is returned. If `floating` is `true`, or either `lower` or `upper` are
       * floats, a floating-point number is returned instead of an integer.
       *
       * **Note:** JavaScript follows the IEEE-754 standard for resolving
       * floating-point values which can produce unexpected results.
       *
       * @static
       * @memberOf _
       * @since 0.7.0
       * @category Number
       * @param {number} [lower=0] The lower bound.
       * @param {number} [upper=1] The upper bound.
       * @param {boolean} [floating] Specify returning a floating-point number.
       * @returns {number} Returns the random number.
       * @example
       *
       * _.random(0, 5);
       * // => an integer between 0 and 5
       *
       * _.random(5);
       * // => also an integer between 0 and 5
       *
       * _.random(5, true);
       * // => a floating-point number between 0 and 5
       *
       * _.random(1.2, 5.2);
       * // => a floating-point number between 1.2 and 5.2
       */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined$1;}if(floating===undefined$1){if(typeof upper=='boolean'){floating=upper;upper=undefined$1;}else if(typeof lower=='boolean'){floating=lower;lower=undefined$1;}}if(lower===undefined$1&&upper===undefined$1){lower=0;upper=1;}else {lower=toFinite(lower);if(upper===undefined$1){upper=lower;lower=0;}else {upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*/ /**
       * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the camel cased string.
       * @example
       *
       * _.camelCase('Foo Bar');
       * // => 'fooBar'
       *
       * _.camelCase('--foo-bar--');
       * // => 'fooBar'
       *
       * _.camelCase('__FOO_BAR__');
       * // => 'fooBar'
       */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * _.capitalize('FRED');
       * // => 'Fred'
       */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
       * Deburrs `string` by converting
       * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
       * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
       * letters to basic Latin letters and removing
       * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to deburr.
       * @returns {string} Returns the deburred string.
       * @example
       *
       * _.deburr('déjà vu');
       * // => 'deja vu'
       */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
       * Checks if `string` ends with the given target string.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to inspect.
       * @param {string} [target] The string to search for.
       * @param {number} [position=string.length] The position to search up to.
       * @returns {boolean} Returns `true` if `string` ends with `target`,
       *  else `false`.
       * @example
       *
       * _.endsWith('abc', 'c');
       * // => true
       *
       * _.endsWith('abc', 'b');
       * // => false
       *
       * _.endsWith('abc', 'b', 2);
       * // => true
       */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined$1?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
       * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
       * corresponding HTML entities.
       *
       * **Note:** No other characters are escaped. To escape additional
       * characters use a third-party library like [_he_](https://mths.be/he).
       *
       * Though the ">" character is escaped for symmetry, characters like
       * ">" and "/" don't need escaping in HTML and have no special meaning
       * unless they're part of a tag or unquoted attribute value. See
       * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
       * (under "semi-related fun fact") for more details.
       *
       * When working with HTML you should always
       * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
       * XSS vectors.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to escape.
       * @returns {string} Returns the escaped string.
       * @example
       *
       * _.escape('fred, barney, & pebbles');
       * // => 'fred, barney, &amp; pebbles'
       */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
       * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
       * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to escape.
       * @returns {string} Returns the escaped string.
       * @example
       *
       * _.escapeRegExp('[lodash](https://lodash.com/)');
       * // => '\[lodash\]\(https://lodash\.com/\)'
       */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
       * Converts `string` to
       * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the kebab cased string.
       * @example
       *
       * _.kebabCase('Foo Bar');
       * // => 'foo-bar'
       *
       * _.kebabCase('fooBar');
       * // => 'foo-bar'
       *
       * _.kebabCase('__FOO_BAR__');
       * // => 'foo-bar'
       */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
       * Converts `string`, as space separated words, to lower case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the lower cased string.
       * @example
       *
       * _.lowerCase('--Foo-Bar--');
       * // => 'foo bar'
       *
       * _.lowerCase('fooBar');
       * // => 'foo bar'
       *
       * _.lowerCase('__FOO_BAR__');
       * // => 'foo bar'
       */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
       * Converts the first character of `string` to lower case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.lowerFirst('Fred');
       * // => 'fred'
       *
       * _.lowerFirst('FRED');
       * // => 'fRED'
       */var lowerFirst=createCaseFirst('toLowerCase');/**
       * Pads `string` on the left and right sides if it's shorter than `length`.
       * Padding characters are truncated if they can't be evenly divided by `length`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to pad.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padded string.
       * @example
       *
       * _.pad('abc', 8);
       * // => '  abc   '
       *
       * _.pad('abc', 8, '_-');
       * // => '_-abc_-_'
       *
       * _.pad('abc', 3);
       * // => 'abc'
       */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
       * Pads `string` on the right side if it's shorter than `length`. Padding
       * characters are truncated if they exceed `length`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to pad.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padded string.
       * @example
       *
       * _.padEnd('abc', 6);
       * // => 'abc   '
       *
       * _.padEnd('abc', 6, '_-');
       * // => 'abc_-_'
       *
       * _.padEnd('abc', 3);
       * // => 'abc'
       */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
       * Pads `string` on the left side if it's shorter than `length`. Padding
       * characters are truncated if they exceed `length`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to pad.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padded string.
       * @example
       *
       * _.padStart('abc', 6);
       * // => '   abc'
       *
       * _.padStart('abc', 6, '_-');
       * // => '_-_abc'
       *
       * _.padStart('abc', 3);
       * // => 'abc'
       */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
       * Converts `string` to an integer of the specified radix. If `radix` is
       * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
       * hexadecimal, in which case a `radix` of `16` is used.
       *
       * **Note:** This method aligns with the
       * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category String
       * @param {string} string The string to convert.
       * @param {number} [radix=10] The radix to interpret `value` by.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.parseInt('08');
       * // => 8
       *
       * _.map(['6', '08', '10'], _.parseInt);
       * // => [6, 8, 10]
       */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
       * Repeats the given string `n` times.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to repeat.
       * @param {number} [n=1] The number of times to repeat the string.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the repeated string.
       * @example
       *
       * _.repeat('*', 3);
       * // => '***'
       *
       * _.repeat('abc', 2);
       * // => 'abcabc'
       *
       * _.repeat('abc', 0);
       * // => ''
       */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined$1){n=1;}else {n=toInteger(n);}return baseRepeat(toString(string),n);}/**
       * Replaces matches for `pattern` in `string` with `replacement`.
       *
       * **Note:** This method is based on
       * [`String#replace`](https://mdn.io/String/replace).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to modify.
       * @param {RegExp|string} pattern The pattern to replace.
       * @param {Function|string} replacement The match replacement.
       * @returns {string} Returns the modified string.
       * @example
       *
       * _.replace('Hi Fred', 'Fred', 'Barney');
       * // => 'Hi Barney'
       */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
       * Converts `string` to
       * [snake case](https://en.wikipedia.org/wiki/Snake_case).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the snake cased string.
       * @example
       *
       * _.snakeCase('Foo Bar');
       * // => 'foo_bar'
       *
       * _.snakeCase('fooBar');
       * // => 'foo_bar'
       *
       * _.snakeCase('--FOO-BAR--');
       * // => 'foo_bar'
       */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
       * Splits `string` by `separator`.
       *
       * **Note:** This method is based on
       * [`String#split`](https://mdn.io/String/split).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to split.
       * @param {RegExp|string} separator The separator pattern to split by.
       * @param {number} [limit] The length to truncate results to.
       * @returns {Array} Returns the string segments.
       * @example
       *
       * _.split('a-b-c', '-', 2);
       * // => ['a', 'b']
       */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined$1;}limit=limit===undefined$1?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return [];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
       * Converts `string` to
       * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
       *
       * @static
       * @memberOf _
       * @since 3.1.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the start cased string.
       * @example
       *
       * _.startCase('--foo-bar--');
       * // => 'Foo Bar'
       *
       * _.startCase('fooBar');
       * // => 'Foo Bar'
       *
       * _.startCase('__FOO_BAR__');
       * // => 'FOO BAR'
       */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
       * Checks if `string` starts with the given target string.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to inspect.
       * @param {string} [target] The string to search for.
       * @param {number} [position=0] The position to search from.
       * @returns {boolean} Returns `true` if `string` starts with `target`,
       *  else `false`.
       * @example
       *
       * _.startsWith('abc', 'a');
       * // => true
       *
       * _.startsWith('abc', 'b');
       * // => false
       *
       * _.startsWith('abc', 'b', 1);
       * // => true
       */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
       * Creates a compiled template function that can interpolate data properties
       * in "interpolate" delimiters, HTML-escape interpolated data properties in
       * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
       * properties may be accessed as free variables in the template. If a setting
       * object is given, it takes precedence over `_.templateSettings` values.
       *
       * **Note:** In the development build `_.template` utilizes
       * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
       * for easier debugging.
       *
       * For more information on precompiling templates see
       * [lodash's custom builds documentation](https://lodash.com/custom-builds).
       *
       * For more information on Chrome extension sandboxes see
       * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category String
       * @param {string} [string=''] The template string.
       * @param {Object} [options={}] The options object.
       * @param {RegExp} [options.escape=_.templateSettings.escape]
       *  The HTML "escape" delimiter.
       * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
       *  The "evaluate" delimiter.
       * @param {Object} [options.imports=_.templateSettings.imports]
       *  An object to import into the template as free variables.
       * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
       *  The "interpolate" delimiter.
       * @param {string} [options.sourceURL='lodash.templateSources[n]']
       *  The sourceURL of the compiled template.
       * @param {string} [options.variable='obj']
       *  The data object variable name.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the compiled template function.
       * @example
       *
       * // Use the "interpolate" delimiter to create a compiled template.
       * var compiled = _.template('hello <%= user %>!');
       * compiled({ 'user': 'fred' });
       * // => 'hello fred!'
       *
       * // Use the HTML "escape" delimiter to escape data property values.
       * var compiled = _.template('<b><%- value %></b>');
       * compiled({ 'value': '<script>' });
       * // => '<b>&lt;script&gt;</b>'
       *
       * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
       * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
       * compiled({ 'users': ['fred', 'barney'] });
       * // => '<li>fred</li><li>barney</li>'
       *
       * // Use the internal `print` function in "evaluate" delimiters.
       * var compiled = _.template('<% print("hello " + user); %>!');
       * compiled({ 'user': 'barney' });
       * // => 'hello barney!'
       *
       * // Use the ES template literal delimiter as an "interpolate" delimiter.
       * // Disable support by replacing the "interpolate" delimiter.
       * var compiled = _.template('hello ${ user }!');
       * compiled({ 'user': 'pebbles' });
       * // => 'hello pebbles!'
       *
       * // Use backslashes to treat delimiters as plain text.
       * var compiled = _.template('<%= "\\<%- value %\\>" %>');
       * compiled({ 'value': 'ignored' });
       * // => '<%- value %>'
       *
       * // Use the `imports` option to import `jQuery` as `jq`.
       * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
       * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
       * compiled({ 'users': ['fred', 'barney'] });
       * // => '<li>fred</li><li>barney</li>'
       *
       * // Use the `sourceURL` option to specify a custom sourceURL for the template.
       * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
       * compiled(data);
       * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
       *
       * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
       * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
       * compiled.source;
       * // => function(data) {
       * //   var __t, __p = '';
       * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
       * //   return __p;
       * // }
       *
       * // Use custom template delimiters.
       * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
       * var compiled = _.template('hello {{ user }}!');
       * compiled({ 'user': 'mustache' });
       * // => 'hello mustache!'
       *
       * // Use the `source` property to inline compiled templates for meaningful
       * // line numbers in error messages and stack traces.
       * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
       *   var JST = {\
       *     "main": ' + _.template(mainText).source + '\
       *   };\
       * ');
       */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined$1;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
  var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
  // The sourceURL gets injected into the source that's eval-ed, so be careful
  // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
  // and escape the comment, thus injecting code that gets evaled.
  var sourceURL='//# sourceURL='+(hasOwnProperty.call(options,'sourceURL')?(options.sourceURL+'').replace(/\s/g,' '):'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
  source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
  if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
  // order to produce the correct `offset` value.
  return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  var variable=hasOwnProperty.call(options,'variable')&&options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Throw an error if a forbidden character was found in `variable`, to prevent
  // potential command injection attacks.
  else if(reForbiddenIdentifierChars.test(variable)){throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);}// Cleanup code by stripping empty strings.
  source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
  source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined$1,importsValues);});// Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.
  result.source=source;if(isError(result)){throw result;}return result;}/**
       * Converts `string`, as a whole, to lower case just like
       * [String#toLowerCase](https://mdn.io/toLowerCase).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the lower cased string.
       * @example
       *
       * _.toLower('--Foo-Bar--');
       * // => '--foo-bar--'
       *
       * _.toLower('fooBar');
       * // => 'foobar'
       *
       * _.toLower('__FOO_BAR__');
       * // => '__foo_bar__'
       */function toLower(value){return toString(value).toLowerCase();}/**
       * Converts `string`, as a whole, to upper case just like
       * [String#toUpperCase](https://mdn.io/toUpperCase).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the upper cased string.
       * @example
       *
       * _.toUpper('--foo-bar--');
       * // => '--FOO-BAR--'
       *
       * _.toUpper('fooBar');
       * // => 'FOOBAR'
       *
       * _.toUpper('__foo_bar__');
       * // => '__FOO_BAR__'
       */function toUpper(value){return toString(value).toUpperCase();}/**
       * Removes leading and trailing whitespace or specified characters from `string`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * _.trim('  abc  ');
       * // => 'abc'
       *
       * _.trim('-_-abc-_-', '_-');
       * // => 'abc'
       *
       * _.map(['  foo  ', '  bar  '], _.trim);
       * // => ['foo', 'bar']
       */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return baseTrim(string);}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * _.trimEnd('  abc  ');
       * // => '  abc'
       *
       * _.trimEnd('-_-abc-_-', '_-');
       * // => '-_-abc'
       */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return string.slice(0,trimmedEndIndex(string)+1);}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
       * Removes leading whitespace or specified characters from `string`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * _.trimStart('  abc  ');
       * // => 'abc  '
       *
       * _.trimStart('-_-abc-_-', '_-');
       * // => 'abc-_-'
       */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
       * Truncates `string` if it's longer than the given maximum string length.
       * The last characters of the truncated string are replaced with the omission
       * string which defaults to "...".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to truncate.
       * @param {Object} [options={}] The options object.
       * @param {number} [options.length=30] The maximum string length.
       * @param {string} [options.omission='...'] The string to indicate text is omitted.
       * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
       * @returns {string} Returns the truncated string.
       * @example
       *
       * _.truncate('hi-diddly-ho there, neighborino');
       * // => 'hi-diddly-ho there, neighbo...'
       *
       * _.truncate('hi-diddly-ho there, neighborino', {
       *   'length': 24,
       *   'separator': ' '
       * });
       * // => 'hi-diddly-ho there,...'
       *
       * _.truncate('hi-diddly-ho there, neighborino', {
       *   'length': 24,
       *   'separator': /,? +/
       * });
       * // => 'hi-diddly-ho there...'
       *
       * _.truncate('hi-diddly-ho there, neighborino', {
       *   'omission': ' [...]'
       * });
       * // => 'hi-diddly-ho there, neig [...]'
       */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined$1){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined$1?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
       * The inverse of `_.escape`; this method converts the HTML entities
       * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
       * their corresponding characters.
       *
       * **Note:** No other HTML entities are unescaped. To unescape additional
       * HTML entities use a third-party library like [_he_](https://mths.be/he).
       *
       * @static
       * @memberOf _
       * @since 0.6.0
       * @category String
       * @param {string} [string=''] The string to unescape.
       * @returns {string} Returns the unescaped string.
       * @example
       *
       * _.unescape('fred, barney, &amp; pebbles');
       * // => 'fred, barney, & pebbles'
       */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
       * Converts `string`, as space separated words, to upper case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the upper cased string.
       * @example
       *
       * _.upperCase('--foo-bar');
       * // => 'FOO BAR'
       *
       * _.upperCase('fooBar');
       * // => 'FOO BAR'
       *
       * _.upperCase('__foo_bar__');
       * // => 'FOO BAR'
       */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
       * Converts the first character of `string` to upper case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.upperFirst('fred');
       * // => 'Fred'
       *
       * _.upperFirst('FRED');
       * // => 'FRED'
       */var upperFirst=createCaseFirst('toUpperCase');/**
       * Splits `string` into an array of its words.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to inspect.
       * @param {RegExp|string} [pattern] The pattern to match words.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the words of `string`.
       * @example
       *
       * _.words('fred, barney, & pebbles');
       * // => ['fred', 'barney', 'pebbles']
       *
       * _.words('fred, barney, & pebbles', /[^, ]+/g);
       * // => ['fred', 'barney', '&', 'pebbles']
       */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined$1:pattern;if(pattern===undefined$1){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*/ /**
       * Attempts to invoke `func`, returning either the result or the caught error
       * object. Any additional arguments are provided to `func` when it's invoked.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {Function} func The function to attempt.
       * @param {...*} [args] The arguments to invoke `func` with.
       * @returns {*} Returns the `func` result or error object.
       * @example
       *
       * // Avoid throwing errors for invalid selectors.
       * var elements = _.attempt(function(selector) {
       *   return document.querySelectorAll(selector);
       * }, '>_>');
       *
       * if (_.isError(elements)) {
       *   elements = [];
       * }
       */var attempt=baseRest(function(func,args){try{return apply(func,undefined$1,args);}catch(e){return isError(e)?e:new Error(e);}});/**
       * Binds methods of an object to the object itself, overwriting the existing
       * method.
       *
       * **Note:** This method doesn't set the "length" property of bound functions.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {Object} object The object to bind and assign the bound methods to.
       * @param {...(string|string[])} methodNames The object method names to bind.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var view = {
       *   'label': 'docs',
       *   'click': function() {
       *     console.log('clicked ' + this.label);
       *   }
       * };
       *
       * _.bindAll(view, ['click']);
       * jQuery(element).on('click', view.click);
       * // => Logs 'clicked docs' when clicked.
       */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
       * Creates a function that iterates over `pairs` and invokes the corresponding
       * function of the first predicate to return truthy. The predicate-function
       * pairs are invoked with the `this` binding and arguments of the created
       * function.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {Array} pairs The predicate-function pairs.
       * @returns {Function} Returns the new composite function.
       * @example
       *
       * var func = _.cond([
       *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
       *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
       *   [_.stubTrue,                      _.constant('no match')]
       * ]);
       *
       * func({ 'a': 1, 'b': 2 });
       * // => 'matches A'
       *
       * func({ 'a': 0, 'b': 1 });
       * // => 'matches B'
       *
       * func({ 'a': '1', 'b': '2' });
       * // => 'no match'
       */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return [toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
       * Creates a function that invokes the predicate properties of `source` with
       * the corresponding property values of a given object, returning `true` if
       * all predicates return truthy, else `false`.
       *
       * **Note:** The created function is equivalent to `_.conformsTo` with
       * `source` partially applied.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {Object} source The object of property predicates to conform to.
       * @returns {Function} Returns the new spec function.
       * @example
       *
       * var objects = [
       *   { 'a': 2, 'b': 1 },
       *   { 'a': 1, 'b': 2 }
       * ];
       *
       * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
       * // => [{ 'a': 1, 'b': 2 }]
       */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
       * Creates a function that returns `value`.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Util
       * @param {*} value The value to return from the new function.
       * @returns {Function} Returns the new constant function.
       * @example
       *
       * var objects = _.times(2, _.constant({ 'a': 1 }));
       *
       * console.log(objects);
       * // => [{ 'a': 1 }, { 'a': 1 }]
       *
       * console.log(objects[0] === objects[1]);
       * // => true
       */function constant(value){return function(){return value;};}/**
       * Checks `value` to determine whether a default value should be returned in
       * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
       * or `undefined`.
       *
       * @static
       * @memberOf _
       * @since 4.14.0
       * @category Util
       * @param {*} value The value to check.
       * @param {*} defaultValue The default value.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * _.defaultTo(1, 10);
       * // => 1
       *
       * _.defaultTo(undefined, 10);
       * // => 10
       */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
       * Creates a function that returns the result of invoking the given functions
       * with the `this` binding of the created function, where each successive
       * invocation is supplied the return value of the previous.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {...(Function|Function[])} [funcs] The functions to invoke.
       * @returns {Function} Returns the new composite function.
       * @see _.flowRight
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var addSquare = _.flow([_.add, square]);
       * addSquare(1, 2);
       * // => 9
       */var flow=createFlow();/**
       * This method is like `_.flow` except that it creates a function that
       * invokes the given functions from right to left.
       *
       * @static
       * @since 3.0.0
       * @memberOf _
       * @category Util
       * @param {...(Function|Function[])} [funcs] The functions to invoke.
       * @returns {Function} Returns the new composite function.
       * @see _.flow
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var addSquare = _.flowRight([square, _.add]);
       * addSquare(1, 2);
       * // => 9
       */var flowRight=createFlow(true);/**
       * This method returns the first argument it receives.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {*} value Any value.
       * @returns {*} Returns `value`.
       * @example
       *
       * var object = { 'a': 1 };
       *
       * console.log(_.identity(object) === object);
       * // => true
       */function identity(value){return value;}/**
       * Creates a function that invokes `func` with the arguments of the created
       * function. If `func` is a property name, the created function returns the
       * property value for a given element. If `func` is an array or object, the
       * created function returns `true` for elements that contain the equivalent
       * source properties, otherwise it returns `false`.
       *
       * @static
       * @since 4.0.0
       * @memberOf _
       * @category Util
       * @param {*} [func=_.identity] The value to convert to a callback.
       * @returns {Function} Returns the callback.
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': true },
       *   { 'user': 'fred',   'age': 40, 'active': false }
       * ];
       *
       * // The `_.matches` iteratee shorthand.
       * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
       * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.filter(users, _.iteratee(['user', 'fred']));
       * // => [{ 'user': 'fred', 'age': 40 }]
       *
       * // The `_.property` iteratee shorthand.
       * _.map(users, _.iteratee('user'));
       * // => ['barney', 'fred']
       *
       * // Create custom iteratee shorthands.
       * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
       *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
       *     return func.test(string);
       *   };
       * });
       *
       * _.filter(['abc', 'def'], /ef/);
       * // => ['def']
       */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
       * Creates a function that performs a partial deep comparison between a given
       * object and `source`, returning `true` if the given object has equivalent
       * property values, else `false`.
       *
       * **Note:** The created function is equivalent to `_.isMatch` with `source`
       * partially applied.
       *
       * Partial comparisons will match empty array and empty object `source`
       * values against any array or object value, respectively. See `_.isEqual`
       * for a list of supported value comparisons.
       *
       * **Note:** Multiple values can be checked by combining several matchers
       * using `_.overSome`
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {Object} source The object of property values to match.
       * @returns {Function} Returns the new spec function.
       * @example
       *
       * var objects = [
       *   { 'a': 1, 'b': 2, 'c': 3 },
       *   { 'a': 4, 'b': 5, 'c': 6 }
       * ];
       *
       * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
       * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
       *
       * // Checking for several possible values
       * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
       * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
       */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
       * Creates a function that performs a partial deep comparison between the
       * value at `path` of a given object to `srcValue`, returning `true` if the
       * object value is equivalent, else `false`.
       *
       * **Note:** Partial comparisons will match empty array and empty object
       * `srcValue` values against any array or object value, respectively. See
       * `_.isEqual` for a list of supported value comparisons.
       *
       * **Note:** Multiple values can be checked by combining several matchers
       * using `_.overSome`
       *
       * @static
       * @memberOf _
       * @since 3.2.0
       * @category Util
       * @param {Array|string} path The path of the property to get.
       * @param {*} srcValue The value to match.
       * @returns {Function} Returns the new spec function.
       * @example
       *
       * var objects = [
       *   { 'a': 1, 'b': 2, 'c': 3 },
       *   { 'a': 4, 'b': 5, 'c': 6 }
       * ];
       *
       * _.find(objects, _.matchesProperty('a', 4));
       * // => { 'a': 4, 'b': 5, 'c': 6 }
       *
       * // Checking for several possible values
       * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
       * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
       */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
       * Creates a function that invokes the method at `path` of a given object.
       * Any additional arguments are provided to the invoked method.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Util
       * @param {Array|string} path The path of the method to invoke.
       * @param {...*} [args] The arguments to invoke the method with.
       * @returns {Function} Returns the new invoker function.
       * @example
       *
       * var objects = [
       *   { 'a': { 'b': _.constant(2) } },
       *   { 'a': { 'b': _.constant(1) } }
       * ];
       *
       * _.map(objects, _.method('a.b'));
       * // => [2, 1]
       *
       * _.map(objects, _.method(['a', 'b']));
       * // => [2, 1]
       */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
       * The opposite of `_.method`; this method creates a function that invokes
       * the method at a given path of `object`. Any additional arguments are
       * provided to the invoked method.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Util
       * @param {Object} object The object to query.
       * @param {...*} [args] The arguments to invoke the method with.
       * @returns {Function} Returns the new invoker function.
       * @example
       *
       * var array = _.times(3, _.constant),
       *     object = { 'a': array, 'b': array, 'c': array };
       *
       * _.map(['a[2]', 'c[0]'], _.methodOf(object));
       * // => [2, 0]
       *
       * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
       * // => [2, 0]
       */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
       * Adds all own enumerable string keyed function properties of a source
       * object to the destination object. If `object` is a function, then methods
       * are added to its prototype as well.
       *
       * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
       * avoid conflicts caused by modifying the original.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {Function|Object} [object=lodash] The destination object.
       * @param {Object} source The object of functions to add.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
       * @returns {Function|Object} Returns `object`.
       * @example
       *
       * function vowels(string) {
       *   return _.filter(string, function(v) {
       *     return /[aeiou]/i.test(v);
       *   });
       * }
       *
       * _.mixin({ 'vowels': vowels });
       * _.vowels('fred');
       * // => ['e']
       *
       * _('fred').vowels().value();
       * // => ['e']
       *
       * _.mixin({ 'vowels': vowels }, { 'chain': false });
       * _('fred').vowels();
       * // => ['e']
       */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
       * Reverts the `_` variable to its previous value and returns a reference to
       * the `lodash` function.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @returns {Function} Returns the `lodash` function.
       * @example
       *
       * var lodash = _.noConflict();
       */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
       * This method returns `undefined`.
       *
       * @static
       * @memberOf _
       * @since 2.3.0
       * @category Util
       * @example
       *
       * _.times(2, _.noop);
       * // => [undefined, undefined]
       */function noop(){// No operation performed.
  }/**
       * Creates a function that gets the argument at index `n`. If `n` is negative,
       * the nth argument from the end is returned.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {number} [n=0] The index of the argument to return.
       * @returns {Function} Returns the new pass-thru function.
       * @example
       *
       * var func = _.nthArg(1);
       * func('a', 'b', 'c', 'd');
       * // => 'b'
       *
       * var func = _.nthArg(-2);
       * func('a', 'b', 'c', 'd');
       * // => 'c'
       */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
       * Creates a function that invokes `iteratees` with the arguments it receives
       * and returns their results.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {...(Function|Function[])} [iteratees=[_.identity]]
       *  The iteratees to invoke.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var func = _.over([Math.max, Math.min]);
       *
       * func(1, 2, 3, 4);
       * // => [4, 1]
       */var over=createOver(arrayMap);/**
       * Creates a function that checks if **all** of the `predicates` return
       * truthy when invoked with the arguments it receives.
       *
       * Following shorthands are possible for providing predicates.
       * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
       * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {...(Function|Function[])} [predicates=[_.identity]]
       *  The predicates to check.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var func = _.overEvery([Boolean, isFinite]);
       *
       * func('1');
       * // => true
       *
       * func(null);
       * // => false
       *
       * func(NaN);
       * // => false
       */var overEvery=createOver(arrayEvery);/**
       * Creates a function that checks if **any** of the `predicates` return
       * truthy when invoked with the arguments it receives.
       *
       * Following shorthands are possible for providing predicates.
       * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
       * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {...(Function|Function[])} [predicates=[_.identity]]
       *  The predicates to check.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var func = _.overSome([Boolean, isFinite]);
       *
       * func('1');
       * // => true
       *
       * func(null);
       * // => true
       *
       * func(NaN);
       * // => false
       *
       * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
       * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
       */var overSome=createOver(arraySome);/**
       * Creates a function that returns the value at `path` of a given object.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Util
       * @param {Array|string} path The path of the property to get.
       * @returns {Function} Returns the new accessor function.
       * @example
       *
       * var objects = [
       *   { 'a': { 'b': 2 } },
       *   { 'a': { 'b': 1 } }
       * ];
       *
       * _.map(objects, _.property('a.b'));
       * // => [2, 1]
       *
       * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
       * // => [1, 2]
       */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
       * The opposite of `_.property`; this method creates a function that returns
       * the value at a given path of `object`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {Object} object The object to query.
       * @returns {Function} Returns the new accessor function.
       * @example
       *
       * var array = [0, 1, 2],
       *     object = { 'a': array, 'b': array, 'c': array };
       *
       * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
       * // => [2, 0]
       *
       * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
       * // => [2, 0]
       */function propertyOf(object){return function(path){return object==null?undefined$1:baseGet(object,path);};}/**
       * Creates an array of numbers (positive and/or negative) progressing from
       * `start` up to, but not including, `end`. A step of `-1` is used if a negative
       * `start` is specified without an `end` or `step`. If `end` is not specified,
       * it's set to `start` with `start` then set to `0`.
       *
       * **Note:** JavaScript follows the IEEE-754 standard for resolving
       * floating-point values which can produce unexpected results.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {number} [start=0] The start of the range.
       * @param {number} end The end of the range.
       * @param {number} [step=1] The value to increment or decrement by.
       * @returns {Array} Returns the range of numbers.
       * @see _.inRange, _.rangeRight
       * @example
       *
       * _.range(4);
       * // => [0, 1, 2, 3]
       *
       * _.range(-4);
       * // => [0, -1, -2, -3]
       *
       * _.range(1, 5);
       * // => [1, 2, 3, 4]
       *
       * _.range(0, 20, 5);
       * // => [0, 5, 10, 15]
       *
       * _.range(0, -4, -1);
       * // => [0, -1, -2, -3]
       *
       * _.range(1, 4, 0);
       * // => [1, 1, 1]
       *
       * _.range(0);
       * // => []
       */var range=createRange();/**
       * This method is like `_.range` except that it populates values in
       * descending order.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {number} [start=0] The start of the range.
       * @param {number} end The end of the range.
       * @param {number} [step=1] The value to increment or decrement by.
       * @returns {Array} Returns the range of numbers.
       * @see _.inRange, _.range
       * @example
       *
       * _.rangeRight(4);
       * // => [3, 2, 1, 0]
       *
       * _.rangeRight(-4);
       * // => [-3, -2, -1, 0]
       *
       * _.rangeRight(1, 5);
       * // => [4, 3, 2, 1]
       *
       * _.rangeRight(0, 20, 5);
       * // => [15, 10, 5, 0]
       *
       * _.rangeRight(0, -4, -1);
       * // => [-3, -2, -1, 0]
       *
       * _.rangeRight(1, 4, 0);
       * // => [1, 1, 1]
       *
       * _.rangeRight(0);
       * // => []
       */var rangeRight=createRange(true);/**
       * This method returns a new empty array.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {Array} Returns the new empty array.
       * @example
       *
       * var arrays = _.times(2, _.stubArray);
       *
       * console.log(arrays);
       * // => [[], []]
       *
       * console.log(arrays[0] === arrays[1]);
       * // => false
       */function stubArray(){return [];}/**
       * This method returns `false`.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {boolean} Returns `false`.
       * @example
       *
       * _.times(2, _.stubFalse);
       * // => [false, false]
       */function stubFalse(){return false;}/**
       * This method returns a new empty object.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {Object} Returns the new empty object.
       * @example
       *
       * var objects = _.times(2, _.stubObject);
       *
       * console.log(objects);
       * // => [{}, {}]
       *
       * console.log(objects[0] === objects[1]);
       * // => false
       */function stubObject(){return {};}/**
       * This method returns an empty string.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {string} Returns the empty string.
       * @example
       *
       * _.times(2, _.stubString);
       * // => ['', '']
       */function stubString(){return '';}/**
       * This method returns `true`.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {boolean} Returns `true`.
       * @example
       *
       * _.times(2, _.stubTrue);
       * // => [true, true]
       */function stubTrue(){return true;}/**
       * Invokes the iteratee `n` times, returning an array of the results of
       * each invocation. The iteratee is invoked with one argument; (index).
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {number} n The number of times to invoke `iteratee`.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the array of results.
       * @example
       *
       * _.times(3, String);
       * // => ['0', '1', '2']
       *
       *  _.times(4, _.constant(0));
       * // => [0, 0, 0, 0]
       */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return [];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
       * Converts `value` to a property path array.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {*} value The value to convert.
       * @returns {Array} Returns the new property path array.
       * @example
       *
       * _.toPath('a.b.c');
       * // => ['a', 'b', 'c']
       *
       * _.toPath('a[0].b.c');
       * // => ['a', '0', 'b', 'c']
       */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
       * Generates a unique ID. If `prefix` is given, the ID is appended to it.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {string} [prefix=''] The value to prefix the ID with.
       * @returns {string} Returns the unique ID.
       * @example
       *
       * _.uniqueId('contact_');
       * // => 'contact_104'
       *
       * _.uniqueId();
       * // => '105'
       */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*/ /**
       * Adds two numbers.
       *
       * @static
       * @memberOf _
       * @since 3.4.0
       * @category Math
       * @param {number} augend The first number in an addition.
       * @param {number} addend The second number in an addition.
       * @returns {number} Returns the total.
       * @example
       *
       * _.add(6, 4);
       * // => 10
       */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
       * Computes `number` rounded up to `precision`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Math
       * @param {number} number The number to round up.
       * @param {number} [precision=0] The precision to round up to.
       * @returns {number} Returns the rounded up number.
       * @example
       *
       * _.ceil(4.006);
       * // => 5
       *
       * _.ceil(6.004, 2);
       * // => 6.01
       *
       * _.ceil(6040, -2);
       * // => 6100
       */var ceil=createRound('ceil');/**
       * Divide two numbers.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Math
       * @param {number} dividend The first number in a division.
       * @param {number} divisor The second number in a division.
       * @returns {number} Returns the quotient.
       * @example
       *
       * _.divide(6, 4);
       * // => 1.5
       */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
       * Computes `number` rounded down to `precision`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Math
       * @param {number} number The number to round down.
       * @param {number} [precision=0] The precision to round down to.
       * @returns {number} Returns the rounded down number.
       * @example
       *
       * _.floor(4.006);
       * // => 4
       *
       * _.floor(0.046, 2);
       * // => 0.04
       *
       * _.floor(4060, -2);
       * // => 4000
       */var floor=createRound('floor');/**
       * Computes the maximum value of `array`. If `array` is empty or falsey,
       * `undefined` is returned.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {*} Returns the maximum value.
       * @example
       *
       * _.max([4, 2, 8, 6]);
       * // => 8
       *
       * _.max([]);
       * // => undefined
       */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined$1;}/**
       * This method is like `_.max` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the criterion by which
       * the value is ranked. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {*} Returns the maximum value.
       * @example
       *
       * var objects = [{ 'n': 1 }, { 'n': 2 }];
       *
       * _.maxBy(objects, function(o) { return o.n; });
       * // => { 'n': 2 }
       *
       * // The `_.property` iteratee shorthand.
       * _.maxBy(objects, 'n');
       * // => { 'n': 2 }
       */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined$1;}/**
       * Computes the mean of the values in `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {number} Returns the mean.
       * @example
       *
       * _.mean([4, 2, 8, 6]);
       * // => 5
       */function mean(array){return baseMean(array,identity);}/**
       * This method is like `_.mean` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the value to be averaged.
       * The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the mean.
       * @example
       *
       * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
       *
       * _.meanBy(objects, function(o) { return o.n; });
       * // => 5
       *
       * // The `_.property` iteratee shorthand.
       * _.meanBy(objects, 'n');
       * // => 5
       */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
       * Computes the minimum value of `array`. If `array` is empty or falsey,
       * `undefined` is returned.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {*} Returns the minimum value.
       * @example
       *
       * _.min([4, 2, 8, 6]);
       * // => 2
       *
       * _.min([]);
       * // => undefined
       */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined$1;}/**
       * This method is like `_.min` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the criterion by which
       * the value is ranked. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {*} Returns the minimum value.
       * @example
       *
       * var objects = [{ 'n': 1 }, { 'n': 2 }];
       *
       * _.minBy(objects, function(o) { return o.n; });
       * // => { 'n': 1 }
       *
       * // The `_.property` iteratee shorthand.
       * _.minBy(objects, 'n');
       * // => { 'n': 1 }
       */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined$1;}/**
       * Multiply two numbers.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Math
       * @param {number} multiplier The first number in a multiplication.
       * @param {number} multiplicand The second number in a multiplication.
       * @returns {number} Returns the product.
       * @example
       *
       * _.multiply(6, 4);
       * // => 24
       */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
       * Computes `number` rounded to `precision`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Math
       * @param {number} number The number to round.
       * @param {number} [precision=0] The precision to round to.
       * @returns {number} Returns the rounded number.
       * @example
       *
       * _.round(4.006);
       * // => 4
       *
       * _.round(4.006, 2);
       * // => 4.01
       *
       * _.round(4060, -2);
       * // => 4100
       */var round=createRound('round');/**
       * Subtract two numbers.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {number} minuend The first number in a subtraction.
       * @param {number} subtrahend The second number in a subtraction.
       * @returns {number} Returns the difference.
       * @example
       *
       * _.subtract(6, 4);
       * // => 2
       */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
       * Computes the sum of the values in `array`.
       *
       * @static
       * @memberOf _
       * @since 3.4.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {number} Returns the sum.
       * @example
       *
       * _.sum([4, 2, 8, 6]);
       * // => 20
       */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
       * This method is like `_.sum` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the value to be summed.
       * The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the sum.
       * @example
       *
       * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
       *
       * _.sumBy(objects, function(o) { return o.n; });
       * // => 20
       *
       * // The `_.property` iteratee shorthand.
       * _.sumBy(objects, 'n');
       * // => 20
       */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences.
  lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
  lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
  mixin(lodash,lodash);/*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences.
  lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
  lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*/ /**
       * The semantic version number.
       *
       * @static
       * @memberOf _
       * @type {string}
       */lodash.VERSION=VERSION;// Assign default placeholders.
  arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
  arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined$1?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else {result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
  arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
  arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
  arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined$1){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
  baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function interceptor(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
  isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined$1});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
  arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
  baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'';if(!hasOwnProperty.call(realNames,key)){realNames[key]=[];}realNames[key].push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined$1,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined$1}];// Add methods to `LazyWrapper`.
  LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
  lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
  lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/ // Export lodash.
  var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
  if(freeModule){// Export for Node.js.
  (freeModule.exports=_)._=_;// Export for CommonJS support.
  freeExports._=_;}else {// Export to the global object.
  root._=_;}}).call(commonjsGlobal);});

  var isDefined$1 = function isDefined(x) {
    return !lodash.isUndefined(x);
  };

  var isNotEmpty = function isNotEmpty(x) {
    return !lodash.isEmpty(x);
  };

  var isNotNull$1 = function isNotNull(x) {
    return x != null;
  };

  var isDefinedAndNotNull$1 = function isDefinedAndNotNull(x) {
    return isDefined$1(x) && isNotNull$1(x);
  };

  var isDefinedAndNotNullAndNotEmpty = function isDefinedAndNotNullAndNotEmpty(x) {
    return isDefined$1(x) && isNotNull$1(x) && isNotEmpty(x);
  };

  var removeUndefinedAndNullValues = function removeUndefinedAndNullValues(obj) {
    return lodash.pickBy(obj, isDefinedAndNotNull$1);
  };

  var pick = function pick(argObj, argArr) {
    return lodash.pick(argObj, argArr);
  };
  /**
   *
   * Convert an array map to hashmap
   * @param  {} arrays [{"from":"prop1","to":"val1"},{"from":"prop2","to":"val2"}]
   * @param  {} fromKey="from"
   * @param  {} toKey="to"
   * @param  {} isLowerCase=true
   * @param  {} return hashmap {"prop1":"val1","prop2:"val2"}
   */


  var getHashFromArray = function getHashFromArray(arrays) {
    var fromKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "from";
    var toKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "to";
    var isLowerCase = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var hashMap = {};

    if (Array.isArray(arrays)) {
      arrays.forEach(function (array) {
        if (!isNotEmpty(array[fromKey])) return;
        hashMap[isLowerCase ? array[fromKey].toLowerCase() : array[fromKey]] = array[toKey];
      });
    }

    return hashMap;
  };
  /**
   * @param  {} timestamp
   * @param  {} return iso format of date
   */


  var toIso = function toIso(timestamp) {
    return new Date(timestamp).toISOString();
  }; // function to flatten a json


  function flattenJson(data) {
    var result = {};
    var l; // a recursive function to loop through the array of the data

    function recurse(cur, prop) {
      var i;

      if (Object(cur) !== cur) {
        result[prop] = cur;
      } else if (Array.isArray(cur)) {
        for (i = 0, l = cur.length; i < l; i += 1) {
          recurse(cur[i], "".concat(prop, "[").concat(i, "]"));
        }

        if (l === 0) {
          result[prop] = [];
        }
      } else {
        var isEmptyFlag = true;
        Object.keys(cur).forEach(function (key) {
          isEmptyFlag = false;
          recurse(cur[key], prop ? "".concat(prop, ".").concat(key) : key);
        });
        if (isEmptyFlag && prop) result[prop] = {};
      }
    }

    recurse(data, "");
    return result;
  }

  var dynamicKeys = [];

  var setDynamicKeys = function setDynamicKeys(dk) {
    dynamicKeys = dk;
  };

  var getDynamicKeys = function getDynamicKeys() {
    return dynamicKeys;
  };

  var config$1;

  var setConfig = function setConfig(c) {
    config$1 = c;
  };

  var getConfig = function getConfig() {
    return config$1;
  };

  var topLevelProperties = ["messageId", "anonymousId", "event"];
  /* eslint-disable camelcase */

  /**
   *
   * @param {} rudderElement
   * Quality of experience tracking includes quality of service (QoS) and error tracking, both are optional elements
   *  and are not required for core media tracking implementations.
   *
   * DOC: https://experienceleague.adobe.com/docs/media-analytics/using/sdk-implement/track-qos/track-qos-overview.html?lang=en
   * DOC: https://experienceleague.adobe.com/docs/media-analytics/using/sdk-implement/track-qos/track-qos-js/track-qos-js.html?lang=en
   */

  var createQos = function createQos(rudderElement) {
    var va = window.ADB.va;
    var properties = rudderElement.message.properties;
    var bitrate = properties.bitrate,
        startupTime = properties.startupTime,
        fps = properties.fps,
        droppedFrames = properties.droppedFrames;
    var qosData = va.MediaHeartbeat.createQoSObject(bitrate || 0, startupTime || 0, fps || 0, droppedFrames || 0);
    return qosData;
  };
  /**
   *
   * @param {*} rudderElement
   * @param {*} mediaObj
   *
   * DOC: https://experienceleague.adobe.com/docs/media-analytics/using/sdk-implement/track-ads/impl-std-ad-metadata/impl-std-ad-md-js/impl-std-ad-metadata-js.html?lang=en
   */


  var standardVideoMetadata = function standardVideoMetadata(rudderElement, mediaObj) {
    var va = window.ADB.va;
    var properties = rudderElement.message.properties;
    var metaKeys = va.MediaHeartbeat.VideoMetadataKeys;
    var SHOW = metaKeys.SHOW,
        SEASON = metaKeys.SEASON,
        EPISODE = metaKeys.EPISODE,
        ASSET_ID = metaKeys.ASSET_ID,
        GENRE = metaKeys.GENRE,
        FIRST_AIR_DATE = metaKeys.FIRST_AIR_DATE,
        ORIGINATOR = metaKeys.ORIGINATOR,
        NETWORK = metaKeys.NETWORK,
        RATING = metaKeys.RATING;
    var stdVidMeta = {};
    var rudderAdbMap = {
      program: SHOW,
      season: SEASON,
      episode: EPISODE,
      assetId: ASSET_ID,
      contentAssetId: ASSET_ID,
      genre: GENRE,
      airdate: FIRST_AIR_DATE,
      publisher: ORIGINATOR,
      channel: NETWORK,
      rating: RATING
    };
    Object.keys(rudderAdbMap).forEach(function (value) {
      stdVidMeta[rudderAdbMap[value]] = properties[value] || "no ".concat(rudderAdbMap[value]);
    });
    mediaObj.setValue(va.MediaHeartbeat.MediaObjectKey.StandardVideoMetadata, stdVidMeta);
  };

  var standardAdMetadata = function standardAdMetadata(rudderElement, adObj) {
    var va = window.ADB.va;
    var properties = rudderElement.message.properties;
    var metaKeys = va.MediaHeartbeat.AdMetadataKeys;
    var stdAdMeta = {};
    var rudderAdbMap = {
      publisher: metaKeys.ADVERTISER
    }; // eslint-disable-next-line

    Object.keys(rudderAdbMap).forEach(function (value) {
      stdAdMeta[rudderAdbMap[value]] = properties[value] || "no ".concat(rudderAdbMap[value]);
    });
    adObj.setValue(va.MediaHeartbeat.MediaObjectKey.StandardAdMetadata, stdAdMeta);
  }; // clear the previously set keys for adobe analytics


  var clearWindowSKeys = function clearWindowSKeys(dk) {
    each_1(function (keys) {
      delete window.s[keys];
    }, dk);
    var presentKeys = dynamicKeys;
    presentKeys.length = 0;
    setDynamicKeys(presentKeys);
  }; // update window keys for adobe analytics


  var updateWindowSKeys = function updateWindowSKeys(value, key) {
    if (isDefinedAndNotNullAndNotEmpty(key)) {
      dynamicKeys.push(key);
      window.s[key] = value;
    }
  }; // update all the keys for adobe analytics which are common for all calls.


  var updateCommonWindowSKeys = function updateCommonWindowSKeys(rudderElement, pageName) {
    var _rudderElement$messag = rudderElement.message,
        properties = _rudderElement$messag.properties,
        type = _rudderElement$messag.type,
        context = _rudderElement$messag.context;
    var campaign;

    if (context && context.campaign) {
      campaign = context.campaign.name;
    } else {
      campaign = properties.campaign;
    }

    var channel = rudderElement.message.channel || properties.channel;
    var zip = context.traits.zip || properties.zip;
    var state = context.traits.state || properties.state;
    updateWindowSKeys(channel, "channel");
    updateWindowSKeys(campaign, "campaign");
    updateWindowSKeys(state, "state");
    updateWindowSKeys(zip, "zip");
    var name = context.page ? context.page.name : undefined;

    if (config$1.trackPageName && type === "track") {
      updateWindowSKeys(properties.pageName || pageName || name, "pageName");
    }
  }; // TODO: Need to check why timestamp not setting
  // DOC: https://experienceleague.adobe.com/docs/analytics/implementation/vars/page-vars/timestamp.html?lang=en


  var calculateTimestamp = function calculateTimestamp(rudderElement) {
    var _rudderElement$messag2 = rudderElement.message,
        properties = _rudderElement$messag2.properties,
        originalTimestamp = _rudderElement$messag2.originalTimestamp,
        timestamp = _rudderElement$messag2.timestamp;
    var timestampVal = originalTimestamp || timestamp || properties.originalTimestamp || properties.timestamp; // The s.timestamp variable is a string containing the date and time of the hit. Valid timestamp formats include ISO 8601 and Unix time.

    if (timestampVal) {
      if (typeof timestampVal !== "string") {
        timestampVal = toIso(timestampVal);
      }

      if (config$1.timestampOption === "hybrid" && !config$1.preferVisitorId || config$1.timestampOption === "enabled") {
        updateWindowSKeys(timestampVal, "timestamp");
      }
    }
  };
  /**
   * @param  {} contextMap { "page.name" : "pName", "page.url": "pUrl"}
   * @param  {} rudderElement
   *  Find page.name, page.url from context/properties of rudder message.
   *  If key is one of anonymousId/userId/messageId it will fetch from message.
   *  If context = {"page": {"name": "Home Page", "url":"https://example.com"},{"path", "/page1"}}
   * @param  {} return a hash map of {"pName": "Home Page", "pUrl": "https://example.com"}
   */


  var getDataFromContext = function getDataFromContext(contextMap, rudderElement) {
    var _rudderElement$messag3 = rudderElement.message,
        context = _rudderElement$messag3.context,
        properties = _rudderElement$messag3.properties;
    var contextDataMap = {};
    Object.keys(contextMap).forEach(function (value) {
      var val;

      if (value) {
        if (topLevelProperties.includes(value)) {
          val = rudderElement.message[value];
        } else {
          val = lodash.get(context, value) ? lodash.get(context, value) : lodash.get(properties, value);
        }

        if (val) {
          contextDataMap[contextMap[value]] = val;
        }
      }
    });
    return contextDataMap;
  };
  /**
   * @param  {} contextDataKey
   * @param  {} contextDataValue
   * Context data variables let you define custom variables on each page that processing rules can read.
   * DOC: https://experienceleague.adobe.com/docs/analytics/implementation/vars/page-vars/contextdata.html?lang=en
   */


  var setContextData = function setContextData(contextDataKey, contextDataValue) {
    var video = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var contextData = {};
    window.s.contextData[contextDataKey] = contextDataValue;
    dynamicKeys.push("contextData.".concat(contextDataKey));

    if (video) {
      contextData[contextDataKey] = contextDataValue;
      return contextData;
    }

    return null;
  };
  /**
   * @param  {} rudderElement
   * Context data variables let you define custom variables on each page that processing rules can read.
   * DOC: https://experienceleague.adobe.com/docs/analytics/implementation/vars/page-vars/contextdata.html?lang=en
   */


  var handleContextData = function handleContextData(rudderElement) {
    window.s.contextData = {};
    var properties = rudderElement.message.properties;
    var contextDataPrefixValue = config$1.contextDataPrefix ? "".concat(config$1.contextDataPrefix, ".") : "";

    if (properties) {
      each_1(function (value, key) {
        setContextData(contextDataPrefixValue + key, value);
      }, properties);
    }

    var contextDataMappingHashmap = getHashFromArray(config$1.contextDataMapping, "from", "to", false);
    var keyValueContextData = getDataFromContext(contextDataMappingHashmap, rudderElement);

    if (keyValueContextData) {
      each_1(function (value, key) {
        if (isDefinedAndNotNullAndNotEmpty(key)) {
          setContextData(key, value);
        }
      }, keyValueContextData);
    }
  };
  /**
   * @param  {} rudderElement
   * eVars are custom variables that you can use however you’d like.
   * Updates eVar variable of window.s
   * DOC: https://experienceleague.adobe.com/docs/analytics/implementation/vars/page-vars/evar.html?lang=en
   */


  var handleEVars = function handleEVars(rudderElement) {
    var properties = rudderElement.message.properties;
    var eVarMappingHashmap = getHashFromArray(config$1.eVarMapping, "from", "to", false);
    var eVarHashmapMod = {};
    Object.keys(eVarMappingHashmap).forEach(function (value) {
      eVarHashmapMod[value] = "eVar".concat(eVarMappingHashmap[value]);
    });

    if (eVarHashmapMod) {
      each_1(function (value, key) {
        if (eVarHashmapMod[key]) {
          updateWindowSKeys(value.toString(), eVarHashmapMod[key]);
        }
      }, properties);
    }
  };
  /**
   * @param  {} rudderElement
   * Hierarchy variables are custom variables that let you see a site’s structure.
   * Updates hier varaible of window.s
   *
   * DOC: https://experienceleague.adobe.com/docs/analytics/implementation/vars/page-vars/hier.html?lang=en
   */


  var handleHier = function handleHier(rudderElement) {
    var properties = rudderElement.message.properties;
    var hierMappingHashmap = getHashFromArray(config$1.hierMapping, "from", "to", false);
    var hierHashmapMod = {};
    Object.keys(hierMappingHashmap).forEach(function (value) {
      hierHashmapMod[value] = "hier".concat(hierMappingHashmap[value]);
    });

    if (hierHashmapMod) {
      each_1(function (value, key) {
        if (hierHashmapMod[key]) {
          updateWindowSKeys(value.toString(), hierHashmapMod[key]);
        }
      }, properties);
    }
  };
  /**
   * @param  {} rudderElement
   * List variables are custom variables that you can use however you’d like.
   * They work similarly to eVars, except they can contain multiple values in the same hit.
   *
   * If there are many values to be appended in a particular list it will be separated by
   * the delimiter set.
   *
   * Sets list variable of window.s
   * DOC: https://experienceleague.adobe.com/docs/analytics/implementation/vars/page-vars/list.html?lang=en
   */


  var handleLists = function handleLists(rudderElement) {
    var properties = rudderElement.message.properties;
    var listMappingHashmap = getHashFromArray(config$1.listMapping, "from", "to", false);
    var listDelimiterHashmap = getHashFromArray(config$1.listDelimiter, "from", "to", false);

    if (properties) {
      each_1(function (value, key) {
        if (listMappingHashmap[key] && listDelimiterHashmap[key]) {
          if (typeof value !== "string" && !Array.isArray(value)) {
            logger.error("list variable is neither a string nor an array");
            return;
          }

          var delimiter = listDelimiterHashmap[key];
          var listValue = "list".concat(listMappingHashmap[key]);

          if (typeof value === "string") {
            value = value.replace(/\s*,+\s*/g, delimiter);
          } else {
            value = value.join(delimiter);
          }

          updateWindowSKeys(value.toString(), listValue);
        }
      }, properties);
    }
  };
  /**
   * @param  {} rudderElement
   * @description Props are custom variables that you can use however you’d like.
   * They do not persist beyond the hit that they are set.
   * prop variable of window.s is updated
   * DOC: https://experienceleague.adobe.com/docs/analytics/implementation/vars/page-vars/prop.html?lang=en
   */


  var handleCustomProps = function handleCustomProps(rudderElement) {
    var properties = rudderElement.message.properties;
    var customPropsMappingHashmap = getHashFromArray(config$1.customPropsMapping, "from", "to", false);
    var propsDelimiterHashmap = getHashFromArray(config$1.propsDelimiter, "from", "to", false);

    if (properties) {
      each_1(function (value, key) {
        if (customPropsMappingHashmap[key]) {
          if (typeof value !== "string" && !Array.isArray(value)) {
            logger.error("prop variable is neither a string nor an array");
            return;
          }

          var delimiter = propsDelimiterHashmap[key] ? propsDelimiterHashmap[key] : "|";
          var propValue = "prop".concat(customPropsMappingHashmap[key]);

          if (typeof value === "string") {
            value = value.replace(/\s*,+\s*/g, delimiter);
          } else {
            value = value.join(delimiter);
          }

          updateWindowSKeys(value.toString(), propValue);
        }
      }, properties);
    }
  };

  var mapMerchEvents = function mapMerchEvents(event, properties) {
    var eventMerchEventToAdobeEventHashmap = getHashFromArray(config$1.eventMerchEventToAdobeEvent);
    var merchMap = [];

    if (!eventMerchEventToAdobeEventHashmap[event.toLowerCase()] || !config$1.eventMerchProperties) {
      return merchMap;
    }

    var adobeEvent = eventMerchEventToAdobeEventHashmap[event.toLowerCase()].split(",");
    var eventString;
    each_1(function (rudderProp) {
      if (rudderProp.eventMerchProperties in properties) {
        each_1(function (value) {
          if (properties[rudderProp.eventMerchProperties]) eventString = "".concat(value, "=").concat(properties[rudderProp.eventMerchProperties]);
          merchMap.push(eventString);
        }, adobeEvent);
      }
    }, config$1.eventMerchProperties);
    return merchMap;
  };
  /**
   * @param  {} event
   * @param  {} properties
   * @description Function to set event string of Ecomm events
   * Updates the "events" property of window.s
   */


  var setEventsString = function setEventsString(event, properties, adobeEventName) {
    // adobe events are taken as comma separated string
    var adobeEventArray = adobeEventName ? adobeEventName.split(",") : [];
    var merchMap = mapMerchEvents(event, properties);
    adobeEventArray = adobeEventArray.concat(merchMap);
    adobeEventArray = adobeEventArray.filter(function (item) {
      return !!item;
    });
    var productMerchEventToAdobeEventHashmap = getHashFromArray(config$1.productMerchEventToAdobeEvent);

    if (productMerchEventToAdobeEventHashmap[event.toLowerCase()]) {
      each_1(function (value) {
        adobeEventArray.push(value);
      }, productMerchEventToAdobeEventHashmap);
    }

    var adobeEvent = adobeEventArray.join(",");
    updateWindowSKeys(adobeEvent, "events");
    /**
     * The s.linkTrackEvents variable is a string containing a comma-delimited list of
     *  events that you want to include in link tracking image requests
     */

    window.s.linkTrackEvents = adobeEvent;
  };
  /**
   * @param  {} event
   * @param  {} properties
   * @param  {} adobeEvent
   * @description Creates the merchendising product eventsString for each product which will be added to the
   * key products along with the evars as set.
   * DOC: https://experienceleague.adobe.com/docs/analytics/implementation/vars/page-vars/products.html?lang=en
   * @returns [] merchMap
   */


  var mapMerchProductEvents = function mapMerchProductEvents(event, properties, adobeEvent) {
    var productMerchEventToAdobeEventHashmap = getHashFromArray(config$1.productMerchEventToAdobeEvent); // converting string to array if more than 1 event is there.

    adobeEvent = adobeEvent.split(",");
    var merchMap = [];
    var eventString;

    if (!productMerchEventToAdobeEventHashmap[event.toLowerCase()] || !config$1.productMerchProperties) {
      return merchMap;
    }

    each_1(function (rudderProp) {
      // if property mapped with products. as starting handle differently
      if (rudderProp.productMerchProperties.startsWith("products.")) {
        var key = rudderProp.productMerchProperties.split("."); // take the keys after products. and find the value in properties

        var value = lodash.get(properties, key[1]);

        if (isDefined$1(value)) {
          each_1(function (val) {
            eventString = "".concat(val, "=").concat(value);
            merchMap.push(eventString);
          }, adobeEvent);
        }
      } else if (rudderProp.productMerchProperties in properties) {
        each_1(function (val) {
          eventString = "".concat(val, "=").concat(properties[rudderProp.productMerchProperties]);
          merchMap.push(eventString);
        }, adobeEvent);
      }
    }, config$1.productMerchProperties);
    return merchMap;
  };
  /**
   * @param  {} properties
   * @description set eVars for product level properties
   * DOC: https://experienceleague.adobe.com/docs/analytics/implementation/vars/page-vars/evar-merchandising.html?lang=en
   * @returns eVars as a string with delimiter "|"
   */


  var mapMerchProductEVars = function mapMerchProductEVars(properties) {
    var productMerchEvarsMapHashmap = getHashFromArray(config$1.productMerchEvarsMap, "from", "to", false);
    var eVars = [];
    each_1(function (value, key) {
      // if property mapped with products. as starting handle differently
      if (key.startsWith("products.")) {
        key = key.split("."); // take the keys after products. and find the value in properties

        var productValue = lodash.get(properties, key[1]);

        if (isDefined$1(productValue)) {
          eVars.push("eVar".concat(value, "=").concat(productValue));
        }
      } else if (key in properties) {
        eVars.push("eVar".concat(value, "=").concat(properties[key]));
      }
    }, productMerchEvarsMapHashmap);
    return eVars.join("|");
  };
  /**
   * @param  {} event
   * @param  {} prodFields
   * @param  {} adobeEvent
   * @description set products key for window.s
   * DOC: https://experienceleague.adobe.com/docs/analytics/implementation/vars/page-vars/products.html?lang=en
   */


  var mapProducts = function mapProducts(event, prodFields, adobeEvent) {
    var prodString = [];
    prodFields.forEach(function (value) {
      var category = value.category || "";
      var quantity = value.quantity || 1;
      var total = value.price ? (value.price * quantity).toFixed(2) : 0;
      var item;

      if (config$1.productIdentifier === "id") {
        item = value.product_id || value.id;
      } else {
        item = value[config$1.productIdentifier];
      }

      var eventString = mapMerchProductEvents(event, value, adobeEvent).join("|");
      var prodEVarsString = mapMerchProductEVars(value);

      if (eventString !== "" || prodEVarsString !== "") {
        var test = [category, item, quantity, total, eventString, prodEVarsString].map(function (val) {
          if (val == null) {
            return String(val);
          }

          return val;
        });
        prodString.push(test.join(";"));
      } else {
        var _test = [category, item, quantity, total].map(function (val) {
          if (val === null) {
            return String(val);
          }

          return val;
        }).join(";");

        prodString.push(_test);
      }
    });
    updateWindowSKeys(prodString, "products");
  };
  /**
   * @param  {} event
   * @param  {} properties
   * @description Function to set product string for product level of Ecomm events
   */


  var setProductString = function setProductString(event, properties) {
    var productMerchEventToAdobeEventHashmap = getHashFromArray(config$1.productMerchEventToAdobeEvent);
    var adobeEvent = productMerchEventToAdobeEventHashmap[event.toLowerCase()];

    if (adobeEvent) {
      var isSingleProdEvent = adobeEvent === "scAdd" || adobeEvent === "scRemove" || adobeEvent === "prodView" && event.toLowerCase() !== "product list viewed" || !Array.isArray(properties.products);
      var prodFields = isSingleProdEvent ? [properties] : properties.products;
      mapProducts(event, prodFields, adobeEvent);
    }
  };
  /**
   * @param  {} rudderElement
   * @param  {} adobeEventName
   *
   * Update window variables and do adobe track calls
   */


  var processEvent = function processEvent(rudderElement, adobeEventName, pageName) {
    var _rudderElement$messag4 = rudderElement.message,
        properties = _rudderElement$messag4.properties,
        event = _rudderElement$messag4.event;
    var currency = properties.currency;
    updateCommonWindowSKeys(rudderElement, pageName);
    calculateTimestamp(rudderElement); // useful for setting evar as amount value if this is set

    if (currency !== "USD") {
      updateWindowSKeys(currency, "currencyCode");
    }

    setEventsString(event, properties, adobeEventName);
    setProductString(event, properties);
    handleContextData(rudderElement);
    handleEVars(rudderElement);
    handleHier(rudderElement);
    handleLists(rudderElement);
    handleCustomProps(rudderElement);
    /**
     * The s.linkTrackVars variable is a string containing a comma-delimited list of variables that you want to
     * include in link tracking image requests
     */

    window.s.linkTrackVars = dynamicKeys.join(",");
    /**
     * The tl() method is an important core component to Adobe Analytics.
     * It takes all Analytics variables defined on the page, compiles them into an image request,
     * and sends that data to Adobe data collection servers. It works similarly to the t() method,
     * however this method does not increment page views.
     * It is useful for tracking links and other elements that wouldn’t be considered a full page load.
     */

    window.s.tl(true, "o", event);
  };

  var handleVideoContextData = function handleVideoContextData(rudderElement) {
    var contextData;
    var properties = rudderElement.message.properties;
    var contextDataPrefixValue = config$1.contextDataPrefix ? "".concat(config$1.contextDataPrefix, ".") : "";

    if (properties) {
      each_1(function (value, key) {
        contextData = _objectSpread2(_objectSpread2({}, contextData), setContextData(contextDataPrefixValue + key, value, true));
      }, properties);
    }

    var contextDataMappingHashmap = getHashFromArray(config$1.contextDataMapping, "from", "to", false);
    var keyValueContextData = getDataFromContext(contextDataMappingHashmap, rudderElement);

    if (keyValueContextData) {
      each_1(function (value, key) {
        if (isDefinedAndNotNullAndNotEmpty(key)) {
          contextData = _objectSpread2(_objectSpread2({}, contextData), setContextData(key, value, true));
        }
      }, keyValueContextData);
    }

    return contextData;
  };

  /* eslint-disable camelcase */

  var productViewHandle = function productViewHandle(rudderElement, pageName) {
    clearWindowSKeys(getDynamicKeys());
    processEvent(rudderElement, "prodView", pageName);
  };

  var productAddedHandle = function productAddedHandle(rudderElement, pageName) {
    clearWindowSKeys(getDynamicKeys());
    processEvent(rudderElement, "scAdd", pageName);
  };

  var productRemovedHandle = function productRemovedHandle(rudderElement, pageName) {
    clearWindowSKeys(getDynamicKeys());
    processEvent(rudderElement, "scRemove", pageName);
  };

  var orderCompletedHandle = function orderCompletedHandle(rudderElement, pageName) {
    clearWindowSKeys(getDynamicKeys());
    var properties = rudderElement.message.properties;
    var purchaseId = properties.purchaseId,
        transactionId = properties.transactionId,
        order_id = properties.order_id;
    updateWindowSKeys(purchaseId || order_id, "purchaseID");
    updateWindowSKeys(transactionId || order_id, "transactionID");
    processEvent(rudderElement, "purchase", pageName);
  };

  var checkoutStartedHandle = function checkoutStartedHandle(rudderElement, pageName) {
    clearWindowSKeys(getDynamicKeys());
    var properties = rudderElement.message.properties;
    var purchaseId = properties.purchaseId,
        transactionId = properties.transactionId,
        order_id = properties.order_id;
    updateWindowSKeys(purchaseId || order_id, "purchaseID");
    updateWindowSKeys(transactionId || order_id, "transactionID");
    processEvent(rudderElement, "scCheckout", pageName);
  };

  var cartViewedHandle = function cartViewedHandle(rudderElement, pageName) {
    clearWindowSKeys(getDynamicKeys());
    processEvent(rudderElement, "scView", pageName);
  };

  var cartOpenedHandle = function cartOpenedHandle(rudderElement, pageName) {
    clearWindowSKeys(getDynamicKeys());
    processEvent(rudderElement, "scOpen", pageName);
  };

  /* eslint-disable no-underscore-dangle */
  var qosData = {};
  var mediaHeartbeats = {};
  var playhead = 0;
  var adBreakCounts = {};
  var adBreakProgress = false; // Begin heartbeat implementation
  // Handling Video Type Events
  // DOC: https://experienceleague.adobe.com/docs/media-analytics/using/sdk-implement/setup/setup-javascript/set-up-js-2.html?lang=en
  // DOC: https://experienceleague.adobe.com/docs/media-analytics/using/sdk-implement/track-av-playback/track-core-overview.html?lang=en

  var heartbeatSessionStart = function heartbeatSessionStart(rudderElement) {
    var va = window.ADB.va;
    var properties = rudderElement.message.properties;
    var livestream = properties.livestream,
        title = properties.title,
        asset_id = properties.asset_id,
        total_length = properties.total_length,
        session_id = properties.session_id;
    var streamType = livestream ? va.MediaHeartbeat.StreamType.LIVE : va.MediaHeartbeat.StreamType.VOD;
    var mediaObj = va.MediaHeartbeat.createMediaObject(title || "", asset_id || "unknown video id", total_length || 0, streamType);
    var contextData = handleVideoContextData(rudderElement);
    standardVideoMetadata(rudderElement, mediaObj);
    mediaHeartbeats[session_id || "default"].heartbeat.trackSessionStart(mediaObj, contextData);
  };

  var initHeartbeat = function initHeartbeat(rudderElement) {
    var config = getConfig();
    var va = window.ADB.va;
    var message = rudderElement.message;
    var properties = message.properties,
        context = message.context;
    var channel = properties.channel,
        video_player = properties.video_player,
        session_id = properties.session_id;
    var mediaHeartbeatConfig = new va.MediaHeartbeatConfig();
    var mediaHeartbeatDelegate = new va.MediaHeartbeatDelegate();
    mediaHeartbeatConfig.trackingServer = config.heartbeatTrackingServerUrl;
    mediaHeartbeatConfig.channel = channel || "";
    mediaHeartbeatConfig.ovp = properties.ovp || "unknown";
    mediaHeartbeatConfig.appVersion = context.app.version || "unknown";
    mediaHeartbeatConfig.playerName = video_player || "unknown";
    mediaHeartbeatConfig.ssl = config.sslHeartbeat;
    mediaHeartbeatConfig.debugLogging = !!window._enableHeartbeatDebugLogging;

    mediaHeartbeatDelegate.getCurrentPlaybackTime = function () {
      playhead = playhead || 0;
      var sessions = window.rudderHBPlayheads || {};
      playhead = sessions[session_id] ? sessions[session_id] : playhead;
      return playhead;
    };

    mediaHeartbeatDelegate.getQoSObject = function () {
      return qosData;
    };

    mediaHeartbeats[session_id || "default"] = {
      heartbeat: new va.MediaHeartbeat(mediaHeartbeatDelegate, mediaHeartbeatConfig, window.s),
      delegate: mediaHeartbeatDelegate,
      config: mediaHeartbeatConfig
    };
    qosData = createQos(rudderElement);
    heartbeatSessionStart(rudderElement);
  };

  var populateHeartbeat = function populateHeartbeat(rudderElement) {
    var properties = rudderElement.message.properties;
    var session_id = properties.session_id,
        channel = properties.channel,
        video_player = properties.video_player;
    var mediaHeartbeat = mediaHeartbeats[session_id || "default"];

    if (!mediaHeartbeat) {
      initHeartbeat(rudderElement);
    } else {
      var mediaHeartbeatConfig = mediaHeartbeat.config;
      mediaHeartbeatConfig.channel = channel || mediaHeartbeatConfig.channel;
      mediaHeartbeatConfig.playerName = video_player || mediaHeartbeatConfig.playerName;
    }
  };

  var heartbeatVideoStart = function heartbeatVideoStart(rudderElement) {
    populateHeartbeat(rudderElement);
    var properties = rudderElement.message.properties;
    var va = window.ADB.va;
    var session_id = properties.session_id,
        chapter_name = properties.chapter_name,
        position = properties.position,
        length = properties.length,
        start_time = properties.start_time;
    mediaHeartbeats[session_id || "default"].heartbeat.trackPlay();
    var contextData = handleVideoContextData(rudderElement);

    if (!mediaHeartbeats[session_id || "default"].chapterInProgress) {
      var chapterObj = va.MediaHeartbeat.createChapterObject(chapter_name || "no chapter name", position || 1, length || 6000, start_time || 0);
      mediaHeartbeats[session_id || "default"].heartbeat.trackEvent(va.MediaHeartbeat.Event.ChapterStart, chapterObj, contextData);
      mediaHeartbeats[session_id || "default"].chapterInProgress = true;
    }
  };

  var heartbeatVideoPaused = function heartbeatVideoPaused(rudderElement) {
    populateHeartbeat(rudderElement);
    var properties = rudderElement.message.properties;
    mediaHeartbeats[properties.session_id || "default"].heartbeat.trackPause();
  };

  var heartbeatVideoComplete = function heartbeatVideoComplete(rudderElement) {
    populateHeartbeat(rudderElement);
    var va = window.ADB.va;
    var properties = rudderElement.message.properties;
    mediaHeartbeats[properties.session_id || "defualt"].heartbeat.trackEvent(va.MediaHeartbeat.Event.ChapterComplete);
    mediaHeartbeats[properties.session_id || "default"].chapterInProgress = false;
  };

  var heartbeatSessionEnd = function heartbeatSessionEnd(rudderElement) {
    populateHeartbeat(rudderElement);
    var properties = rudderElement.message.properties;
    var session_id = properties.session_id;
    mediaHeartbeats[session_id || "default"].heartbeat.trackComplete();
    mediaHeartbeats[session_id || "default"].heartbeat.trackSessionEnd();
    delete mediaHeartbeats[session_id || "default"];
    delete adBreakCounts[session_id || "default"];
  };

  var heartbeatAdStarted = function heartbeatAdStarted(rudderElement) {
    var va = window.ADB.va;
    var properties = rudderElement.message.properties;
    var session_id = properties.session_id,
        type = properties.type,
        position = properties.position,
        title = properties.title,
        asset_id = properties.asset_id,
        total_length = properties.total_length,
        content = properties.content;
    var adSessionCount = adBreakCounts[session_id || "deafult"];
    adSessionCount = adSessionCount ? adBreakCounts[session_id || "default"] + 1 : adBreakCounts[session_id || "default"] = 1;
    var adBreakObj = va.MediaHeartbeat.createAdBreakObject(type || "unknown", adSessionCount, position || 1);
    mediaHeartbeats[session_id || "default"].heartbeat.trackEvent(va.MediaHeartbeat.Event.AdBreakStart, adBreakObj);
    adBreakProgress = true;
    var adObject = va.MediaHeartbeat.createAdObject(title || "no title", asset_id.toString() || "default ad", position || 1, total_length || 0);
    standardAdMetadata(rudderElement, adObject);
    mediaHeartbeats[session_id || "deafult"].heartbeat.trackEvent(va.MediaHeartbeat.Event.AdStart, adObject, content || {});
  };

  var heartbeatAdCompleted = function heartbeatAdCompleted(rudderElement) {
    var va = window.ADB.va;
    var properties = rudderElement.message.properties;
    var session_id = properties.session_id;

    if (!adBreakProgress) {
      heartbeatAdStarted(rudderElement);
    }

    mediaHeartbeats[session_id || "default"].heartbeat.trackEvent(va.MediaHeartbeat.Event.AdComplete);
    mediaHeartbeats[session_id || "default"].heartbeat.trackEvent(va.MediaHeartbeat.Event.AdBreakComplete);
    adBreakProgress = false;
  };

  var heartbeatAdSkipped = function heartbeatAdSkipped(rudderElement) {
    var va = window.ADB.va;
    var properties = rudderElement.message.properties;
    var session_id = properties.session_id;

    if (!adBreakProgress) {
      heartbeatAdStarted(rudderElement);
    }

    mediaHeartbeats[session_id || "default"].heartbeat.trackEvent(va.MediaHeartbeat.Event.AdSkip);
    mediaHeartbeats[session_id || "default"].heartbeat.trackEvent(va.MediaHeartbeat.Event.AdBreakComplete);
    adBreakProgress = false;
  };

  var heartbeatSeekStarted = function heartbeatSeekStarted(rudderElement) {
    populateHeartbeat(rudderElement);
    var va = window.ADB.va;
    var properties = rudderElement.message.properties;
    var session_id = properties.session_id;
    mediaHeartbeats[session_id || "default"].heartbeat.trackEvent(va.MediaHeartbeat.Event.SeekStart);
  };

  var heartbeatSeekCompleted = function heartbeatSeekCompleted(rudderElement) {
    populateHeartbeat(rudderElement);
    var va = window.ADB.va;
    var properties = rudderElement.message.properties;
    var session_id = properties.session_id;
    mediaHeartbeats[session_id || "default"].heartbeat.trackEvent(va.MediaHeartbeat.Event.SeekComplete);
  };

  var heartbeatBufferStarted = function heartbeatBufferStarted(rudderElement) {
    populateHeartbeat(rudderElement);
    var va = window.ADB.va;
    var properties = rudderElement.message.properties;
    var session_id = properties.session_id;
    mediaHeartbeats[session_id || "default"].heartbeat.trackEvent(va.MediaHeartbeat.Event.BufferStart);
  };

  var heartbeatQualityUpdated = function heartbeatQualityUpdated(rudderElement) {
    qosData = createQos(rudderElement);
  };

  var heartbeatUpdatePlayhead = function heartbeatUpdatePlayhead(rudderElement) {
    if (rudderElement.message.properties) {
      playhead = rudderElement.message.properties.position || rudderElement.message.properties.playhead || null;
    }
  };

  var heartbeatBufferCompleted = function heartbeatBufferCompleted(rudderElement) {
    populateHeartbeat(rudderElement);
    var va = window.ADB.va;
    var properties = rudderElement.message.properties;
    var session_id = properties.session_id;
    mediaHeartbeats[session_id || "default"].heartbeat.trackEvent(va.MediaHeartbeat.Event.BufferComplete);
  };

  /* eslint-disable no-use-before-define */
  var defaultAsyncState = true;

  var ScriptLoader = function ScriptLoader(id, src) {
    var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultAsyncState;
    logger.debug("in script loader=== ".concat(id));
    var js = document.createElement("script");
    js.src = src;
    js.async = async === undefined ? defaultAsyncState : async;
    js.type = "text/javascript";
    js.id = id;
    var headElmColl = document.getElementsByTagName("head");

    if (headElmColl.length !== 0) {
      logger.debug("==adding script==", js);
      headElmColl[0].insertBefore(js, headElmColl[0].firstChild);
    } else {
      var e = document.getElementsByTagName("script")[0];
      logger.debug("==parent script==", e);
      logger.debug("==adding script==", js);
      e.parentNode.insertBefore(js, e);
    }
  };

  var AdobeAnalytics = /*#__PURE__*/function () {
    function AdobeAnalytics(config) {
      _classCallCheck(this, AdobeAnalytics);

      this.trackingServerUrl = config.trackingServerUrl || "";
      this.reportSuiteIds = config.reportSuiteIds;
      this.heartbeatTrackingServerUrl = config.heartbeatTrackingServerUrl || "";
      this.eventsToTypes = config.eventsToTypes || [];
      this.marketingCloudOrgId = config.marketingCloudOrgId || "";
      this.dropVisitorId = config.dropVisitorId;
      this.trackingServerSecureUrl = config.trackingServerSecureUrl || "";
      this.timestampOption = config.timestampOption;
      this.preferVisitorId = config.preferVisitorId;
      this.rudderEventsToAdobeEvents = config.rudderEventsToAdobeEvents || [];
      this.proxyNormalUrl = config.proxyNormalUrl;
      this.proxyHeartbeatUrl = config.proxyHeartbeatUrl;
      this.pageName = "";
      this.name = NAME;
      setConfig(config);
    }

    _createClass(AdobeAnalytics, [{
      key: "init",
      value: function init() {
        // check if was already initialised. If yes then use already existing.
        window.s_account = window.s_account || this.reportSuiteIds; // update playhead value of a session

        window.rudderHBPlayheads = {}; // load separately as heartbeat sdk is large and need not be required if this is off.

        var heartbeatUrl = this.proxyHeartbeatUrl || "https://cdn.rudderlabs.com/adobe-analytics-js/adobe-analytics-js-heartbeat.js";
        var normalUrl = this.proxyNormalUrl || "https://cdn.rudderlabs.com/adobe-analytics-js/adobe-analytics-js.js";

        if (this.heartbeatTrackingServerUrl) {
          ScriptLoader("adobe-analytics-heartbeat", heartbeatUrl);
          this.setIntervalHandler = setInterval(this.initAdobeAnalyticsClient.bind(this), 1000);
        } else {
          ScriptLoader("adobe-analytics-heartbeat", normalUrl);
          this.setIntervalHandler = setInterval(this.initAdobeAnalyticsClient.bind(this), 1000);
        }
      }
    }, {
      key: "initAdobeAnalyticsClient",
      value: function initAdobeAnalyticsClient() {
        var _window = window,
            s = _window.s;
        s.trackingServer = s.trackingServer || this.trackingServerUrl;
        s.trackingServerSecure = s.trackingServerSecure || this.trackingServerSecureUrl;

        if (this.marketingCloudOrgId && window.Visitor && typeof window.Visitor.getInstance === "function") {
          s.visitor = window.Visitor.getInstance(this.marketingCloudOrgId, {
            trackingServer: window.s.trackingServer || this.trackingServerUrl,
            trackingServerSecure: window.s.trackingServerSecure || this.trackingServerSecureUrl
          });
        }
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("in AdobeAnalytics isLoaded");
        return !!(window.s_gi && window.s_gi !== Array.prototype.push);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("in AdobeAnalytics isReady");
        return !!(window.s_gi && window.s_gi !== Array.prototype.push);
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        // delete existing keys from widnow.s
        clearWindowSKeys(getDynamicKeys()); // The pageName variable typically stores the name of a given page

        var name;

        if (rudderElement.message.name) {
          name = rudderElement.message.name;
        } else if (rudderElement.message.properties) {
          name = rudderElement.message.properties.name;
        }

        this.pageName = name ? "Viewed Page ".concat(name) : "Viewed Page";
        window.s.pageName = this.pageName; // The referrer variable overrides the automatically collected referrer in reports.

        var referrer;
        var url;

        if (rudderElement.message.context && rudderElement.message.context.page) {
          referrer = rudderElement.message.context.page.referrer;
          url = rudderElement.message.context.page.url;
        } else if (rudderElement.message.properties) {
          referrer = rudderElement.message.properties.referrer;
          url = rudderElement.message.properties.url;
        }

        window.s.referrer = referrer; // if dropVisitorId is true visitorID will not be set

        /** Cross-device visitor identification uses the visitorID variable to associate a user across devices.
         *  The visitorID variable takes the highest priority when identifying unique visitors.
         * Visitor deduplication is not retroactive: */

        if (!this.dropVisitorId) {
          var userId = rudderElement.message.userId;

          if (userId) {
            if (this.timestampOption === "disabled") {
              window.s.visitorID = userId;
            } // If timestamp hybrid option and visitor id preferred is on visitorID is set


            if (this.timestampOption === "hybrid" && this.preferVisitorId) {
              window.s.visitorID = userId;
            }
          }
        } // update values in window.s


        updateWindowSKeys(this.pageName, "events");
        updateWindowSKeys(url, "pageURL");
        updateCommonWindowSKeys(rudderElement, this.pageName);
        calculateTimestamp(rudderElement);
        handleContextData(rudderElement);
        handleEVars(rudderElement);
        handleHier(rudderElement);
        handleLists(rudderElement);
        handleCustomProps(rudderElement);
        /** The t() method is an important core component to Adobe Analytics. It takes all Analytics variables defined on the page,
         *  compiles them into an image request, and sends that data to Adobe data collection servers.
         * */

        window.s.t();
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        clearWindowSKeys(getDynamicKeys());
        var event = rudderElement.message.event;

        if (this.heartbeatTrackingServerUrl) {
          var eventsToTypesHashmap = getHashFromArray(this.eventsToTypes);
          var heartBeatFunction = eventsToTypesHashmap[event.toLowerCase()]; // process mapped video events

          this.processHeartbeatMappedEvents(heartBeatFunction, rudderElement);
        } // process unmapped ecomm events


        var isProcessed = this.checkIfRudderEcommEvent(rudderElement); // process mapped events

        if (!isProcessed) {
          var rudderEventsToAdobeEventsHashmap = getHashFromArray(this.rudderEventsToAdobeEvents);

          if (rudderEventsToAdobeEventsHashmap[event.toLowerCase()]) {
            processEvent(rudderElement, rudderEventsToAdobeEventsHashmap[event.toLowerCase()].trim(), this.pageName);
          }
        }
      }
      /**
       * @param  {} rudderElement
       * @description Checks if the incoming rudder event is an Ecomm Event. Return true or false accordingly.
       * DOC: https://docs.rudderstack.com/rudderstack-api-spec/rudderstack-ecommerce-events-specification
       * @returns ret
       */

    }, {
      key: "checkIfRudderEcommEvent",
      value: function checkIfRudderEcommEvent(rudderElement) {
        var event = rudderElement.message.event;
        var ret = true;

        switch (event.toLowerCase()) {
          case "product viewed":
          case "product list viewed":
            productViewHandle(rudderElement, this.pageName);
            break;

          case "product added":
            productAddedHandle(rudderElement, this.pageName);
            break;

          case "product removed":
            productRemovedHandle(rudderElement, this.pageName);
            break;

          case "order completed":
            orderCompletedHandle(rudderElement, this.pageName);
            break;

          case "cart viewed":
            cartViewedHandle(rudderElement, this.pageName);
            break;

          case "checkout started":
            checkoutStartedHandle(rudderElement, this.pageName);
            break;

          case "cart opened":
          case "opened cart":
            cartOpenedHandle(rudderElement, this.pageName);
            break;

          default:
            ret = false;
        }

        return ret;
      }
      /**
       * @param  {} heartBeatFunction
       * @param  {} rudderElement
       *
       * @description Function to process mapped video events in webapp with adobe video events.
       */

    }, {
      key: "processHeartbeatMappedEvents",
      value: function processHeartbeatMappedEvents(heartBeatFunction, rudderElement) {
        if (heartBeatFunction) {
          switch (heartBeatFunction) {
            case "initHeartbeat":
              initHeartbeat(rudderElement);
              break;

            case "heartbeatPlaybackStarted":
            case "heartbeatPlaybackResumed":
            case "heartbeatContentStarted":
            case "heartbeatVideoStart":
              heartbeatVideoStart(rudderElement);
              break;

            case "heartbeatPlaybackPaused":
            case "heartbeatPlaybackInterrupted":
            case "heartbeatVideoPaused":
              heartbeatVideoPaused(rudderElement);
              break;

            case "heartbeatContentComplete":
            case "heartbeatVideoComplete":
              heartbeatVideoComplete(rudderElement);
              break;

            case "heartbeatSessionEnd":
            case "heartbeatPlaybackCompleted":
              heartbeatSessionEnd(rudderElement);
              break;

            case "heartbeatAdStarted":
            case "heartbeatAdBreakStarted":
              heartbeatAdStarted(rudderElement);
              break;

            case "heartbeatAdCompleted":
            case "heartbeatAdBreakCompleted":
              heartbeatAdCompleted(rudderElement);
              break;

            case "heartbeatAdSkipped":
              heartbeatAdSkipped(rudderElement);
              break;

            case "heartbeatSeekStarted":
              heartbeatSeekStarted(rudderElement);
              break;

            case "heartbeatSeekCompleted":
              heartbeatSeekCompleted(rudderElement);
              break;

            case "heartbeatBufferStarted":
              heartbeatBufferStarted(rudderElement);
              break;

            case "heartbeatBufferCompleted":
              heartbeatBufferCompleted(rudderElement);
              break;

            case "heartbeatQualityUpdated":
              heartbeatQualityUpdated(rudderElement);
              break;

            case "heartbeatUpdatePlayhead":
              heartbeatUpdatePlayhead(rudderElement);
              break;

            default:
              logger.error("No heartbeat function for this event");
          }
        }
      }
    }]);

    return AdobeAnalytics;
  }();

  var Amplitude = /*#__PURE__*/function () {
    function Amplitude(config, analytics) {
      var _this = this;

      _classCallCheck(this, Amplitude);

      this.name = NAME$1;
      this.analytics = analytics;
      this.apiKey = config.apiKey;
      this.trackAllPages = config.trackAllPages || false;
      this.trackNamedPages = config.trackNamedPages || false;
      this.trackCategorizedPages = config.trackCategorizedPages || false;
      this.trackUtmProperties = config.trackUtmProperties || false;
      this.trackReferrer = config.trackReferrer || false;
      this.batchEvents = config.batchEvents || false;
      this.eventUploadThreshold = +config.eventUploadThreshold || 30;
      this.eventUploadPeriodMillis = +config.eventUploadPeriodMillis || 30000;
      this.forceHttps = config.forceHttps || false;
      this.trackGclid = config.trackGclid || false;
      this.saveParamsReferrerOncePerSession = config.saveParamsReferrerOncePerSession || false;
      this.deviceIdFromUrlParam = config.deviceIdFromUrlParam || false; // this.mapQueryParams = config.mapQueryParams;

      this.trackRevenuePerProduct = config.trackRevenuePerProduct || false;
      this.preferAnonymousIdForDeviceId = config.preferAnonymousIdForDeviceId || false;
      this.traitsToSetOnce = [];
      this.traitsToIncrement = [];
      this.appendFieldsToEventProps = config.appendFieldsToEventProps || false;
      this.unsetParamsReferrerOnNewSession = config.unsetParamsReferrerOnNewSession || false;
      this.trackProductsOnce = config.trackProductsOnce || false;
      this.versionName = config.versionName;

      if (config.traitsToSetOnce && config.traitsToSetOnce.length > 0) {
        config.traitsToSetOnce.forEach(function (element) {
          if (element && element.traits && element.traits !== "") {
            _this.traitsToSetOnce.push(element.traits);
          }
        });
      }

      if (config.traitsToIncrement && config.traitsToIncrement.length > 0) {
        config.traitsToIncrement.forEach(function (element) {
          if (element && element.traits && element.traits !== "") {
            _this.traitsToIncrement.push(element.traits);
          }
        });
      }
    }

    _createClass(Amplitude, [{
      key: "init",
      value: function init() {
        if (this.analytics.loadIntegration) {
          (function (e, t) {
            var n = e.amplitude || {
              _q: [],
              _iq: {}
            };
            var r = t.createElement("script");
            r.type = "text/javascript";
            r.integrity = "sha384-girahbTbYZ9tT03PWWj0mEVgyxtZoyDF9KVZdL+R53PP5wCY0PiVUKq0jeRlMx9M";
            r.crossOrigin = "anonymous";
            r.async = true;
            r.src = "https://cdn.amplitude.com/libs/amplitude-7.2.1-min.gz.js";

            r.onload = function () {
              if (!e.amplitude.runQueuedFunctions) {
                console.log("[Amplitude] Error: could not load SDK");
              }
            };

            var i = t.getElementsByTagName("script")[0];
            i.parentNode.insertBefore(r, i);

            function s(e, t) {
              e.prototype[t] = function () {
                this._q.push([t].concat(Array.prototype.slice.call(arguments, 0)));

                return this;
              };
            }

            var o = function o() {
              this._q = [];
              return this;
            };

            var a = ["add", "append", "clearAll", "prepend", "set", "setOnce", "unset"];

            for (var c = 0; c < a.length; c++) {
              s(o, a[c]);
            }

            n.Identify = o;

            var u = function u() {
              this._q = [];
              return this;
            };

            var l = ["setProductId", "setQuantity", "setPrice", "setRevenueType", "setEventProperties"];

            for (var p = 0; p < l.length; p++) {
              s(u, l[p]);
            }

            n.Revenue = u;
            var d = ["init", "logEvent", "logRevenue", "setUserId", "setUserProperties", "setOptOut", "setVersionName", "setDomain", "setDeviceId", "enableTracking", "setGlobalUserProperties", "identify", "clearUserProperties", "setGroup", "logRevenueV2", "regenerateDeviceId", "groupIdentify", "onInit", "logEventWithTimestamp", "logEventWithGroups", "setSessionId", "resetSessionId"];

            function v(e) {
              function t(t) {
                e[t] = function () {
                  e._q.push([t].concat(Array.prototype.slice.call(arguments, 0)));
                };
              }

              for (var _n = 0; _n < d.length; _n++) {
                t(d[_n]);
              }
            }

            v(n);

            n.getInstance = function (e) {
              e = (!e || e.length === 0 ? "$default_instance" : e).toLowerCase();

              if (!n._iq.hasOwnProperty(e)) {
                n._iq[e] = {
                  _q: []
                };
                v(n._iq[e]);
              }

              return n._iq[e];
            };

            e.amplitude = n;
          })(window, document);
        }

        var initOptions = {
          includeUtm: this.trackUtmProperties,
          batchEvents: this.batchEvents,
          eventUploadThreshold: this.eventUploadThreshold,
          eventUploadPeriodMillis: this.eventUploadPeriodMillis,
          forceHttps: this.forceHttps,
          includeGclid: this.trackGclid,
          includeReferrer: this.trackReferrer,
          saveParamsReferrerOncePerSession: this.saveParamsReferrerOncePerSession,
          deviceIdFromUrlParam: this.deviceIdFromUrlParam,
          unsetParamsReferrerOnNewSession: this.unsetParamsReferrerOnNewSession,
          deviceId: this.preferAnonymousIdForDeviceId && this.analytics && this.analytics.getAnonymousId()
        };
        window.amplitude.getInstance().init(this.apiKey, null, initOptions);

        if (this.versionName) {
          window.amplitude.getInstance().setVersionName(this.versionName);
        }
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("in Amplitude identify");
        this.setDeviceId(rudderElement); // rudderElement.message.context will always be present as part of identify event payload.

        var traits = rudderElement.message.context.traits;
        var userId = rudderElement.message.userId;

        if (userId) {
          window.amplitude.getInstance().setUserId(userId);
        }

        if (traits) {
          var amplitudeIdentify = new window.amplitude.Identify();

          for (var trait in traits) {
            if (!traits.hasOwnProperty(trait)) {
              continue;
            }

            var shouldIncrement = this.traitsToIncrement.indexOf(trait) >= 0;
            var shouldSetOnce = this.traitsToSetOnce.indexOf(trait) >= 0;

            if (shouldIncrement) {
              amplitudeIdentify.add(trait, traits[trait]);
            }

            if (shouldSetOnce) {
              amplitudeIdentify.setOnce(trait, traits[trait]);
            }

            if (!shouldIncrement && !shouldSetOnce) {
              amplitudeIdentify.set(trait, traits[trait]);
            }
          }

          window.amplitude.identify(amplitudeIdentify);
        }
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("in Amplitude track");
        this.setDeviceId(rudderElement);
        var properties = rudderElement.message.properties; // message.properties will always be present as part of track event.

        var products = properties.products;
        var clonedTrackEvent = {};

        _extends(clonedTrackEvent, rudderElement.message); // For track products once, we will send the products in a single call.


        if (this.trackProductsOnce) {
          if (products && type(products) == "array") {
            // track all the products in a single event.
            var allProducts = [];
            var productKeys = Object.keys(products);

            for (var index = 0; index < productKeys.length; index++) {
              var product = {};
              product = this.getProductAttributes(products[index]);
              allProducts.push(product);
            }

            clonedTrackEvent.properties.products = allProducts;
            this.logEventAndCorrespondingRevenue(clonedTrackEvent, this.trackRevenuePerProduct); // we do not want to track revenue as a whole if trackRevenuePerProduct is enabled.
            // If trackRevenuePerProduct is enabled, track revenues per product.

            if (this.trackRevenuePerProduct) {
              var trackEventMessage = {};

              _extends(trackEventMessage, clonedTrackEvent);

              this.trackingEventAndRevenuePerProduct(trackEventMessage, products, false); // also track revenue only and not event per product.
            }
          } else {
            // track event and revenue as a whole as products array is not available.
            this.logEventAndCorrespondingRevenue(clonedTrackEvent, false);
          }

          return;
        }

        if (products && type(products) == "array") {
          // track events iterating over product array individually.
          // Log the actuall event without products array. We will subsequently track each product with 'Product Purchased' event.
          delete clonedTrackEvent.properties.products;
          this.logEventAndCorrespondingRevenue(clonedTrackEvent, this.trackRevenuePerProduct);
          var _trackEventMessage = {};

          _extends(_trackEventMessage, clonedTrackEvent); // track products and revenue per product basis.


          this.trackingEventAndRevenuePerProduct(_trackEventMessage, products, true); // track both event and revenue on per product basis.
        } else {
          // track event and revenue as a whole as no product array is present.
          this.logEventAndCorrespondingRevenue(clonedTrackEvent, false);
        }
      }
    }, {
      key: "trackingEventAndRevenuePerProduct",
      value: function trackingEventAndRevenuePerProduct(trackEventMessage, products, shouldTrackEventPerProduct) {
        var _trackEventMessage$pr = trackEventMessage.properties,
            revenue = _trackEventMessage$pr.revenue,
            revenueType = _trackEventMessage$pr.revenueType,
            revenue_type = _trackEventMessage$pr.revenue_type;
        revenueType = revenueType || revenue_type;

        for (var index = 0; index < products.length; index++) {
          var product = products[index];
          trackEventMessage.properties = product;
          trackEventMessage.event = "Product Purchased";

          if (this.trackRevenuePerProduct) {
            if (revenueType) {
              trackEventMessage.properties.revenueType = revenueType;
            }

            if (revenue) {
              trackEventMessage.properties.revenue = revenue;
            }

            this.trackRevenue(trackEventMessage);
          }

          if (shouldTrackEventPerProduct) {
            this.logEventAndCorrespondingRevenue(trackEventMessage, true);
          }
        }
      } // Always to be called for general and top level events (and not product level)
      // For these events we expect top level revenue property.

    }, {
      key: "logEventAndCorrespondingRevenue",
      value: function logEventAndCorrespondingRevenue(rudderMessage, dontTrackRevenue) {
        var properties = rudderMessage.properties,
            event = rudderMessage.event;
        window.amplitude.getInstance().logEvent(event, properties);

        if (properties.revenue && !dontTrackRevenue) {
          this.trackRevenue(rudderMessage);
        }
      }
      /**
       * track page events base on destination settings. If more than one settings is enabled, multiple events may be logged for a single page event.
       * For example, if category of a page is present, and both trackAllPages and trackCategorizedPages are enabled, then 2 events will be tracked for
       * a single pageview - 'Loaded a page' and `Viewed page ${category}`.
       *
       * @memberof Amplitude
       */

    }, {
      key: "page",
      value: function page(rudderElement) {
        var _rudderElement$messag2, _rudderElement$messag3;

        logger.debug("in Amplitude page");
        this.setDeviceId(rudderElement);
        var _rudderElement$messag = rudderElement.message,
            properties = _rudderElement$messag.properties,
            name = _rudderElement$messag.name,
            category = _rudderElement$messag.category;
        var useNewPageEventNameFormat = ((_rudderElement$messag2 = rudderElement.message.integrations) === null || _rudderElement$messag2 === void 0 ? void 0 : (_rudderElement$messag3 = _rudderElement$messag2.AM) === null || _rudderElement$messag3 === void 0 ? void 0 : _rudderElement$messag3.useNewPageEventNameFormat) || false; // all pages

        if (this.trackAllPages) {
          var event = "Loaded a page";
          amplitude.getInstance().logEvent(event, properties);
        } // categorized pages


        if (category && this.trackCategorizedPages) {
          var _event;

          if (!useNewPageEventNameFormat) _event = "Viewed page ".concat(category);else _event = "Viewed ".concat(category, " Page");
          amplitude.getInstance().logEvent(_event, properties);
        } // named pages


        if (name && this.trackNamedPages) {
          var _event2;

          if (!useNewPageEventNameFormat) _event2 = "Viewed page ".concat(name);else _event2 = "Viewed ".concat(name, " Page");
          amplitude.getInstance().logEvent(_event2, properties);
        }
      }
    }, {
      key: "group",
      value: function group(rudderElement) {
        logger.debug("in Amplitude group");
        this.setDeviceId(rudderElement);
        var _rudderElement$messag4 = rudderElement.message,
            groupId = _rudderElement$messag4.groupId,
            traits = _rudderElement$messag4.traits;
        var groupTypeTrait = this.groupTypeTrait;
        var groupValueTrait = this.groupValueTrait;

        if (groupTypeTrait && groupValueTrait && traits) {
          var groupType = traits[groupTypeTrait];
          var groupValue = traits[groupValueTrait];
        }

        if (groupType && groupValue) {
          window.amplitude.getInstance().setGroup(groupTypeTrait, groupValueTrait);
        } else if (groupId) {
          // Similar as segment but not sure whether we need it as our cloud mode supports only the above if block
          window.amplitude.getInstance().setGroup("[Rudderstack] Group", groupId);
        } // https://developers.amplitude.com/docs/setting-user-properties#setting-group-properties
        // no other api for setting group properties for javascript

      }
    }, {
      key: "setDeviceId",
      value: function setDeviceId(rudderElement) {
        var anonymousId = rudderElement.message.anonymousId;

        if (this.preferAnonymousIdForDeviceId && anonymousId) {
          window.amplitude.getInstance().setDeviceId(anonymousId);
        }
      }
      /**
       * Tracks revenue with logRevenueV2() api based on revenue/price present in event payload. If neither of revenue/price present, it returns.
       * The event payload may contain ruddermessage of an original track event payload (from trackEvent method) or it is derived from a product
       * array (from trackingRevenuePerProduct) in an e-comm event.
       *
       * @param {*} rudderMessage
       * @returns
       * @memberof Amplitude
       */

    }, {
      key: "trackRevenue",
      value: function trackRevenue(rudderMessage) {
        var mapRevenueType = {
          "order completed": "Purchase",
          "completed order": "Purchase",
          "product purchased": "Purchase"
        };
        var properties = rudderMessage.properties,
            event = rudderMessage.event;
        var price = properties.price,
            productId = properties.productId,
            quantity = properties.quantity,
            revenue = properties.revenue,
            product_id = properties.product_id;
        var revenueType = properties.revenueType || properties.revenue_type || mapRevenueType[event.toLowerCase()];
        productId = productId || product_id; // If neither revenue nor price is present, then return
        // else send price and quantity from properties to amplitude
        // If price not present set price as revenue's value and force quantity to be 1.
        // Ultimately set quantity to 1 if not already present from above logic.

        if (!revenue && !price) {
          console.debug("revenue or price is not present.");
          return;
        }

        if (!price) {
          price = revenue;
          quantity = 1;
        }

        if (!quantity) {
          quantity = 1;
        }

        var amplitudeRevenue = new window.amplitude.Revenue().setPrice(price).setQuantity(quantity).setEventProperties(properties);

        if (revenueType) {
          amplitudeRevenue.setRevenueType(revenueType);
        }

        if (productId) {
          amplitudeRevenue.setProductId(productId);
        }

        if (amplitudeRevenue._properties) {
          delete amplitudeRevenue._properties.price;
          delete amplitudeRevenue._properties.productId;
          delete amplitudeRevenue._properties.quantity;
        }

        window.amplitude.getInstance().logRevenueV2(amplitudeRevenue);
      }
    }, {
      key: "getProductAttributes",
      value: function getProductAttributes(product) {
        return {
          productId: product.productId || product.product_id,
          sku: product.sku,
          name: product.name,
          price: product.price,
          quantity: product.quantity,
          category: product.category
        };
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("in Amplitude isLoaded");
        return !!(window.amplitude && window.amplitude.getInstance().options);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return !!(window.amplitude && window.amplitude.getInstance().options);
      }
    }]);

    return Amplitude;
  }();

  var Appcues = /*#__PURE__*/function () {
    function Appcues(config) {
      _classCallCheck(this, Appcues);

      this.accountId = config.accountId;
      this.apiKey = config.apiKey;
      this.name = NAME$2; // this.sendToAllDestinations = config.sendToAll;
    }

    _createClass(Appcues, [{
      key: "init",
      value: function init() {
        logger.debug("===in init Appcues===");
        ScriptLoader("appcues-id", "https://fast.appcues.com/".concat(this.accountId, ".js"));
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("in appcues isLoaded");
        return !!window.Appcues;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("in appcues isReady"); // This block of code enables us to send Appcues Flow events to all the other destinations connected to the same source (we might use it in future)
        // if (this.sendToAllDestinations && window.Appcues) {
        //   window.Appcues.on("all", function(eventName, event) {
        //     window.rudderanalytics.track(eventName, event, {
        //       integrations: {
        //         All: true,
        //         APPCUES: false
        //       }
        //     });
        //   });
        // }

        return !!window.Appcues;
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        var traits = rudderElement.message.context.traits;
        var userId = rudderElement.message.userId;

        if (userId) {
          window.Appcues.identify(userId, traits);
        } else {
          logger.error("user id is empty");
        }
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        var eventName = rudderElement.message.event;
        var properties = rudderElement.message.properties;

        if (eventName) {
          window.Appcues.track(eventName, properties);
        } else {
          logger.error("event name is empty");
        }
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        var _rudderElement$messag = rudderElement.message,
            properties = _rudderElement$messag.properties,
            name = _rudderElement$messag.name;
        window.Appcues.page(name, properties);
      } // To be uncommented after adding Reset feature to our SDK
      // reset() {
      //   window.Appcues.reset();
      // }

    }]);

    return Appcues;
  }();

  var BingAds = /*#__PURE__*/_createClass(function BingAds(config) {
    var _this = this;

    _classCallCheck(this, BingAds);

    this.loadBingadsScript = function () {
      (function (w, d, t, r, u) {
        var f, n, i;
        w[u] = w[u] || [], f = function f() {
          var o = {
            ti: _this.tagID
          };
          o.q = w[u], w[u] = new UET(o);
        }, n = d.createElement(t), n.src = r, n.async = 1, n.onload = n.onreadystatechange = function () {
          var s = this.readyState;
          s && s !== "loaded" && s !== "complete" || (f(), n.onload = n.onreadystatechange = null);
        }, i = d.getElementsByTagName(t)[0], i.parentNode.insertBefore(n, i);
      })(window, document, "script", "https://bat.bing.com/bat.js", "uetq");
    };

    this.init = function () {
      _this.loadBingadsScript();

      logger.debug("===in init BingAds===");
    };

    this.isLoaded = function () {
      logger.debug("in BingAds isLoaded");
      return !!window.uetq && window.uetq.push !== Array.prototype.push;
    };

    this.isReady = function () {
      logger.debug("in BingAds isReady");
      return !!(window.uetq && window.uetq.push !== Array.prototype.push);
    };

    this.track = function (rudderElement) {
      var _rudderElement$messag = rudderElement.message,
          type = _rudderElement$messag.type,
          properties = _rudderElement$messag.properties,
          event = _rudderElement$messag.event;
      var category = properties.category,
          currency = properties.currency,
          value = properties.value,
          revenue = properties.revenue,
          total = properties.total;
      var payload = {
        ea: type,
        el: event
      };

      if (category) {
        payload.ec = category;
      }

      if (currency) {
        payload.gc = currency;
      }

      if (value) {
        payload.gv = value;
      }

      if (revenue) {
        payload.gv = revenue;
      }

      if (total) {
        payload.gv = total;
      }

      window.uetq.push(payload);
    };

    this.page = function () {
      window.uetq.push("pageLoad");
    };

    this.tagID = config.tagID;
    this.name = NAME$3;
  });

  /*
  E-commerce support required for logPurchase support & other e-commerce events as track with productId changed
  */

  var Braze = /*#__PURE__*/function () {
    function Braze(config, analytics) {
      _classCallCheck(this, Braze);

      this.analytics = analytics;
      this.appKey = config.appKey;
      this.enableHtmlInAppMessages = config.enableHtmlInAppMessages || false;
      this.allowUserSuppliedJavascript = config.allowUserSuppliedJavascript || false;
      if (!config.appKey) this.appKey = "";
      this.endPoint = "";

      if (config.dataCenter) {
        var dataCenterArr = config.dataCenter.trim().split("-");

        if (dataCenterArr[0].toLowerCase() === "eu") {
          this.endPoint = "sdk.fra-01.braze.eu";
        } else {
          this.endPoint = "sdk.iad-".concat(dataCenterArr[1], ".braze.com");
        }
      }

      this.name = NAME$4;
      logger.debug("Config ", config);
    }
    /** https://js.appboycdn.com/web-sdk/latest/doc/ab.User.html#toc4
     */


    _createClass(Braze, [{
      key: "formatGender",
      value: function formatGender(gender) {
        if (!gender) return;
        if (typeof gender !== "string") return;
        var femaleGenders = ["woman", "female", "w", "f"];
        var maleGenders = ["man", "male", "m"];
        var otherGenders = ["other", "o"];
        if (femaleGenders.indexOf(gender.toLowerCase()) > -1) return window.appboy.ab.User.Genders.FEMALE;
        if (maleGenders.indexOf(gender.toLowerCase()) > -1) return window.appboy.ab.User.Genders.MALE;
        if (otherGenders.indexOf(gender.toLowerCase()) > -1) return window.appboy.ab.User.Genders.OTHER;
      }
    }, {
      key: "init",
      value: function init() {
        logger.debug("===in init Braze==="); // load appboy

        +function (a, p, P, b, y) {
          a.appboy = {};
          a.appboyQueue = [];

          for (var s = "initialize destroy getDeviceId toggleAppboyLogging setLogger openSession changeUser requestImmediateDataFlush requestFeedRefresh subscribeToFeedUpdates requestContentCardsRefresh subscribeToContentCardsUpdates logCardImpressions logCardClick logCardDismissal logFeedDisplayed logContentCardsDisplayed logInAppMessageImpression logInAppMessageClick logInAppMessageButtonClick logInAppMessageHtmlClick subscribeToNewInAppMessages subscribeToInAppMessage removeSubscription removeAllSubscriptions logCustomEvent logPurchase isPushSupported isPushBlocked isPushGranted isPushPermissionGranted registerAppboyPushMessages unregisterAppboyPushMessages trackLocation stopWebTracking resumeWebTracking wipeData ab ab.DeviceProperties ab.User ab.User.Genders ab.User.NotificationSubscriptionTypes ab.User.prototype.getUserId ab.User.prototype.setFirstName ab.User.prototype.setLastName ab.User.prototype.setEmail ab.User.prototype.setGender ab.User.prototype.setDateOfBirth ab.User.prototype.setCountry ab.User.prototype.setHomeCity ab.User.prototype.setLanguage ab.User.prototype.setEmailNotificationSubscriptionType ab.User.prototype.setPushNotificationSubscriptionType ab.User.prototype.setPhoneNumber ab.User.prototype.setAvatarImageUrl ab.User.prototype.setLastKnownLocation ab.User.prototype.setUserAttribute ab.User.prototype.setCustomUserAttribute ab.User.prototype.addToCustomAttributeArray ab.User.prototype.removeFromCustomAttributeArray ab.User.prototype.incrementCustomUserAttribute ab.User.prototype.addAlias ab.User.prototype.setCustomLocationAttribute ab.InAppMessage ab.InAppMessage.SlideFrom ab.InAppMessage.ClickAction ab.InAppMessage.DismissType ab.InAppMessage.OpenTarget ab.InAppMessage.ImageStyle ab.InAppMessage.TextAlignment ab.InAppMessage.Orientation ab.InAppMessage.CropType ab.InAppMessage.prototype.subscribeToClickedEvent ab.InAppMessage.prototype.subscribeToDismissedEvent ab.InAppMessage.prototype.removeSubscription ab.InAppMessage.prototype.removeAllSubscriptions ab.InAppMessage.prototype.closeMessage ab.InAppMessage.Button ab.InAppMessage.Button.prototype.subscribeToClickedEvent ab.InAppMessage.Button.prototype.removeSubscription ab.InAppMessage.Button.prototype.removeAllSubscriptions ab.SlideUpMessage ab.ModalMessage ab.FullScreenMessage ab.HtmlMessage ab.ControlMessage ab.Feed ab.Feed.prototype.getUnreadCardCount ab.ContentCards ab.ContentCards.prototype.getUnviewedCardCount ab.Card ab.Card.prototype.dismissCard ab.ClassicCard ab.CaptionedImage ab.Banner ab.ControlCard ab.WindowUtils display display.automaticallyShowNewInAppMessages display.showInAppMessage display.showFeed display.destroyFeed display.toggleFeed display.showContentCards display.hideContentCards display.toggleContentCards sharedLib".split(" "), i = 0; i < s.length; i++) {
            for (var m = s[i], k = a.appboy, l = m.split("."), j = 0; j < l.length - 1; j++) {
              k = k[l[j]];
            }

            k[l[j]] = new Function("return function ".concat(m.replace(/\./g, "_"), "(){window.appboyQueue.push(arguments); return true}"))();
          }

          window.appboy.getUser = function () {
            return new window.appboy.ab.User();
          };

          window.appboy.getCachedFeed = function () {
            return new window.appboy.ab.Feed();
          };

          window.appboy.getCachedContentCards = function () {
            return new window.appboy.ab.ContentCards();
          };

          (y = p.createElement(P)).type = "text/javascript";
          y.src = "https://js.appboycdn.com/web-sdk/2.4/appboy.min.js";
          y.async = 1;
          (b = p.getElementsByTagName(P)[0]).parentNode.insertBefore(y, b);
        }(window, document, "script");
        window.appboy.initialize(this.appKey, {
          enableLogging: true,
          baseUrl: this.endPoint,
          enableHtmlInAppMessages: this.enableHtmlInAppMessages,
          allowUserSuppliedJavascript: this.allowUserSuppliedJavascript
        });
        window.appboy.display.automaticallyShowNewInAppMessages();
        var userId = this.analytics.userId; // send userId if you have it https://js.appboycdn.com/web-sdk/latest/doc/module-appboy.html#.changeUser

        if (userId) appboy.changeUser(userId);
        window.appboy.openSession();
      }
    }, {
      key: "handleReservedProperties",
      value: function handleReservedProperties(props) {
        // remove reserved keys from custom event properties
        // https://www.appboy.com/documentation/Platform_Wide/#reserved-keys
        var reserved = ["time", "product_id", "quantity", "event_name", "price", "currency"];
        reserved.forEach(function (element) {
          delete props[element];
        });
        return props;
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        var userId = rudderElement.message.userId;
        var address = rudderElement.message.context.traits.address;
        var avatar = rudderElement.message.context.traits.avatar;
        var birthday = rudderElement.message.context.traits.birthday;
        var email = rudderElement.message.context.traits.email;
        var firstname = rudderElement.message.context.traits.firstname;
        var gender = rudderElement.message.context.traits.gender;
        var lastname = rudderElement.message.context.traits.lastname;
        var phone = rudderElement.message.context.traits.phone; // This is a hack to make a deep copy that is not recommended because it will often fail:

        var traits = JSON.parse(JSON.stringify(rudderElement.message.context.traits));
        window.appboy.changeUser(userId);
        window.appboy.getUser().setAvatarImageUrl(avatar);
        if (email) window.appboy.getUser().setEmail(email);
        if (firstname) window.appboy.getUser().setFirstName(firstname);
        if (gender) window.appboy.getUser().setGender(this.formatGender(gender));
        if (lastname) window.appboy.getUser().setLastName(lastname);
        if (phone) window.appboy.getUser().setPhoneNumber(phone);

        if (address) {
          window.appboy.getUser().setCountry(address.country);
          window.appboy.getUser().setHomeCity(address.city);
        }

        if (birthday) {
          window.appboy.getUser().setDateOfBirth(birthday.getUTCFullYear(), birthday.getUTCMonth() + 1, birthday.getUTCDate());
        } // remove reserved keys https://www.appboy.com/documentation/Platform_Wide/#reserved-keys


        var reserved = ["avatar", "address", "birthday", "email", "id", "firstname", "gender", "lastname", "phone", "facebook", "twitter", "first_name", "last_name", "dob", "external_id", "country", "home_city", "bio", "gender", "phone", "email_subscribe", "push_subscribe"];
        reserved.forEach(function (element) {
          delete traits[element];
        });
        Object.keys(traits).forEach(function (key) {
          window.appboy.getUser().setCustomUserAttribute(key, traits[key]);
        });
      }
    }, {
      key: "handlePurchase",
      value: function handlePurchase(properties, userId) {
        var products = properties.products;
        var currencyCode = properties.currency;
        window.appboy.changeUser(userId); // del used properties

        del(properties, "products");
        del(properties, "currency"); // we have to make a separate call to appboy for each product

        products.forEach(function (product) {
          var productId = product.product_id;
          var price = product.price;
          var quantity = product.quantity;
          if (quantity && price && productId) window.appboy.logPurchase(productId, price, currencyCode, quantity, properties);
        });
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        var userId = rudderElement.message.userId;
        var eventName = rudderElement.message.event;
        var properties = rudderElement.message.properties;
        window.appboy.changeUser(userId);

        if (eventName.toLowerCase() === "order completed") {
          this.handlePurchase(properties, userId);
        } else {
          properties = this.handleReservedProperties(properties);
          window.appboy.logCustomEvent(eventName, properties);
        }
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        var userId = rudderElement.message.userId;
        var eventName = rudderElement.message.name;
        var properties = rudderElement.message.properties;
        properties = this.handleReservedProperties(properties);
        window.appboy.changeUser(userId);
        window.appboy.logCustomEvent(eventName, properties);
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        return window.appboyQueue === null;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return window.appboyQueue === null;
      }
    }]);

    return Braze;
  }();

  var Bugsnag = /*#__PURE__*/function () {
    function Bugsnag(config) {
      _classCallCheck(this, Bugsnag);

      this.releaseStage = config.releaseStage;
      this.apiKey = config.apiKey;
      this.name = NAME$5;
      this.setIntervalHandler = undefined;
    }

    _createClass(Bugsnag, [{
      key: "init",
      value: function init() {
        logger.debug("===in init Bugsnag===");
        ScriptLoader("bugsnag-id", "https://d2wy8f7a9ursnm.cloudfront.net/v6/bugsnag.min.js");
        this.setIntervalHandler = setInterval(this.initBugsnagClient.bind(this), 1000);
      }
    }, {
      key: "initBugsnagClient",
      value: function initBugsnagClient() {
        if (window.bugsnag !== undefined) {
          window.bugsnagClient = window.bugsnag(this.apiKey);
          window.bugsnagClient.releaseStage = this.releaseStage;
          clearInterval(this.setIntervalHandler);
        }
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("in bugsnag isLoaded");
        return !!window.bugsnagClient;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("in bugsnag isReady");
        return !!window.bugsnagClient;
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        var traits = rudderElement.message.context.traits;
        var traitsFinal = {
          id: rudderElement.message.userId || rudderElement.message.anonymousId,
          name: traits.name,
          email: traits.email
        };
        window.bugsnagClient.user = traitsFinal;
        window.bugsnagClient.notify(new Error("error in identify"));
      }
    }]);

    return Bugsnag;
  }();

  /**
   * toString ref.
   */
  var toString$2 = Object.prototype.toString;
  /**
   * Return the type of `val`.
   *
   * @param {Mixed} val
   * @return {String}
   * @api public
   */

  var componentType$2 = function componentType(val) {
    switch (toString$2.call(val)) {
      case '[object Function]':
        return 'function';

      case '[object Date]':
        return 'date';

      case '[object RegExp]':
        return 'regexp';

      case '[object Arguments]':
        return 'arguments';

      case '[object Array]':
        return 'array';

      case '[object String]':
        return 'string';
    }

    if (val === null) return 'null';
    if (val === undefined) return 'undefined';
    if (val && val.nodeType === 1) return 'element';
    if (val === Object(val)) return 'object';
    return _typeof(val);
  };

  /**
   * Global Names
   */
  var globals = /\b(Array|Date|Object|Math|JSON)\b/g;
  /**
   * Return immediate identifiers parsed from `str`.
   *
   * @param {String} str
   * @param {String|Function} map function or prefix
   * @return {Array}
   * @api public
   */

  var componentProps = function componentProps(str, fn) {
    var p = unique(props(str));
    if (fn && 'string' == typeof fn) fn = prefixed(fn);
    if (fn) return map(str, p, fn);
    return p;
  };
  /**
   * Return immediate identifiers in `str`.
   *
   * @param {String} str
   * @return {Array}
   * @api private
   */


  function props(str) {
    return str.replace(/\.\w+|\w+ *\(|"[^"]*"|'[^']*'|\/([^/]+)\//g, '').replace(globals, '').match(/[a-zA-Z_]\w*/g) || [];
  }
  /**
   * Return `str` with `props` mapped with `fn`.
   *
   * @param {String} str
   * @param {Array} props
   * @param {Function} fn
   * @return {String}
   * @api private
   */


  function map(str, props, fn) {
    var re = /\.\w+|\w+ *\(|"[^"]*"|'[^']*'|\/([^/]+)\/|[a-zA-Z_]\w*/g;
    return str.replace(re, function (_) {
      if ('(' == _[_.length - 1]) return fn(_);
      if (!~props.indexOf(_)) return _;
      return fn(_);
    });
  }
  /**
   * Return unique array.
   *
   * @param {Array} arr
   * @return {Array}
   * @api private
   */


  function unique(arr) {
    var ret = [];

    for (var i = 0; i < arr.length; i++) {
      if (~ret.indexOf(arr[i])) continue;
      ret.push(arr[i]);
    }

    return ret;
  }
  /**
   * Map with prefix `str`.
   */


  function prefixed(str) {
    return function (_) {
      return str + _;
    };
  }

  /**
   * Module Dependencies
   */

  var expr;

  try {
    expr = componentProps;
  } catch (e) {
    expr = componentProps;
  }
  /**
   * Expose `toFunction()`.
   */


  var toFunction_1 = toFunction;
  /**
   * Convert `obj` to a `Function`.
   *
   * @param {Mixed} obj
   * @return {Function}
   * @api private
   */

  function toFunction(obj) {
    switch ({}.toString.call(obj)) {
      case '[object Object]':
        return objectToFunction(obj);

      case '[object Function]':
        return obj;

      case '[object String]':
        return stringToFunction(obj);

      case '[object RegExp]':
        return regexpToFunction(obj);

      default:
        return defaultToFunction(obj);
    }
  }
  /**
   * Default to strict equality.
   *
   * @param {Mixed} val
   * @return {Function}
   * @api private
   */


  function defaultToFunction(val) {
    return function (obj) {
      return val === obj;
    };
  }
  /**
   * Convert `re` to a function.
   *
   * @param {RegExp} re
   * @return {Function}
   * @api private
   */


  function regexpToFunction(re) {
    return function (obj) {
      return re.test(obj);
    };
  }
  /**
   * Convert property `str` to a function.
   *
   * @param {String} str
   * @return {Function}
   * @api private
   */


  function stringToFunction(str) {
    // immediate such as "> 20"
    if (/^ *\W+/.test(str)) return new Function('_', 'return _ ' + str); // properties such as "name.first" or "age > 18" or "age > 18 && age < 36"

    return new Function('_', 'return ' + get$2(str));
  }
  /**
   * Convert `object` to a function.
   *
   * @param {Object} object
   * @return {Function}
   * @api private
   */


  function objectToFunction(obj) {
    var match = {};

    for (var key in obj) {
      match[key] = typeof obj[key] === 'string' ? defaultToFunction(obj[key]) : toFunction(obj[key]);
    }

    return function (val) {
      if (_typeof(val) !== 'object') return false;

      for (var key in match) {
        if (!(key in val)) return false;
        if (!match[key](val[key])) return false;
      }

      return true;
    };
  }
  /**
   * Built the getter function. Supports getter style functions
   *
   * @param {String} str
   * @return {String}
   * @api private
   */


  function get$2(str) {
    var props = expr(str);
    if (!props.length) return '_.' + str;
    var val, i, prop;

    for (i = 0; i < props.length; i++) {
      prop = props[i];
      val = '_.' + prop;
      val = "('function' == typeof " + val + " ? " + val + "() : " + val + ")"; // mimic negative lookbehind to avoid problems with nested properties

      str = stripNested(prop, str, val);
    }

    return str;
  }
  /**
   * Mimic negative lookbehind to avoid problems with nested properties.
   *
   * See: http://blog.stevenlevithan.com/archives/mimic-lookbehind-javascript
   *
   * @param {String} prop
   * @param {String} str
   * @param {String} val
   * @return {String}
   * @api private
   */


  function stripNested(prop, str, val) {
    return str.replace(new RegExp('(\\.)?' + prop, 'g'), function ($0, $1) {
      return $1 ? $0 : val;
    });
  }

  /**
   * Module dependencies.
   */

  try {
    var type$1 = componentType$2;
  } catch (err) {
    var type$1 = componentType$2;
  }
  /**
   * HOP reference.
   */


  var has$3 = Object.prototype.hasOwnProperty;
  /**
   * Iterate the given `obj` and invoke `fn(val, i)`
   * in optional context `ctx`.
   *
   * @param {String|Array|Object} obj
   * @param {Function} fn
   * @param {Object} [ctx]
   * @api public
   */

  var componentEach = function componentEach(obj, fn, ctx) {
    fn = toFunction_1(fn);
    ctx = ctx || this;

    switch (type$1(obj)) {
      case 'array':
        return array(obj, fn, ctx);

      case 'object':
        if ('number' == typeof obj.length) return array(obj, fn, ctx);
        return object(obj, fn, ctx);

      case 'string':
        return string(obj, fn, ctx);
    }
  };
  /**
   * Iterate string chars.
   *
   * @param {String} obj
   * @param {Function} fn
   * @param {Object} ctx
   * @api private
   */


  function string(obj, fn, ctx) {
    for (var i = 0; i < obj.length; ++i) {
      fn.call(ctx, obj.charAt(i), i);
    }
  }
  /**
   * Iterate object keys.
   *
   * @param {Object} obj
   * @param {Function} fn
   * @param {Object} ctx
   * @api private
   */


  function object(obj, fn, ctx) {
    for (var key in obj) {
      if (has$3.call(obj, key)) {
        fn.call(ctx, key, obj[key]);
      }
    }
  }
  /**
   * Iterate array-ish.
   *
   * @param {Array|Object} obj
   * @param {Function} fn
   * @param {Object} ctx
   * @api private
   */


  function array(obj, fn, ctx) {
    for (var i = 0; i < obj.length; ++i) {
      fn.call(ctx, obj[i], i);
    }
  }

  /**
   * Cache whether `<body>` exists.
   */

  var body = false;
  /**
   * Callbacks to call when the body exists.
   */

  var callbacks = [];
  /**
   * Export a way to add handlers to be invoked once the body exists.
   *
   * @param {Function} callback  A function to call when the body exists.
   */

  var onBody = function onBody(callback) {
    if (body) {
      call(callback);
    } else {
      callbacks.push(callback);
    }
  };
  /**
   * Set an interval to check for `document.body`.
   */


  var interval = setInterval(function () {
    if (!document.body) return;
    body = true;
    componentEach(callbacks, call);
    clearInterval(interval);
  }, 5);
  /**
   * Call a callback, passing it the body.
   *
   * @param {Function} callback  The callback to call.
   */

  function call(callback) {
    callback(document.body);
  }

  var Chartbeat = /*#__PURE__*/function () {
    function Chartbeat(config, analytics) {
      _classCallCheck(this, Chartbeat);

      this.analytics = analytics; // use this to modify failed integrations or for passing events from callback to other destinations

      this._sf_async_config = window._sf_async_config = window._sf_async_config || {};
      window._sf_async_config.useCanonical = true;
      window._sf_async_config.uid = config.uid;
      window._sf_async_config.domain = config.domain;
      this.isVideo = !!config.video;
      this.sendNameAndCategoryAsTitle = config.sendNameAndCategoryAsTitle || true;
      this.subscriberEngagementKeys = config.subscriberEngagementKeys || [];
      this.replayEvents = [];
      this.failed = false;
      this.isFirstPageCallMade = false;
      this.name = NAME$6;
    }

    _createClass(Chartbeat, [{
      key: "init",
      value: function init() {
        logger.debug("===in init Chartbeat===");
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("in Chartbeat identify");
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("in Chartbeat track");
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("in Chartbeat page");
        this.loadConfig(rudderElement);

        if (!this.isFirstPageCallMade) {
          this.isFirstPageCallMade = true;
          this.initAfterPage();
        } else {
          if (this.failed) {
            logger.debug("===ignoring cause failed integration===");
            this.replayEvents = [];
            return;
          }

          if (!this.isLoaded() && !this.failed) {
            logger.debug("===pushing to replay queue for chartbeat===");
            this.replayEvents.push(["page", rudderElement]);
            return;
          }

          logger.debug("===processing page event in chartbeat===");
          var properties = rudderElement.message.properties;
          window.pSUPERFLY.virtualPage(properties.path);
        }
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("in Chartbeat isLoaded");

        if (!this.isFirstPageCallMade) {
          return true;
        }

        return !!window.pSUPERFLY;
      }
    }, {
      key: "isFailed",
      value: function isFailed() {
        return this.failed;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return !!window.pSUPERFLY;
      }
    }, {
      key: "loadConfig",
      value: function loadConfig(rudderElement) {
        var properties = rudderElement.message.properties;
        var category = properties ? properties.category : undefined;
        var name = rudderElement.message.name;
        var author = properties ? properties.author : undefined;
        var title;

        if (this.sendNameAndCategoryAsTitle) {
          title = category && name ? "".concat(category, " ").concat(name) : name;
        }

        if (category) window._sf_async_config.sections = category;
        if (author) window._sf_async_config.authors = author;
        if (title) window._sf_async_config.title = title;

        var _cbq = window._cbq = window._cbq || [];

        for (var key in properties) {
          if (!properties.hasOwnProperty(key)) continue;

          if (this.subscriberEngagementKeys.indexOf(key) > -1) {
            _cbq.push([key, properties[key]]);
          }
        }
      }
    }, {
      key: "initAfterPage",
      value: function initAfterPage() {
        var _this = this;

        onBody(function () {
          var script = _this.isVideo ? "chartbeat_video.js" : "chartbeat.js";

          function loadChartbeat() {
            var e = document.createElement("script");
            var n = document.getElementsByTagName("script")[0];
            e.type = "text/javascript";
            e.async = true;
            e.src = "//static.chartbeat.com/js/".concat(script);
            n.parentNode.insertBefore(e, n);
          }

          loadChartbeat();
        });

        this._isReady(this).then(function (instance) {
          logger.debug("===replaying on chartbeat===");
          instance.replayEvents.forEach(function (event) {
            instance[event[0]](event[1]);
          });
        });
      }
    }, {
      key: "pause",
      value: function pause(time) {
        return new Promise(function (resolve) {
          setTimeout(resolve, time);
        });
      }
    }, {
      key: "_isReady",
      value: function _isReady(instance) {
        var _this2 = this;

        var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return new Promise(function (resolve) {
          if (_this2.isLoaded()) {
            _this2.failed = false;
            logger.debug("===chartbeat loaded successfully===");
            instance.analytics.emit("ready");
            return resolve(instance);
          }

          if (time >= MAX_WAIT_FOR_INTEGRATION_LOAD) {
            _this2.failed = true;
            logger.debug("===chartbeat failed===");
            return resolve(instance);
          }

          _this2.pause(INTEGRATION_LOAD_CHECK_INTERVAL).then(function () {
            return _this2._isReady(instance, time + INTEGRATION_LOAD_CHECK_INTERVAL).then(resolve);
          });
        });
      }
    }]);

    return Chartbeat;
  }();

  var Clevertap = /*#__PURE__*/function () {
    function Clevertap(config) {
      _classCallCheck(this, Clevertap);

      this.accountId = config.accountId;
      this.apiKey = config.passcode;
      this.name = NAME$7;
      this.region = config.region;
      this.keysToExtract = ["context.traits"];
      this.exclusionKeys = ["email", "E-mail", "Email", "phone", "Phone", "name", "Name", "gender", "Gender", "birthday", "Birthday", "anonymousId", "userId", "lastName", "lastname", "last_name", "firstName", "firstname", "first_name", "employed", "education", "married", "customerType"];
    }

    _createClass(Clevertap, [{
      key: "init",
      value: function init() {
        logger.debug("===in init Clevertap===");
        var sourceUrl = document.location.protocol == "https:" ? "https://d2r1yp2w7bby2u.cloudfront.net/js/a.js" : "http://static.clevertap.com/js/a.js";
        window.clevertap = {
          event: [],
          profile: [],
          account: [],
          onUserLogin: [],
          notifications: []
        };
        window.clevertap.enablePersonalization = true;
        window.clevertap.account.push({
          id: this.accountId
        });

        if (this.region && this.region !== "none") {
          window.clevertap.region.push(this.region);
        }

        ScriptLoader("clevertap-integration", sourceUrl);
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("in clevertap isLoaded");
        return !!window.clevertap && window.clevertap.logout !== undefined;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("in clevertap isReady");
        return !!window.clevertap && window.clevertap.logout !== undefined;
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("in clevertap identify");
        var message = rudderElement.message;

        if (!(message.context && message.context.traits)) {
          logger.error("user traits not present");
          return;
        }

        var _getDefinedTraits = getDefinedTraits(message),
            userId = _getDefinedTraits.userId,
            email = _getDefinedTraits.email,
            phone = _getDefinedTraits.phone,
            name = _getDefinedTraits.name;

        var payload = {
          Name: name,
          Identity: userId,
          Email: email,
          Phone: phone,
          Gender: getValue(message, "context.traits.gender"),
          DOB: getValue(message, "context.traits.birthday"),
          Photo: getValue(message, "context.traits.avatar"),
          Employed: getValue(message, "context.traits.employed"),
          Education: getValue(message, "context.traits.education"),
          Married: getValue(message, "context.traits.married"),
          "Customer Type": getValue(message, "context.traits.customerType")
        }; // Extract other K-V property from traits about user custom properties

        try {
          payload = extractCustomFields(message, payload, this.keysToExtract, this.exclusionKeys);
        } catch (err) {
          logger.debug("Error occured at extractCustomFields ".concat(err));
        }

        Object.keys(payload).map(function (key) {
          if (isObject$1(payload[key])) {
            logger.debug("cannot process, unsupported traits");
            return;
          }
        });
        window.clevertap.onUserLogin.push({
          Site: payload
        });
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("in clevertap track");
        var _rudderElement$messag = rudderElement.message,
            event = _rudderElement$messag.event,
            properties = _rudderElement$messag.properties;

        if (properties) {
          if (event === "Order Completed") {
            var ecomProperties = {
              "Charged ID": properties.checkout_id,
              Amount: properties.revenue,
              Items: properties.products
            }; // Extract other K-V property from traits about user custom properties

            try {
              ecomProperties = extractCustomFields(rudderElement.message, ecomProperties, ["properties"], ["checkout_id", "revenue", "products"]);
            } catch (err) {
              logger.debug("Error occured at extractCustomFields ".concat(err));
            }

            window.clevertap.event.push("Charged", ecomProperties);
          } else {
            Object.keys(properties).map(function (key) {
              if (isObject$1(properties[key]) || isArray$1(properties[key])) {
                logger.debug("cannot process, unsupported event");
                return;
              }
            });
            window.clevertap.event.push(event, properties);
          }
        } else if (event === "Order Completed") {
          window.clevertap.event.push("Charged");
        } else {
          window.clevertap.event.push(event);
        }
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("in clevertap page");
        var _rudderElement$messag2 = rudderElement.message,
            name = _rudderElement$messag2.name,
            properties = _rudderElement$messag2.properties;
        var eventName;

        if (properties && properties.category && name) {
          eventName = "WebPage Viewed ".concat(name, " ").concat(properties.category);
        } else if (name) {
          eventName = "WebPage Viewed ".concat(name);
        } else {
          eventName = "WebPage Viewed";
        }

        if (properties) {
          Object.keys(properties).map(function (key) {
            if (isObject$1(properties[key]) || isArray$1(properties[key])) {
              logger.debug("cannot process, unsupported event");
              return;
            }
          });
          window.clevertap.event.push(eventName, properties);
        } else {
          window.clevertap.event.push(eventName);
        }
      }
    }]);

    return Clevertap;
  }();

  var Comscore = /*#__PURE__*/function () {
    function Comscore(config, analytics) {
      _classCallCheck(this, Comscore);

      this.c2ID = config.c2ID;
      this.analytics = analytics;
      this.comScoreBeaconParam = config.comScoreBeaconParam ? config.comScoreBeaconParam : {};
      this.isFirstPageCallMade = false;
      this.failed = false;
      this.comScoreParams = {};
      this.replayEvents = [];
      this.name = NAME$8;
    }

    _createClass(Comscore, [{
      key: "init",
      value: function init() {
        logger.debug("===in init Comscore init===");
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("in Comscore identify");
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("in Comscore track");
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("in Comscore page");
        this.loadConfig(rudderElement);

        if (!this.isFirstPageCallMade) {
          this.isFirstPageCallMade = true;
          this.initAfterPage();
        } else {
          if (this.failed) {
            this.replayEvents = [];
            return;
          }

          if (!this.isLoaded() && !this.failed) {
            this.replayEvents.push(["page", rudderElement]);
            return;
          }

          var properties = rudderElement.message.properties; // window.COMSCORE.beacon({c1:"2", c2: ""});
          // this.comScoreParams = this.mapComscoreParams(properties);

          window.COMSCORE.beacon(this.comScoreParams);
        }
      }
    }, {
      key: "loadConfig",
      value: function loadConfig(rudderElement) {
        logger.debug("=====in loadConfig=====");
        this.comScoreParams = this.mapComscoreParams(rudderElement.message.properties);
        window._comscore = window._comscore || [];

        window._comscore.push(this.comScoreParams);
      }
    }, {
      key: "initAfterPage",
      value: function initAfterPage() {
        logger.debug("=====in initAfterPage=====");

        (function () {
          var s = document.createElement("script");
          var el = document.getElementsByTagName("script")[0];
          s.async = true;
          s.src = "".concat(document.location.protocol == "https:" ? "https://sb" : "http://b", ".scorecardresearch.com/beacon.js");
          el.parentNode.insertBefore(s, el);
        })();

        this._isReady(this).then(function (instance) {
          instance.replayEvents.forEach(function (event) {
            instance[event[0]](event[1]);
          });
        });
      }
    }, {
      key: "pause",
      value: function pause(time) {
        return new Promise(function (resolve) {
          setTimeout(resolve, time);
        });
      }
    }, {
      key: "_isReady",
      value: function _isReady(instance) {
        var _this = this;

        var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return new Promise(function (resolve) {
          if (_this.isLoaded()) {
            _this.failed = false;
            instance.analytics.emit("ready");
            return resolve(instance);
          }

          if (time >= MAX_WAIT_FOR_INTEGRATION_LOAD) {
            _this.failed = true;
            return resolve(instance);
          }

          _this.pause(INTEGRATION_LOAD_CHECK_INTERVAL).then(function () {
            return _this._isReady(instance, time + INTEGRATION_LOAD_CHECK_INTERVAL).then(resolve);
          });
        });
      }
    }, {
      key: "mapComscoreParams",
      value: function mapComscoreParams(properties) {
        logger.debug("=====in mapComscoreParams=====");
        var comScoreBeaconParamsMap = this.comScoreBeaconParam;
        var comScoreParams = {};
        Object.keys(comScoreBeaconParamsMap).forEach(function (property) {
          if (property in properties) {
            var key = comScoreBeaconParamsMap[property];
            var value = properties[property];
            comScoreParams[key] = value;
          }
        });
        comScoreParams.c1 = "2";
        comScoreParams.c2 = this.c2ID;
        /* if (this.options.comscorekw.length) {
          comScoreParams.comscorekw = this.options.comscorekw;
        } */

        logger.debug("=====in mapComscoreParams=====", comScoreParams);
        return comScoreParams;
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("in Comscore isLoaded");

        if (!this.isFirstPageCallMade) {
          return true;
        }

        return !!window.COMSCORE;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return !!window.COMSCORE;
      }
    }]);

    return Comscore;
  }();

  var crypt = createCommonjsModule(function (module) {
    (function () {
      var base64map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
          crypt = {
        // Bit-wise rotation left
        rotl: function rotl(n, b) {
          return n << b | n >>> 32 - b;
        },
        // Bit-wise rotation right
        rotr: function rotr(n, b) {
          return n << 32 - b | n >>> b;
        },
        // Swap big-endian to little-endian and vice versa
        endian: function endian(n) {
          // If number given, swap endian
          if (n.constructor == Number) {
            return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
          } // Else, assume array and swap all items


          for (var i = 0; i < n.length; i++) {
            n[i] = crypt.endian(n[i]);
          }

          return n;
        },
        // Generate an array of any length of random bytes
        randomBytes: function randomBytes(n) {
          for (var bytes = []; n > 0; n--) {
            bytes.push(Math.floor(Math.random() * 256));
          }

          return bytes;
        },
        // Convert a byte array to big-endian 32-bit words
        bytesToWords: function bytesToWords(bytes) {
          for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8) {
            words[b >>> 5] |= bytes[i] << 24 - b % 32;
          }

          return words;
        },
        // Convert big-endian 32-bit words to a byte array
        wordsToBytes: function wordsToBytes(words) {
          for (var bytes = [], b = 0; b < words.length * 32; b += 8) {
            bytes.push(words[b >>> 5] >>> 24 - b % 32 & 0xFF);
          }

          return bytes;
        },
        // Convert a byte array to a hex string
        bytesToHex: function bytesToHex(bytes) {
          for (var hex = [], i = 0; i < bytes.length; i++) {
            hex.push((bytes[i] >>> 4).toString(16));
            hex.push((bytes[i] & 0xF).toString(16));
          }

          return hex.join('');
        },
        // Convert a hex string to a byte array
        hexToBytes: function hexToBytes(hex) {
          for (var bytes = [], c = 0; c < hex.length; c += 2) {
            bytes.push(parseInt(hex.substr(c, 2), 16));
          }

          return bytes;
        },
        // Convert a byte array to a base-64 string
        bytesToBase64: function bytesToBase64(bytes) {
          for (var base64 = [], i = 0; i < bytes.length; i += 3) {
            var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];

            for (var j = 0; j < 4; j++) {
              if (i * 8 + j * 6 <= bytes.length * 8) base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 0x3F));else base64.push('=');
            }
          }

          return base64.join('');
        },
        // Convert a base-64 string to a byte array
        base64ToBytes: function base64ToBytes(base64) {
          // Remove non-base-64 characters
          base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

          for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
            if (imod4 == 0) continue;
            bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
          }

          return bytes;
        }
      };
      module.exports = crypt;
    })();
  });

  var charenc = {
    // UTF-8 encoding
    utf8: {
      // Convert a string to a byte array
      stringToBytes: function stringToBytes(str) {
        return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
      },
      // Convert a byte array to a string
      bytesToString: function bytesToString(bytes) {
        return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
      }
    },
    // Binary encoding
    bin: {
      // Convert a string to a byte array
      stringToBytes: function stringToBytes(str) {
        for (var bytes = [], i = 0; i < str.length; i++) {
          bytes.push(str.charCodeAt(i) & 0xFF);
        }

        return bytes;
      },
      // Convert a byte array to a string
      bytesToString: function bytesToString(bytes) {
        for (var str = [], i = 0; i < bytes.length; i++) {
          str.push(String.fromCharCode(bytes[i]));
        }

        return str.join('');
      }
    }
  };
  var charenc_1 = charenc;

  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually
  var isBuffer_1 = function isBuffer_1(obj) {
    return obj != null && (isBuffer$1(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
  };

  function isBuffer$1(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
  } // For Node v0.10 support. Remove this eventually.


  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer$1(obj.slice(0, 0));
  }

  var md5$1 = createCommonjsModule(function (module) {
    (function () {
      var crypt$1 = crypt,
          utf8 = charenc_1.utf8,
          isBuffer = isBuffer_1,
          bin = charenc_1.bin,
          // The core
      md5 = function md5(message, options) {
        // Convert to byte array
        if (message.constructor == String) {
          if (options && options.encoding === 'binary') message = bin.stringToBytes(message);else message = utf8.stringToBytes(message);
        } else if (isBuffer(message)) message = Array.prototype.slice.call(message, 0);else if (!Array.isArray(message) && message.constructor !== Uint8Array) message = message.toString(); // else, assume byte array already

        var m = crypt$1.bytesToWords(message),
            l = message.length * 8,
            a = 1732584193,
            b = -271733879,
            c = -1732584194,
            d = 271733878; // Swap endian

        for (var i = 0; i < m.length; i++) {
          m[i] = (m[i] << 8 | m[i] >>> 24) & 0x00FF00FF | (m[i] << 24 | m[i] >>> 8) & 0xFF00FF00;
        } // Padding


        m[l >>> 5] |= 0x80 << l % 32;
        m[(l + 64 >>> 9 << 4) + 14] = l; // Method shortcuts

        var FF = md5._ff,
            GG = md5._gg,
            HH = md5._hh,
            II = md5._ii;

        for (var i = 0; i < m.length; i += 16) {
          var aa = a,
              bb = b,
              cc = c,
              dd = d;
          a = FF(a, b, c, d, m[i + 0], 7, -680876936);
          d = FF(d, a, b, c, m[i + 1], 12, -389564586);
          c = FF(c, d, a, b, m[i + 2], 17, 606105819);
          b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
          a = FF(a, b, c, d, m[i + 4], 7, -176418897);
          d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
          c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
          b = FF(b, c, d, a, m[i + 7], 22, -45705983);
          a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
          d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
          c = FF(c, d, a, b, m[i + 10], 17, -42063);
          b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
          a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
          d = FF(d, a, b, c, m[i + 13], 12, -40341101);
          c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
          b = FF(b, c, d, a, m[i + 15], 22, 1236535329);
          a = GG(a, b, c, d, m[i + 1], 5, -165796510);
          d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
          c = GG(c, d, a, b, m[i + 11], 14, 643717713);
          b = GG(b, c, d, a, m[i + 0], 20, -373897302);
          a = GG(a, b, c, d, m[i + 5], 5, -701558691);
          d = GG(d, a, b, c, m[i + 10], 9, 38016083);
          c = GG(c, d, a, b, m[i + 15], 14, -660478335);
          b = GG(b, c, d, a, m[i + 4], 20, -405537848);
          a = GG(a, b, c, d, m[i + 9], 5, 568446438);
          d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
          c = GG(c, d, a, b, m[i + 3], 14, -187363961);
          b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
          a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
          d = GG(d, a, b, c, m[i + 2], 9, -51403784);
          c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
          b = GG(b, c, d, a, m[i + 12], 20, -1926607734);
          a = HH(a, b, c, d, m[i + 5], 4, -378558);
          d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
          c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
          b = HH(b, c, d, a, m[i + 14], 23, -35309556);
          a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
          d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
          c = HH(c, d, a, b, m[i + 7], 16, -155497632);
          b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
          a = HH(a, b, c, d, m[i + 13], 4, 681279174);
          d = HH(d, a, b, c, m[i + 0], 11, -358537222);
          c = HH(c, d, a, b, m[i + 3], 16, -722521979);
          b = HH(b, c, d, a, m[i + 6], 23, 76029189);
          a = HH(a, b, c, d, m[i + 9], 4, -640364487);
          d = HH(d, a, b, c, m[i + 12], 11, -421815835);
          c = HH(c, d, a, b, m[i + 15], 16, 530742520);
          b = HH(b, c, d, a, m[i + 2], 23, -995338651);
          a = II(a, b, c, d, m[i + 0], 6, -198630844);
          d = II(d, a, b, c, m[i + 7], 10, 1126891415);
          c = II(c, d, a, b, m[i + 14], 15, -1416354905);
          b = II(b, c, d, a, m[i + 5], 21, -57434055);
          a = II(a, b, c, d, m[i + 12], 6, 1700485571);
          d = II(d, a, b, c, m[i + 3], 10, -1894986606);
          c = II(c, d, a, b, m[i + 10], 15, -1051523);
          b = II(b, c, d, a, m[i + 1], 21, -2054922799);
          a = II(a, b, c, d, m[i + 8], 6, 1873313359);
          d = II(d, a, b, c, m[i + 15], 10, -30611744);
          c = II(c, d, a, b, m[i + 6], 15, -1560198380);
          b = II(b, c, d, a, m[i + 13], 21, 1309151649);
          a = II(a, b, c, d, m[i + 4], 6, -145523070);
          d = II(d, a, b, c, m[i + 11], 10, -1120210379);
          c = II(c, d, a, b, m[i + 2], 15, 718787259);
          b = II(b, c, d, a, m[i + 9], 21, -343485551);
          a = a + aa >>> 0;
          b = b + bb >>> 0;
          c = c + cc >>> 0;
          d = d + dd >>> 0;
        }

        return crypt$1.endian([a, b, c, d]);
      }; // Auxiliary functions


      md5._ff = function (a, b, c, d, x, s, t) {
        var n = a + (b & c | ~b & d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
      };

      md5._gg = function (a, b, c, d, x, s, t) {
        var n = a + (b & d | c & ~d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
      };

      md5._hh = function (a, b, c, d, x, s, t) {
        var n = a + (b ^ c ^ d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
      };

      md5._ii = function (a, b, c, d, x, s, t) {
        var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
      }; // Package private blocksize


      md5._blocksize = 16;
      md5._digestsize = 16;

      module.exports = function (message, options) {
        if (message === undefined || message === null) throw new Error('Illegal argument ' + message);
        var digestbytes = crypt$1.wordsToBytes(md5(message, options));
        return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt$1.bytesToHex(digestbytes);
      };
    })();
  });

  var handleCommonFields = function handleCommonFields(rudderElement, hashMethod) {
    var message = rudderElement.message;
    var properties = message.properties;
    var setEmail = {};
    var setZipcode = {};
    var finalRequest = [{
      event: "setCustomerId",
      id: md5$1(message.userId)
    }, {
      event: "setRetailerVisitorId",
      id: md5$1(message.anonymousId)
    }];

    if (properties && properties.email) {
      var email = properties.email.trim().toLowerCase();
      setEmail.event = "setEmail";
      setEmail.hash_method = hashMethod;
      setEmail.email = hashMethod === "md5" ? md5$1(email) : email;
      finalRequest.push(setEmail);
    }

    if (properties && properties.zipCode) {
      setZipcode.event = "setZipcode";
      setZipcode.zipCode = properties.zipCode || properties.zip;
      finalRequest.push(setZipcode);
    }

    return finalRequest;
  };

  var generateExtraData = function generateExtraData(rudderElement, fieldMapping) {
    var message = rudderElement.message;
    var extraData = {};
    var fieldMapHashmap = getHashFromArray(fieldMapping, "from", "to", false);
    Object.keys(fieldMapHashmap).forEach(function (field) {
      if (isDefinedAndNotNull$1(message.properties[field])) {
        extraData[fieldMapHashmap[field]] = message.properties[field];
      }
    });
    return extraData;
  };

  var handleProductView = function handleProductView(message, finalPayload) {
    var properties = message.properties;

    if (properties.product_id) {
      var viewItemObject = {
        event: "viewItem",
        item: String(properties.product_id)
      };

      if (properties.price && !Number.isNaN(parseFloat(properties.price))) {
        viewItemObject.price = parseFloat(properties.price);
      }

      if (properties.availability && (properties.availability === 1 || properties.availability === 0)) {
        viewItemObject.availability = properties.availability;
      }

      finalPayload.push(viewItemObject);
    } else {
      logger.debug("[Criteo] product_id is a mandatory field to use Product Tag in criteo");
    } // Final example payload supported by destination
    // window.criteo_q.push(
    //   { event: "setAccount", account: YOUR_PARTNER_ID},
    //   {
    //     event: "setEmail",
    //     email: "##Email Address##",
    //     hash_method: "##Hash Method##",
    //   },
    //   { event: "setSiteType", type: deviceType},
    //   { event: "setCustomerId", id: "##Customer Id##" },
    //   { event: "setRetailerVisitorId", id: "##Visitor Id##"},
    //   { event: "setZipcode", zipcode: "##Zip Code##" },
    //   {
    //     event: "viewItem",
    //     item: "##Product ID##",
    //     price: "##price##",
    //     availability: "##Availability##",
    //   }
    // );

  };

  var handlingEventDuo = function handlingEventDuo(message, finalPayload) {
    var event = message.event,
        properties = message.properties;
    var eventType = event.toLowerCase().trim();
    var productInfo = [];
    var elementaryProduct;

    if (properties && properties.products && properties.products.length > 0) {
      properties.products.forEach(function (product, index) {
        if (product.product_id && product.price && product.quantity) {
          elementaryProduct = {
            id: String(product.product_id),
            price: parseFloat(product.price),
            quantity: parseInt(product.quantity, 10)
          };

          if (!Number.isNaN(parseFloat(elementaryProduct.price)) && !Number.isNaN(parseInt(elementaryProduct.quantity, 10))) {
            // all the above fields are mandatory
            productInfo.push(elementaryProduct);
          }
        } else {
          logger.debug("[Criteo] product at index ".concat(index, " is skipped for insufficient information"));
        }
      });

      if (productInfo.length === 0) {
        logger.debug("[Criteo] None of the products had sufficient information or information is wrongly formatted");
        return;
      }
    } else {
      logger.debug("[Criteo] Payload should consist of at least one product information");
      return;
    }

    if (eventType === "cart viewed") {
      var viewBasketObject = {
        event: "viewBasket",
        item: productInfo
      };
      finalPayload.push(viewBasketObject); // final example payload supported by the destination
      // window.criteo_q.push(
      //   { event: "setAccount", account: YOUR_PARTNER_ID},
      //   {
      //     event: "setEmail",
      //     email: "##Email Address##",
      //     hash_method: "##Hash Method##",
      //   },
      //   { event: "setSiteType", type: deviceType},
      //   { event: "setCustomerId", id: "##Customer Id##" },
      //   { event: "setRetailerVisitorId", id: "##Visitor Id##"},
      //   { event: "setZipcode", zipcode: "##Zip Code##" },
      //   {
      //     event: "viewBasket",
      //     item: [
      //       {
      //         id: "##Product Id##",
      //         price: "##Price##",
      //         quantity: "##Quantity##",
      //       },
      //       // add a line for each additional line in the basket
      //     ],
      //   }
      // );
    }

    if (eventType === "order completed") {
      var trackTransactionObject = {
        event: "trackTransaction",
        id: String(properties.order_id),
        item: productInfo
      };

      if (!trackTransactionObject.id) {
        logger.debug("[Criteo] order_id (Transaction Id) is a mandatory field");
        return;
      }

      if (properties.new_customer === 1 || properties.new_customer === 0) {
        trackTransactionObject.new_customer = properties.new_customer;
      }

      if (properties.deduplication === 1 || properties.deduplication === 0) {
        trackTransactionObject.deduplication = properties.deduplication;
      }

      finalPayload.push(trackTransactionObject); // final example payload supported by destination
      //   window.criteo_q.push(
      //     { event: "setAccount", account: YOUR_PARTNER_ID},
      //     { event: "setEmail", email: "##Email Address##", hash_method: "##Hash Method##" },
      //     { event: "setSiteType", type: deviceType},
      //     { event: "setCustomerId", id: "##Customer Id##" },
      //     { event: "setRetailerVisitorId", id: "##Visitor Id##"},
      //     { event: "setZipcode", zipcode: "##Zip Code##" },
      //     { event: "trackTransaction",
      //       id: "##Transaction ID##",
      //       new_customer: ##New Customer##,
      //       deduplication: ##Deduplication##,
      //       item: [
      //        {id: "##Product Id##", price: "##Price##", quantity: "##Quantity##" }
      //        //add a line for each additional line in the basket
      //      ]}
      //   );
      // }
    }
  };

  var handleListView = function handleListView(message, finalPayload, OPERATOR_LIST) {
    var properties = message.properties;
    var productIdList = [];
    var filterArray = [];
    var viewListObj = {};
    var FILTER_FIELDS = ["name", "value"];

    if (properties.products && properties.products.length > 0) {
      properties.products.forEach(function (product) {
        if (product.product_id) {
          productIdList.push(String(product.product_id));
        }
      });

      if (productIdList.length === 0) {
        logger.debug("[Criteo] None of the product information had product_id");
        return;
      }
    } else {
      logger.debug("[Criteo] The payload should consist of atleast one product information");
      return;
    }

    viewListObj.event = "viewList";
    viewListObj.item = productIdList;
    viewListObj.category = String(properties.category);
    viewListObj.keywords = String(properties.keywords);

    if (properties.page_number && !Number.isNaN(parseInt(properties.page_number, 10))) {
      viewListObj.page_number = parseInt(properties.page_number, 10);
    }

    if (properties.filters) {
      properties.filters.forEach(function (filter) {
        var filterObject = {};
        Object.keys(filter).forEach(function (key) {
          if (FILTER_FIELDS.includes(key) || key === "operator" && OPERATOR_LIST.includes(filter.operator)) {
            filterObject[key] = filter[key];
          }
        });
        filterArray.push(filterObject);
      });
    }

    if (filterArray.length > 0) {
      viewListObj.filters = filterArray;
    }

    finalPayload.push(viewListObj);
  };

  var Criteo = /*#__PURE__*/function () {
    function Criteo(config) {
      _classCallCheck(this, Criteo);

      this.name = NAME$9;
      this.hashMethod = config.hashMethod;
      this.accountId = config.accountId;
      this.url = config.homePageUrl; // eslint-disable-next-line no-nested-ternary

      this.deviceType = /iPad/.test(navigator.userAgent) ? "t" : /Mobile|iP(hone|od)|Android|BlackBerry|IEMobile|Silk/.test(navigator.userAgent) ? "m" : "d";
      this.fieldMapping = config.fieldMapping;
      this.OPERATOR_LIST = ["eq", "gt", "lt", "ge", "le", "in"];
    }

    _createClass(Criteo, [{
      key: "init",
      value: function init() {
        logger.debug("===in init Criteo===");

        if (!this.accountId) {
          logger.debug("Account ID missing");
          return;
        }

        window.criteo_q = window.criteo_q || [];
        ScriptLoader("Criteo", "//dynamic.criteo.com/js/ld/ld.js?a=".concat(this.accountId));
        window.criteo_q.push({
          event: "setAccount",
          account: this.accountId
        });
        window.criteo_q.push({
          event: "setSiteType",
          type: this.deviceType
        });
      } // eslint-disable-next-line class-methods-use-this

    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("===in Criteo isLoaded===");
        return !!(window.criteo_q && window.criteo_q.push !== Array.prototype.push);
      } // eslint-disable-next-line class-methods-use-this

    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("===in Criteo isReady===");
        return !!(window.criteo_q && window.criteo_q.push !== Array.prototype.push);
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        var _rudderElement$messag = rudderElement.message,
            name = _rudderElement$messag.name,
            properties = _rudderElement$messag.properties;
        var finalPayload = handleCommonFields(rudderElement, this.hashMethod);

        if (name === "home" || properties && properties.name === "home" || this.url && this.url === window.location.href || properties && properties.url === this.url) {
          var homeEvent = {
            event: "viewHome"
          };
          finalPayload.push(homeEvent);
        } else {
          logger.debug("[Criteo] Home page is not detected");
          return;
        }

        var extraDataObject = generateExtraData(rudderElement, this.fieldMapping);

        if (Object.keys(extraDataObject).length !== 0) {
          finalPayload.push(_objectSpread2({
            event: "setData"
          }, extraDataObject));
        }

        window.criteo_q.push(finalPayload); // Final example payload supported by destination
        // window.criteo_q.push(
        //   { event: "setAccount", account: YOUR_PARTNER_ID},
        //   {
        //     event: "setEmail",
        //     email: "##Email Address##",
        //     hash_method: "##Hash Method##",
        //   },
        //   { event: "setSiteType", type: deviceType},
        //   { event: "setCustomerId", id: "##Customer Id##" },
        //   { event: "setRetailerVisitorId", id: "##Visitor Id##"},
        //   { event: "setZipcode", zipcode: "##Zip Code##" },
        //   { event: "viewHome" }
        // );
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        var _rudderElement$messag2 = rudderElement.message,
            event = _rudderElement$messag2.event,
            properties = _rudderElement$messag2.properties;
        var finalPayload = handleCommonFields(rudderElement, this.hashMethod);

        if (!event) {
          logger.debug("[Criteo] Event name from track call is missing!!===");
          return;
        }

        if (!properties || Object.keys(properties).length === 0) {
          logger.debug("[Criteo] Either properties object is missing or empty in the track call");
          return;
        }

        var eventType = event.toLowerCase().trim();

        switch (eventType) {
          case "product viewed":
            handleProductView(rudderElement.message, finalPayload);
            break;

          case "cart viewed":
          case "order completed":
            handlingEventDuo(rudderElement.message, finalPayload);
            break;

          case "product list viewed":
            handleListView(rudderElement.message, finalPayload, this.OPERATOR_LIST);
            break;

          default:
            logger.debug("[Criteo] event ".concat(eventType, " is not supported"));
            return;
        }

        var extraDataObject = generateExtraData(rudderElement, this.fieldMapping);

        if (Object.keys(extraDataObject).length !== 0) {
          finalPayload.push(_objectSpread2({
            event: "setData"
          }, extraDataObject));
        }

        window.criteo_q.push(finalPayload);
      }
    }]);

    return Criteo;
  }();

  var CustomerIO = /*#__PURE__*/function () {
    function CustomerIO(config) {
      _classCallCheck(this, CustomerIO);

      this.siteID = config.siteID;
      this.apiKey = config.apiKey;
      this.name = NAME$a;
    }

    _createClass(CustomerIO, [{
      key: "init",
      value: function init() {
        logger.debug("===in init Customer IO init===");
        window._cio = window._cio || [];
        var siteID = this.siteID;

        (function () {
          var a;
          var b;
          var c;

          a = function a(f) {
            return function () {
              window._cio.push([f].concat(Array.prototype.slice.call(arguments, 0)));
            };
          };

          b = ["load", "identify", "sidentify", "track", "page"];

          for (c = 0; c < b.length; c++) {
            window._cio[b[c]] = a(b[c]);
          }

          var t = document.createElement("script");
          var s = document.getElementsByTagName("script")[0];
          t.async = true;
          t.id = "cio-tracker";
          t.setAttribute("data-site-id", siteID);
          t.src = "https://assets.customer.io/assets/track.js";
          s.parentNode.insertBefore(t, s);
        })();
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("in Customer IO identify");
        var userId = rudderElement.message.userId ? rudderElement.message.userId : rudderElement.message.anonymousId;
        var traits = rudderElement.message.context.traits ? rudderElement.message.context.traits : {};
        var createAt = traits.createdAt;

        if (createAt) {
          traits.created_at = Math.floor(new Date(createAt).getTime() / 1000);
        }

        traits.id = userId;

        window._cio.identify(traits);
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("in Customer IO track");
        var eventName = rudderElement.message.event;
        var properties = rudderElement.message.properties;

        window._cio.track(eventName, properties);
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("in Customer IO page");
        var name = rudderElement.message.name || rudderElement.message.properties.url;

        window._cio.page(name, rudderElement.message.properties);
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        return !!(window._cio && window._cio.push !== Array.prototype.push);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return !!(window._cio && window._cio.push !== Array.prototype.push);
      }
    }]);

    return CustomerIO;
  }();

  // External ID format
  // {
  //   "context": {
  //     "externalId": [
  //       {
  //         "type": "kustomerId",
  //         "id": "12345678"
  //       }
  //     ]
  //   }
  // }
  // to get destination specific external id passed in context.
  function getDestinationExternalID(message, type) {
    var externalIdArray = null;
    var destinationExternalId = null;

    if (message.context && message.context.externalId) {
      externalIdArray = message.context.externalId;
    }

    if (externalIdArray) {
      externalIdArray.forEach(function (extIdObj) {
        if (extIdObj.type === type) {
          destinationExternalId = extIdObj.id;
        }
      });
    }

    return destinationExternalId;
  }

  var Drip = /*#__PURE__*/function () {
    function Drip(config) {
      _classCallCheck(this, Drip);

      this.accountId = config.accountId;
      this.campaignId = config.campaignId;
      this.name = NAME$b;
      this.exclusionFields = ["email", "new_email", "newEmail", "tags", "remove_tags", "removeTags", "prospect", "eu_consent", "euConsent", "eu_consent_message", "euConsentMessage"];
    }

    _createClass(Drip, [{
      key: "init",
      value: function init() {
        logger.debug("===In init Drip===");
        window._dcq = window._dcq || [];
        window._dcs = window._dcs || {};
        window._dcs.account = this.accountId;

        (function () {
          var dc = document.createElement("script");
          dc.type = "text/javascript";
          dc.async = true;
          dc.src = "//tag.getdrip.com/".concat(window._dcs.account, ".js");
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(dc, s);
        })();
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("===In isLoaded Drip===");
        return !!window._dcq;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("===In isReady Drip===");
        return !!window._dcq;
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("===In Drip identify===");
        var message = rudderElement.message;

        if (!message.context || !message.context.traits) {
          logger.error("user context or traits not present");
          return;
        }

        var email = getValue(message, "context.traits.email");

        if (!email) {
          logger.error("email is required for identify");
          return;
        }

        var euConsent = getValue(message, "context.traits.euConsent");

        if (euConsent && !(euConsent.toLowerCase() === "granted" || euConsent.toLowerCase() === "denied")) {
          euConsent = null;
        }

        var payload = {
          email: email,
          new_email: getValue(message, "context.traits.newEmail"),
          user_id: getValue(message, "userId") || getValue(message, "anonymousId"),
          tags: getValue(message, "context.traits.tags"),
          remove_tags: getValue(message, "context.traits.removeTags"),
          prospect: getValue(message, "context.traits.prospect"),
          eu_consent: euConsent,
          eu_consent_message: getValue(message, "context.traits.euConsentMessage")
        };
        var extraFields = {};

        try {
          extraFields = extractCustomFields(message, extraFields, ["context.traits"], this.exclusionFields);
        } catch (err) {
          logger.debug("Error occured at extractCustomFields ".concat(err));
        }

        payload = _objectSpread2(_objectSpread2({}, payload), extraFields);
        payload = removeUndefinedAndNullValues(payload);

        window._dcq.push(["identify", payload]);

        var campaignId = getDestinationExternalID(message, "dripCampaignId") || this.campaignId;

        if (campaignId) {
          var fields = payload;
          delete fields.campaignId;
          delete fields.doubleOptin;
          delete fields.tags;
          var campaignPayload = {
            fields: fields,
            campaign_id: campaignId,
            double_optin: getValue(message, "context.traits.doubleOptin")
          };
          campaignPayload = removeUndefinedAndNullValues(campaignPayload);

          window._dcq.push(["subscribe", campaignPayload]);
        }
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("===In Drip track===");
        var message = rudderElement.message;
        var event = rudderElement.message.event;

        if (!event) {
          logger.error("Event name not present");
          return;
        }

        var email = getValue(message, "properties.email") || getValue(message, "context.traits.email");

        if (!email) {
          logger.error("email is required for track");
          return;
        }

        var payload = getValue(message, "properties");

        if (isDefinedAndNotNull$1(payload.revenue)) {
          var cents = Math.round(payload.revenue * 100);

          if (cents) {
            payload.value = cents;
          }

          delete payload.revenue;
        }

        payload = _objectSpread2(_objectSpread2({}, payload), {}, {
          email: email,
          occurred_at: getValue(message, "properties.occurred_at") || getValue(message, "originalTimestamp")
        });
        payload = removeUndefinedAndNullValues(payload);

        window._dcq.push(["track", event, payload]);
      }
    }]);

    return Drip;
  }();

  /* globals window, HTMLElement */
  var objProto = Object.prototype;
  var owns = objProto.hasOwnProperty;
  var toStr$1 = objProto.toString;
  var symbolValueOf;

  if (typeof Symbol === 'function') {
    symbolValueOf = Symbol.prototype.valueOf;
  }

  var bigIntValueOf;

  if (typeof BigInt === 'function') {
    bigIntValueOf = BigInt.prototype.valueOf;
  }

  var isActualNaN = function isActualNaN(value) {
    return value !== value;
  };

  var NON_HOST_TYPES = {
    'boolean': 1,
    number: 1,
    string: 1,
    undefined: 1
  };
  var base64Regex = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)$/;
  var hexRegex = /^[A-Fa-f0-9]+$/;
  /**
   * Expose `is`
   */

  var is = {};
  /**
   * Test general.
   */

  /**
   * is.type
   * Test if `value` is a type of `type`.
   *
   * @param {*} value value to test
   * @param {String} type type
   * @return {Boolean} true if `value` is a type of `type`, false otherwise
   * @api public
   */

  is.a = is.type = function (value, type) {
    return _typeof(value) === type;
  };
  /**
   * is.defined
   * Test if `value` is defined.
   *
   * @param {*} value value to test
   * @return {Boolean} true if 'value' is defined, false otherwise
   * @api public
   */


  is.defined = function (value) {
    return typeof value !== 'undefined';
  };
  /**
   * is.empty
   * Test if `value` is empty.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is empty, false otherwise
   * @api public
   */


  is.empty = function (value) {
    var type = toStr$1.call(value);
    var key;

    if (type === '[object Array]' || type === '[object Arguments]' || type === '[object String]') {
      return value.length === 0;
    }

    if (type === '[object Object]') {
      for (key in value) {
        if (owns.call(value, key)) {
          return false;
        }
      }

      return true;
    }

    return !value;
  };
  /**
   * is.equal
   * Test if `value` is equal to `other`.
   *
   * @param {*} value value to test
   * @param {*} other value to compare with
   * @return {Boolean} true if `value` is equal to `other`, false otherwise
   */


  is.equal = function equal(value, other) {
    if (value === other) {
      return true;
    }

    var type = toStr$1.call(value);
    var key;

    if (type !== toStr$1.call(other)) {
      return false;
    }

    if (type === '[object Object]') {
      for (key in value) {
        if (!is.equal(value[key], other[key]) || !(key in other)) {
          return false;
        }
      }

      for (key in other) {
        if (!is.equal(value[key], other[key]) || !(key in value)) {
          return false;
        }
      }

      return true;
    }

    if (type === '[object Array]') {
      key = value.length;

      if (key !== other.length) {
        return false;
      }

      while (key--) {
        if (!is.equal(value[key], other[key])) {
          return false;
        }
      }

      return true;
    }

    if (type === '[object Function]') {
      return value.prototype === other.prototype;
    }

    if (type === '[object Date]') {
      return value.getTime() === other.getTime();
    }

    return false;
  };
  /**
   * is.hosted
   * Test if `value` is hosted by `host`.
   *
   * @param {*} value to test
   * @param {*} host host to test with
   * @return {Boolean} true if `value` is hosted by `host`, false otherwise
   * @api public
   */


  is.hosted = function (value, host) {
    var type = _typeof(host[value]);

    return type === 'object' ? !!host[value] : !NON_HOST_TYPES[type];
  };
  /**
   * is.instance
   * Test if `value` is an instance of `constructor`.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is an instance of `constructor`
   * @api public
   */


  is.instance = is['instanceof'] = function (value, constructor) {
    return value instanceof constructor;
  };
  /**
   * is.nil / is.null
   * Test if `value` is null.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is null, false otherwise
   * @api public
   */


  is.nil = is['null'] = function (value) {
    return value === null;
  };
  /**
   * is.undef / is.undefined
   * Test if `value` is undefined.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is undefined, false otherwise
   * @api public
   */


  is.undef = is.undefined = function (value) {
    return typeof value === 'undefined';
  };
  /**
   * Test arguments.
   */

  /**
   * is.args
   * Test if `value` is an arguments object.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is an arguments object, false otherwise
   * @api public
   */


  is.args = is.arguments = function (value) {
    var isStandardArguments = toStr$1.call(value) === '[object Arguments]';
    var isOldArguments = !is.array(value) && is.arraylike(value) && is.object(value) && is.fn(value.callee);
    return isStandardArguments || isOldArguments;
  };
  /**
   * Test array.
   */

  /**
   * is.array
   * Test if 'value' is an array.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is an array, false otherwise
   * @api public
   */


  is.array = Array.isArray || function (value) {
    return toStr$1.call(value) === '[object Array]';
  };
  /**
   * is.arguments.empty
   * Test if `value` is an empty arguments object.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is an empty arguments object, false otherwise
   * @api public
   */


  is.args.empty = function (value) {
    return is.args(value) && value.length === 0;
  };
  /**
   * is.array.empty
   * Test if `value` is an empty array.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is an empty array, false otherwise
   * @api public
   */


  is.array.empty = function (value) {
    return is.array(value) && value.length === 0;
  };
  /**
   * is.arraylike
   * Test if `value` is an arraylike object.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is an arguments object, false otherwise
   * @api public
   */


  is.arraylike = function (value) {
    return !!value && !is.bool(value) && owns.call(value, 'length') && isFinite(value.length) && is.number(value.length) && value.length >= 0;
  };
  /**
   * Test boolean.
   */

  /**
   * is.bool
   * Test if `value` is a boolean.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is a boolean, false otherwise
   * @api public
   */


  is.bool = is['boolean'] = function (value) {
    return toStr$1.call(value) === '[object Boolean]';
  };
  /**
   * is.false
   * Test if `value` is false.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is false, false otherwise
   * @api public
   */


  is['false'] = function (value) {
    return is.bool(value) && Boolean(Number(value)) === false;
  };
  /**
   * is.true
   * Test if `value` is true.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is true, false otherwise
   * @api public
   */


  is['true'] = function (value) {
    return is.bool(value) && Boolean(Number(value)) === true;
  };
  /**
   * Test date.
   */

  /**
   * is.date
   * Test if `value` is a date.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is a date, false otherwise
   * @api public
   */


  is.date = function (value) {
    return toStr$1.call(value) === '[object Date]';
  };
  /**
   * is.date.valid
   * Test if `value` is a valid date.
   *
   * @param {*} value value to test
   * @returns {Boolean} true if `value` is a valid date, false otherwise
   */


  is.date.valid = function (value) {
    return is.date(value) && !isNaN(Number(value));
  };
  /**
   * Test element.
   */

  /**
   * is.element
   * Test if `value` is an html element.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is an HTML Element, false otherwise
   * @api public
   */


  is.element = function (value) {
    return value !== undefined && typeof HTMLElement !== 'undefined' && value instanceof HTMLElement && value.nodeType === 1;
  };
  /**
   * Test error.
   */

  /**
   * is.error
   * Test if `value` is an error object.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is an error object, false otherwise
   * @api public
   */


  is.error = function (value) {
    return toStr$1.call(value) === '[object Error]';
  };
  /**
   * Test function.
   */

  /**
   * is.fn / is.function (deprecated)
   * Test if `value` is a function.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is a function, false otherwise
   * @api public
   */


  is.fn = is['function'] = function (value) {
    var isAlert = typeof window !== 'undefined' && value === window.alert;

    if (isAlert) {
      return true;
    }

    var str = toStr$1.call(value);
    return str === '[object Function]' || str === '[object GeneratorFunction]' || str === '[object AsyncFunction]';
  };
  /**
   * Test number.
   */

  /**
   * is.number
   * Test if `value` is a number.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is a number, false otherwise
   * @api public
   */


  is.number = function (value) {
    return toStr$1.call(value) === '[object Number]';
  };
  /**
   * is.infinite
   * Test if `value` is positive or negative infinity.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is positive or negative Infinity, false otherwise
   * @api public
   */


  is.infinite = function (value) {
    return value === Infinity || value === -Infinity;
  };
  /**
   * is.decimal
   * Test if `value` is a decimal number.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is a decimal number, false otherwise
   * @api public
   */


  is.decimal = function (value) {
    return is.number(value) && !isActualNaN(value) && !is.infinite(value) && value % 1 !== 0;
  };
  /**
   * is.divisibleBy
   * Test if `value` is divisible by `n`.
   *
   * @param {Number} value value to test
   * @param {Number} n dividend
   * @return {Boolean} true if `value` is divisible by `n`, false otherwise
   * @api public
   */


  is.divisibleBy = function (value, n) {
    var isDividendInfinite = is.infinite(value);
    var isDivisorInfinite = is.infinite(n);
    var isNonZeroNumber = is.number(value) && !isActualNaN(value) && is.number(n) && !isActualNaN(n) && n !== 0;
    return isDividendInfinite || isDivisorInfinite || isNonZeroNumber && value % n === 0;
  };
  /**
   * is.integer
   * Test if `value` is an integer.
   *
   * @param value to test
   * @return {Boolean} true if `value` is an integer, false otherwise
   * @api public
   */


  is.integer = is['int'] = function (value) {
    return is.number(value) && !isActualNaN(value) && value % 1 === 0;
  };
  /**
   * is.maximum
   * Test if `value` is greater than 'others' values.
   *
   * @param {Number} value value to test
   * @param {Array} others values to compare with
   * @return {Boolean} true if `value` is greater than `others` values
   * @api public
   */


  is.maximum = function (value, others) {
    if (isActualNaN(value)) {
      throw new TypeError('NaN is not a valid value');
    } else if (!is.arraylike(others)) {
      throw new TypeError('second argument must be array-like');
    }

    var len = others.length;

    while (--len >= 0) {
      if (value < others[len]) {
        return false;
      }
    }

    return true;
  };
  /**
   * is.minimum
   * Test if `value` is less than `others` values.
   *
   * @param {Number} value value to test
   * @param {Array} others values to compare with
   * @return {Boolean} true if `value` is less than `others` values
   * @api public
   */


  is.minimum = function (value, others) {
    if (isActualNaN(value)) {
      throw new TypeError('NaN is not a valid value');
    } else if (!is.arraylike(others)) {
      throw new TypeError('second argument must be array-like');
    }

    var len = others.length;

    while (--len >= 0) {
      if (value > others[len]) {
        return false;
      }
    }

    return true;
  };
  /**
   * is.nan
   * Test if `value` is not a number.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is not a number, false otherwise
   * @api public
   */


  is.nan = function (value) {
    return !is.number(value) || value !== value;
  };
  /**
   * is.even
   * Test if `value` is an even number.
   *
   * @param {Number} value value to test
   * @return {Boolean} true if `value` is an even number, false otherwise
   * @api public
   */


  is.even = function (value) {
    return is.infinite(value) || is.number(value) && value === value && value % 2 === 0;
  };
  /**
   * is.odd
   * Test if `value` is an odd number.
   *
   * @param {Number} value value to test
   * @return {Boolean} true if `value` is an odd number, false otherwise
   * @api public
   */


  is.odd = function (value) {
    return is.infinite(value) || is.number(value) && value === value && value % 2 !== 0;
  };
  /**
   * is.ge
   * Test if `value` is greater than or equal to `other`.
   *
   * @param {Number} value value to test
   * @param {Number} other value to compare with
   * @return {Boolean}
   * @api public
   */


  is.ge = function (value, other) {
    if (isActualNaN(value) || isActualNaN(other)) {
      throw new TypeError('NaN is not a valid value');
    }

    return !is.infinite(value) && !is.infinite(other) && value >= other;
  };
  /**
   * is.gt
   * Test if `value` is greater than `other`.
   *
   * @param {Number} value value to test
   * @param {Number} other value to compare with
   * @return {Boolean}
   * @api public
   */


  is.gt = function (value, other) {
    if (isActualNaN(value) || isActualNaN(other)) {
      throw new TypeError('NaN is not a valid value');
    }

    return !is.infinite(value) && !is.infinite(other) && value > other;
  };
  /**
   * is.le
   * Test if `value` is less than or equal to `other`.
   *
   * @param {Number} value value to test
   * @param {Number} other value to compare with
   * @return {Boolean} if 'value' is less than or equal to 'other'
   * @api public
   */


  is.le = function (value, other) {
    if (isActualNaN(value) || isActualNaN(other)) {
      throw new TypeError('NaN is not a valid value');
    }

    return !is.infinite(value) && !is.infinite(other) && value <= other;
  };
  /**
   * is.lt
   * Test if `value` is less than `other`.
   *
   * @param {Number} value value to test
   * @param {Number} other value to compare with
   * @return {Boolean} if `value` is less than `other`
   * @api public
   */


  is.lt = function (value, other) {
    if (isActualNaN(value) || isActualNaN(other)) {
      throw new TypeError('NaN is not a valid value');
    }

    return !is.infinite(value) && !is.infinite(other) && value < other;
  };
  /**
   * is.within
   * Test if `value` is within `start` and `finish`.
   *
   * @param {Number} value value to test
   * @param {Number} start lower bound
   * @param {Number} finish upper bound
   * @return {Boolean} true if 'value' is is within 'start' and 'finish'
   * @api public
   */


  is.within = function (value, start, finish) {
    if (isActualNaN(value) || isActualNaN(start) || isActualNaN(finish)) {
      throw new TypeError('NaN is not a valid value');
    } else if (!is.number(value) || !is.number(start) || !is.number(finish)) {
      throw new TypeError('all arguments must be numbers');
    }

    var isAnyInfinite = is.infinite(value) || is.infinite(start) || is.infinite(finish);
    return isAnyInfinite || value >= start && value <= finish;
  };
  /**
   * Test object.
   */

  /**
   * is.object
   * Test if `value` is an object.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is an object, false otherwise
   * @api public
   */


  is.object = function (value) {
    return toStr$1.call(value) === '[object Object]';
  };
  /**
   * is.primitive
   * Test if `value` is a primitive.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is a primitive, false otherwise
   * @api public
   */


  is.primitive = function isPrimitive(value) {
    if (!value) {
      return true;
    }

    if (_typeof(value) === 'object' || is.object(value) || is.fn(value) || is.array(value)) {
      return false;
    }

    return true;
  };
  /**
   * is.hash
   * Test if `value` is a hash - a plain object literal.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is a hash, false otherwise
   * @api public
   */


  is.hash = function (value) {
    return is.object(value) && value.constructor === Object && !value.nodeType && !value.setInterval;
  };
  /**
   * Test regexp.
   */

  /**
   * is.regexp
   * Test if `value` is a regular expression.
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is a regexp, false otherwise
   * @api public
   */


  is.regexp = function (value) {
    return toStr$1.call(value) === '[object RegExp]';
  };
  /**
   * Test string.
   */

  /**
   * is.string
   * Test if `value` is a string.
   *
   * @param {*} value value to test
   * @return {Boolean} true if 'value' is a string, false otherwise
   * @api public
   */


  is.string = function (value) {
    return toStr$1.call(value) === '[object String]';
  };
  /**
   * Test base64 string.
   */

  /**
   * is.base64
   * Test if `value` is a valid base64 encoded string.
   *
   * @param {*} value value to test
   * @return {Boolean} true if 'value' is a base64 encoded string, false otherwise
   * @api public
   */


  is.base64 = function (value) {
    return is.string(value) && (!value.length || base64Regex.test(value));
  };
  /**
   * Test base64 string.
   */

  /**
   * is.hex
   * Test if `value` is a valid hex encoded string.
   *
   * @param {*} value value to test
   * @return {Boolean} true if 'value' is a hex encoded string, false otherwise
   * @api public
   */


  is.hex = function (value) {
    return is.string(value) && (!value.length || hexRegex.test(value));
  };
  /**
   * is.symbol
   * Test if `value` is an ES6 Symbol
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is a Symbol, false otherise
   * @api public
   */


  is.symbol = function (value) {
    return typeof Symbol === 'function' && toStr$1.call(value) === '[object Symbol]' && _typeof(symbolValueOf.call(value)) === 'symbol';
  };
  /**
   * is.bigint
   * Test if `value` is an ES-proposed BigInt
   *
   * @param {*} value value to test
   * @return {Boolean} true if `value` is a BigInt, false otherise
   * @api public
   */


  is.bigint = function (value) {
    // eslint-disable-next-line valid-typeof
    return typeof BigInt === 'function' && toStr$1.call(value) === '[object BigInt]' && typeof bigIntValueOf.call(value) === 'bigint';
  };

  var is_1 = is;

  var sha256 = createCommonjsModule(function (module, exports) {

    (function (root, factory) {
      {
        // CommonJS
        module.exports = exports = factory(core);
      }
    })(commonjsGlobal, function (CryptoJS) {
      (function (Math) {
        // Shortcuts
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo; // Initialization and round constants tables

        var H = [];
        var K = []; // Compute constants

        (function () {
          function isPrime(n) {
            var sqrtN = Math.sqrt(n);

            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n % factor)) {
                return false;
              }
            }

            return true;
          }

          function getFractionalBits(n) {
            return (n - (n | 0)) * 0x100000000 | 0;
          }

          var n = 2;
          var nPrime = 0;

          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
              }

              K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));
              nPrime++;
            }

            n++;
          }
        })(); // Reusable object


        var W = [];
        /**
         * SHA-256 hash algorithm.
         */

        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function _doReset() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            // Shortcut
            var H = this._hash.words; // Working variables

            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            var f = H[5];
            var g = H[6];
            var h = H[7]; // Computation

            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }

              var ch = e & f ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f;
              f = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            } // Intermediate hash value


            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e | 0;
            H[5] = H[5] + f | 0;
            H[6] = H[6] + g | 0;
            H[7] = H[7] + h | 0;
          },
          _doFinalize: function _doFinalize() {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8; // Add padding

            dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4; // Hash final blocks

            this._process(); // Return final computed hash


            return this._hash;
          },
          clone: function clone() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        /**
         * Shortcut function to the hasher's object interface.
         *
         * @param {WordArray|string} message The message to hash.
         *
         * @return {WordArray} The hash.
         *
         * @static
         *
         * @example
         *
         *     var hash = CryptoJS.SHA256('message');
         *     var hash = CryptoJS.SHA256(wordArray);
         */

        C.SHA256 = Hasher._createHelper(SHA256);
        /**
         * Shortcut function to the HMAC's object interface.
         *
         * @param {WordArray|string} message The message to hash.
         * @param {WordArray|string} key The secret key.
         *
         * @return {WordArray} The HMAC.
         *
         * @static
         *
         * @example
         *
         *     var hmac = CryptoJS.HmacSHA256(message, key);
         */

        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);

      return CryptoJS.SHA256;
    });
  });

  function getEventId(message) {
    return getValue(message, "traits.event_id") || getValue(message, "context.traits.event_id") || getValue(message, "properties.event_id") || message.messageId;
  }

  var FacebookPixel = /*#__PURE__*/function () {
    function FacebookPixel(config) {
      _classCallCheck(this, FacebookPixel);

      this.blacklistPiiProperties = config.blacklistPiiProperties;
      this.categoryToContent = config.categoryToContent;
      this.pixelId = config.pixelId;
      this.eventsToEvents = config.eventsToEvents;
      this.eventCustomProperties = config.eventCustomProperties;
      this.valueFieldIdentifier = config.valueFieldIdentifier;
      this.advancedMapping = config.advancedMapping;
      this.traitKeyToExternalId = config.traitKeyToExternalId;
      this.legacyConversionPixelId = config.legacyConversionPixelId;
      this.userIdAsPixelId = config.userIdAsPixelId;
      this.whitelistPiiProperties = config.whitelistPiiProperties;
      this.useUpdatedMapping = config.useUpdatedMapping;
      this.name = NAME$c;
    }

    _createClass(FacebookPixel, [{
      key: "init",
      value: function init() {
        if (this.categoryToContent === undefined) {
          this.categoryToContent = [];
        }

        if (this.legacyConversionPixelId === undefined) {
          this.legacyConversionPixelId = [];
        }

        if (this.userIdAsPixelId === undefined) {
          this.userIdAsPixelId = [];
        }

        logger.debug("===in init FbPixel===");

        window._fbq = function () {
          if (window.fbq.callMethod) {
            window.fbq.callMethod.apply(window.fbq, arguments);
          } else {
            window.fbq.queue.push(arguments);
          }
        };

        window.fbq = window.fbq || window._fbq;
        window.fbq.push = window.fbq;
        window.fbq.loaded = true;
        window.fbq.disablePushState = true; // disables automatic pageview tracking

        window.fbq.allowDuplicatePageViews = true; // enables fb

        window.fbq.version = "2.0";
        window.fbq.queue = [];
        window.fbq("init", this.pixelId);
        ScriptLoader("fbpixel-integration", "https://connect.facebook.net/en_US/fbevents.js");
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("in FBPixel isLoaded");
        return !!(window.fbq && window.fbq.callMethod);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("in FBPixel isReady");
        return !!(window.fbq && window.fbq.callMethod);
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        var properties = rudderElement.message.properties;
        window.fbq("track", "PageView", properties, {
          event_id: getEventId(rudderElement.message)
        });
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        if (this.advancedMapping) {
          var payload = {};
          var traits = rudderElement.message.context ? rudderElement.message.context.traits : undefined;

          if (this.useUpdatedMapping) {
            var reserve = ["email", "lastName", "firstName", "phone", "external_id", "city", "birthday", "gender", "street", "zip", "country"]; // this construcPayload will help to map the traits in the same way as cloud mode

            payload = constructPayload(rudderElement.message, traitsMapper); // here we are sending other traits apart from the reserved ones.

            reserve.forEach(function (element) {
              delete traits[element];
            });
          }

          payload = _objectSpread2(_objectSpread2({}, payload), traits);
          window.fbq("init", this.pixelId, payload);
        }
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        var _this = this;

        var self = this;
        var _rudderElement$messag = rudderElement.message,
            event = _rudderElement$messag.event,
            properties = _rudderElement$messag.properties,
            messageId = _rudderElement$messag.messageId;
        var revValue;
        var currVal;

        if (properties) {
          var revenue = properties.revenue,
              currency = properties.currency;
          revValue = this.formatRevenue(revenue);
          currVal = currency || "USD";
        }

        var payload = this.buildPayLoad(rudderElement, true);

        if (this.categoryToContent === undefined) {
          this.categoryToContent = [];
        }

        if (this.legacyConversionPixelId === undefined) {
          this.legacyConversionPixelId = [];
        }

        if (this.userIdAsPixelId === undefined) {
          this.userIdAsPixelId = [];
        }

        payload.value = revValue;
        var standard = this.eventsToEvents;
        var legacy = this.legacyConversionPixelId;
        var standardTo = getHashFromArray(standard);
        var legacyTo = getHashFromArray(legacy);
        var useValue = this.valueFieldIdentifier === "properties.value";
        var products;
        var quantity;
        var category;
        var prodId;
        var prodName;
        var value;
        var price;
        var query;

        if (properties) {
          products = properties.products;
          quantity = properties.quantity;
          category = properties.category;
          prodId = properties.product_id || properties.id || properties.sku || "";
          prodName = properties.product_name;
          value = properties.value;
          price = properties.price;
          query = properties.query;
        }

        var customProperties = this.buildPayLoad(rudderElement, true);
        var eventID = getEventId(rudderElement.message);

        if (event === "Product List Viewed") {
          var contentType;
          var contentIds = [];
          var contents = [];

          if (products && Array.isArray(products)) {
            products.forEach(function (product) {
              var productId = product.product_id;

              if (productId) {
                contentIds.push(productId);
                contents.push({
                  id: productId,
                  quantity: quantity || 1
                });
              }
            });
          } else {
            logger.error("No product array found");
          }

          if (contentIds.length) {
            contentType = ["product"];
          } else {
            contentIds.push(category || "");
            contents.push({
              id: category || "",
              quantity: 1
            });
            contentType = ["product_group"];
          }

          window.fbq("trackSingle", self.pixelId, "ViewContent", this.merge({
            content_ids: contentIds,
            content_type: this.getContentType(rudderElement, contentType),
            contents: contents
          }, customProperties), {
            event_id: eventID
          });
          each_1(function (val, key) {
            if (key === event.toLowerCase()) {
              window.fbq("trackSingle", self.pixelId, val, {
                currency: currVal,
                value: revValue
              }, {
                event_id: eventID
              });
            }
          }, legacyTo);
        } else if (event === "Product Viewed") {
          window.fbq("trackSingle", self.pixelId, "ViewContent", this.merge({
            content_ids: [prodId],
            content_type: this.getContentType(rudderElement, ["product"]),
            content_name: prodName || "",
            content_category: category || "",
            currency: currVal,
            value: useValue ? this.formatRevenue(value) : this.formatRevenue(price),
            contents: [{
              id: prodId,
              quantity: quantity,
              item_price: price
            }]
          }, customProperties), {
            event_id: eventID
          });
          each_1(function (val, key) {
            if (key === event.toLowerCase()) {
              window.fbq("trackSingle", self.pixelId, val, {
                currency: currVal,
                value: useValue ? _this.formatRevenue(value) : _this.formatRevenue(price)
              }, {
                event_id: eventID
              });
            }
          }, legacyTo);
        } else if (event === "Product Added") {
          window.fbq("trackSingle", self.pixelId, "AddToCart", this.merge({
            content_ids: [prodId],
            content_type: this.getContentType(rudderElement, ["product"]),
            content_name: prodName || "",
            content_category: category || "",
            currency: currVal,
            value: useValue ? this.formatRevenue(value) : this.formatRevenue(price),
            contents: [{
              id: prodId,
              quantity: quantity,
              item_price: price
            }]
          }, customProperties), {
            event_id: eventID
          });
          each_1(function (val, key) {
            if (key === event.toLowerCase()) {
              window.fbq("trackSingle", self.pixelId, val, {
                currency: currVal,
                value: useValue ? _this.formatRevenue(value) : _this.formatRevenue(price)
              }, {
                event_id: eventID
              });
            }
          }, legacyTo);
          this.merge({
            content_ids: [prodId],
            content_type: this.getContentType(rudderElement, ["product"]),
            content_name: prodName || "",
            content_category: category || "",
            currency: currVal,
            value: useValue ? this.formatRevenue(value) : this.formatRevenue(price),
            contents: [{
              id: prodId,
              quantity: quantity,
              item_price: price
            }]
          }, customProperties);
        } else if (event === "Order Completed") {
          var _contentType = this.getContentType(rudderElement, ["product"]);

          var _contentIds = [];
          var _contents = [];

          if (products) {
            for (var i = 0; i < products.length; i++) {
              var pId = products[i].product_id;

              _contentIds.push(pId);

              var content = {
                id: pId,
                quantity: quantity
              };
              content.item_price = price;

              _contents.push(content);
            }

            window.fbq("trackSingle", self.pixelId, "Purchase", this.merge({
              content_ids: _contentIds,
              content_type: _contentType,
              currency: currVal,
              value: revValue,
              contents: _contents,
              num_items: _contentIds.length
            }, customProperties), {
              event_id: eventID
            });
            each_1(function (val, key) {
              if (key === event.toLowerCase()) {
                window.fbq("trackSingle", self.pixelId, val, {
                  currency: currVal,
                  value: revValue
                }, {
                  event_id: eventID
                });
              }
            }, legacyTo);
          } else {
            logger.error("No product array found");
          }
        } else if (event === "Products Searched") {
          window.fbq("trackSingle", self.pixelId, "Search", this.merge({
            search_string: query
          }, customProperties), {
            event_id: eventID
          });
          each_1(function (val, key) {
            if (key === event.toLowerCase()) {
              window.fbq("trackSingle", self.pixelId, val, {
                currency: currVal,
                value: revValue
              }, {
                event_id: eventID
              });
            }
          }, legacyTo);
        } else if (event === "Checkout Started") {
          var contentCategory = category;
          var _contentIds2 = [];
          var _contents2 = [];

          if (products) {
            for (var _i = 0; _i < products.length; _i++) {
              var product = products[_i];
              var _pId = product.product_id;

              _contentIds2.push(_pId);

              var _content = {
                id: _pId,
                quantity: quantity,
                item_price: price
              };
              _content.item_price = price;

              _contents2.push(_content);
            }

            if (!contentCategory && products[0] && products[0].category) {
              contentCategory = products[0].category;
            }

            window.fbq("trackSingle", self.pixelId, "InitiateCheckout", this.merge({
              content_category: contentCategory,
              content_ids: _contentIds2,
              content_type: this.getContentType(rudderElement, ["product"]),
              currency: currVal,
              value: revValue,
              contents: _contents2,
              num_items: _contentIds2.length
            }, customProperties), {
              event_id: eventID
            });
            each_1(function (val, key) {
              if (key === event.toLowerCase()) {
                window.fbq("trackSingle", self.pixelId, val, {
                  currency: currVal,
                  value: revValue
                }, {
                  event_id: eventID
                });
              }
            }, legacyTo);
          } else {
            logger.error("No product array found");
          }
        } else {
          logger.debug("inside custom");

          if (!standardTo[event.toLowerCase()] && !legacyTo[event.toLowerCase()]) {
            logger.debug("inside custom not mapped");
            var payloadVal = this.buildPayLoad(rudderElement, false);
            payloadVal.value = revValue;
            window.fbq("trackSingleCustom", self.pixelId, event, payloadVal, {
              event_id: eventID
            });
          } else {
            each_1(function (val, key) {
              if (key === event.toLowerCase()) {
                payload.currency = currVal;
                window.fbq("trackSingle", self.pixelId, val, payload, {
                  event_id: eventID
                });
              }
            }, standardTo);
            each_1(function (val, key) {
              if (key === event.toLowerCase()) {
                window.fbq("trackSingle", self.pixelId, val, {
                  currency: currVal,
                  value: revValue
                }, {
                  event_id: eventID
                });
              }
            }, legacyTo);
          }
        }
      }
      /**
       * Get the Facebook Content Type
       *
       * Can be `product`, `destination`, `flight` or `hotel`.
       *
       * This can be overridden within the message
       * `options.integrations.FACEBOOK_PIXEL.contentType`, or alternatively you can
       * set the "Map Categories to Facebook Content Types" setting within
       * RudderStack config and then set the corresponding commerce category in
       * `track()` properties.
       *
       * https://www.facebook.com/business/help/606577526529702?id=1205376682832142
       */

    }, {
      key: "getContentType",
      value: function getContentType(rudderElement, defaultValue) {
        var _rudderElement$messag2, _rudderElement$messag3;

        // Get the message-specific override if it exists in the options parameter of `track()`
        var contentTypeMessageOverride = (_rudderElement$messag2 = rudderElement.message.integrations) === null || _rudderElement$messag2 === void 0 ? void 0 : (_rudderElement$messag3 = _rudderElement$messag2.FACEBOOK_PIXEL) === null || _rudderElement$messag3 === void 0 ? void 0 : _rudderElement$messag3.contentType;
        if (contentTypeMessageOverride) return [contentTypeMessageOverride]; // Otherwise check if there is a replacement set for all Facebook Pixel
        // track calls of this category

        var category = rudderElement.message.properties.category;

        if (category) {
          var _this$categoryToConte;

          var categoryMapping = (_this$categoryToConte = this.categoryToContent) === null || _this$categoryToConte === void 0 ? void 0 : _this$categoryToConte.find(function (i) {
            return i.from === category;
          });
          if (categoryMapping !== null && categoryMapping !== void 0 && categoryMapping.to) return [categoryMapping.to];
        } // Otherwise return the default value


        return defaultValue;
      }
    }, {
      key: "merge",
      value: function merge(obj1, obj2) {
        var res = {}; // All properties of obj1

        for (var propObj1 in obj1) {
          if (obj1.hasOwnProperty(propObj1)) {
            res[propObj1] = obj1[propObj1];
          }
        } // Extra properties of obj2


        for (var propObj2 in obj2) {
          if (obj2.hasOwnProperty(propObj2) && !res.hasOwnProperty(propObj2)) {
            res[propObj2] = obj2[propObj2];
          }
        }

        return res;
      }
    }, {
      key: "formatRevenue",
      value: function formatRevenue(revenue) {
        return Number(revenue || 0).toFixed(2);
      }
    }, {
      key: "buildPayLoad",
      value: function buildPayLoad(rudderElement, isStandardEvent) {
        var dateFields = ["checkinDate", "checkoutDate", "departingArrivalDate", "departingDepartureDate", "returningArrivalDate", "returningDepartureDate", "travelEnd", "travelStart"];
        var defaultPiiProperties = ["email", "firstName", "lastName", "gender", "city", "country", "phone", "state", "zip", "birthday"];
        var whitelistPiiProperties = this.whitelistPiiProperties || [];
        var blacklistPiiProperties = this.blacklistPiiProperties || [];
        var eventCustomProperties = this.eventCustomProperties || [];
        var customPiiProperties = {};

        for (var i = 0; i < blacklistPiiProperties[i]; i++) {
          var configuration = blacklistPiiProperties[i];
          customPiiProperties[configuration.blacklistPiiProperties] = configuration.blacklistPiiHash;
        }

        var payload = {};
        var properties = rudderElement.message.properties;

        for (var property in properties) {
          if (!properties.hasOwnProperty(property)) {
            continue;
          }

          var customProperties = eventCustomProperties.map(function (e) {
            return e.eventCustomProperties;
          });

          if (isStandardEvent && customProperties.indexOf(property) < 0) {
            continue;
          }

          var value = properties[property];

          if (dateFields.indexOf(properties) >= 0) {
            if (is_1.date(value)) {
              payload[property] = value.toISOTring().split("T")[0];
              continue;
            }
          }

          if (customPiiProperties.hasOwnProperty(property)) {
            if (customPiiProperties[property] && typeof value === "string") {
              payload[property] = sha256(value).toString();
            }

            continue;
          }

          var isPropertyPii = defaultPiiProperties.indexOf(property) >= 0;
          var isProperyWhiteListed = whitelistPiiProperties.indexOf(property) >= 0;

          if (!isPropertyPii || isProperyWhiteListed) {
            payload[property] = value;
          }
        }

        return payload;
      }
    }]);

    return FacebookPixel;
  }();

  // util function to convert the input to string type
  function convertToString(input) {
    if (input) {
      if (typeof input === "string") {
        return input;
      }

      return String(input);
    }

    return "";
  } // convert string to words


  function toWords(input) {
    input = convertToString(input);
    var regex = /[A-Z\xC0-\xD6\xD8-\xDE]?[a-z\xDF-\xF6\xF8-\xFF]+|[A-Z\xC0-\xD6\xD8-\xDE]+(?![a-z\xDF-\xF6\xF8-\xFF])|\d+/g;
    return input.match(regex);
  } // convert the input array to camel case


  function toCamelCase(inputArray) {
    var result = "";

    for (var i = 0, len = inputArray.length; i < len; i++) {
      var currentStr = inputArray[i];
      var tempStr = currentStr.toLowerCase();

      if (i !== 0) {
        // convert first letter to upper case (the word is in lowercase)
        tempStr = tempStr.substr(0, 1).toUpperCase() + tempStr.substr(1);
      }

      result += tempStr;
    }

    return result;
  } // this function call all other functions


  function camelcase(input) {
    var words = toWords(input);
    return toCamelCase(words);
  }

  var Fullstory = /*#__PURE__*/function () {
    function Fullstory(config, analytics) {
      _classCallCheck(this, Fullstory);

      this.fs_org = config.fs_org;
      this.fs_debug_mode = config.fs_debug_mode;
      this.name = NAME$d;
      this.analytics = analytics;
    }

    _createClass(Fullstory, [{
      key: "init",
      value: function init() {
        logger.debug("===in init FULLSTORY===");
        window._fs_debug = this.fs_debug_mode;
        window._fs_host = "fullstory.com";
        window._fs_script = "edge.fullstory.com/s/fs.js";
        window._fs_org = this.fs_org;
        window._fs_namespace = "FS";

        (function (m, n, e, t, l, o, g, y) {
          if (e in m) {
            if (m.console && m.console.log) {
              m.console.log('FullStory namespace conflict. Please set window["_fs_namespace"].');
            }

            return;
          }

          g = m[e] = function (a, b, s) {
            g.q ? g.q.push([a, b, s]) : g._api(a, b, s);
          };

          g.q = [];
          o = n.createElement(t);
          o.async = 1;
          o.crossOrigin = "anonymous";
          o.src = "https://".concat(_fs_script);
          y = n.getElementsByTagName(t)[0];
          y.parentNode.insertBefore(o, y);

          g.identify = function (i, v, s) {
            g(l, {
              uid: i
            }, s);
            if (v) g(l, v, s);
          };

          g.setUserVars = function (v, s) {
            g(l, v, s);
          };

          g.event = function (i, v, s) {
            g("event", {
              n: i,
              p: v
            }, s);
          };

          g.shutdown = function () {
            g("rec", !1);
          };

          g.restart = function () {
            g("rec", !0);
          };

          g.log = function (a, b) {
            g("log", [a, b]);
          };

          g.consent = function (a) {
            g("consent", !arguments.length || a);
          };

          g.identifyAccount = function (i, v) {
            o = "account";
            v = v || {};
            v.acctId = i;
            g(o, v);
          };

          g.clearUserCookie = function () {};

          g._w = {};
          y = "XMLHttpRequest";
          g._w[y] = m[y];
          y = "fetch";
          g._w[y] = m[y];
          if (m[y]) m[y] = function () {
            return g._w[y].apply(this, arguments);
          };
        })(window, document, window._fs_namespace, "script", "user");

        var FULLSTORY = this.analytics.loadOnlyIntegrations.FULLSTORY; // Checking if crossDomainSupport is their or not.

        if ((FULLSTORY === null || FULLSTORY === void 0 ? void 0 : FULLSTORY.crossDomainSupport) === true) {
          // This function will check if the customer hash is available or not in localStorage
          window._fs_identity = function () {
            if (window.localStorage) {
              var tata_customer_hash = window.localStorage.tata_customer_hash;

              if (tata_customer_hash) {
                return {
                  uid: tata_customer_hash,
                  displayName: tata_customer_hash
                };
              }
            } else {
              logger.debug("Unable to access locaStorage");
            }

            return null;
          };

          (function () {
            function fs(api) {
              if (!window._fs_namespace) {
                console.error('FullStory unavailable, window["_fs_namespace"] must be defined');
                return undefined;
              }

              return api ? window[window._fs_namespace][api] : window[window._fs_namespace];
            }

            function waitUntil(predicateFn, callbackFn, timeout, timeoutFn) {
              var totalTime = 0;
              var delay = 64;

              var resultFn = function resultFn() {
                if (typeof predicateFn === "function" && predicateFn()) {
                  callbackFn();
                  return;
                }

                delay = Math.min(delay * 2, 1024);

                if (totalTime > timeout) {
                  if (timeoutFn) {
                    timeoutFn();
                  }
                }

                totalTime += delay;
                setTimeout(resultFn, delay);
              };

              resultFn();
            } // Checking if timeout is provided or not.


            var timeout = FULLSTORY.timeout || 2000;

            function identify() {
              if (typeof window._fs_identity === "function") {
                var userVars = window._fs_identity();

                if (_typeof(userVars) === "object" && typeof userVars.uid === "string") {
                  fs("setUserVars")(userVars);
                  fs("restart")();
                } else {
                  fs("log")("error", "FS.setUserVars requires an object that contains uid");
                }
              } else {
                fs("log")("error", 'window["_fs_identity"] function not found');
              }
            }

            fs("shutdown")();
            waitUntil(window._fs_identity, identify, timeout, fs("restart"));
          })();
        }
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("in FULLSORY page");
        var rudderMessage = rudderElement.message;
        var pageName = rudderMessage.name;

        var props = _objectSpread2({
          name: pageName
        }, rudderMessage.properties);

        window.FS.event("Viewed a Page", Fullstory.getFSProperties(props));
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("in FULLSORY identify");
        var userId = rudderElement.message.userId;
        var traits = rudderElement.message.context.traits;
        if (!userId) userId = rudderElement.message.anonymousId;
        if (Object.keys(traits).length === 0 && traits.constructor === Object) window.FS.identify(userId);else window.FS.identify(userId, Fullstory.getFSProperties(traits));
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("in FULLSTORY track");
        window.FS.event(rudderElement.message.event, Fullstory.getFSProperties(rudderElement.message.properties));
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("in FULLSTORY isLoaded");
        return !!window.FS;
      }
    }], [{
      key: "getFSProperties",
      value: function getFSProperties(properties) {
        var FS_properties = {};
        Object.keys(properties).map(function (key, index) {
          FS_properties[key === "displayName" || key === "email" ? key : Fullstory.camelCaseField(key)] = properties[key];
        });
        return FS_properties;
      }
    }, {
      key: "camelCaseField",
      value: function camelCaseField(fieldName) {
        // Do not camel case across type suffixes.
        var parts = fieldName.split("_");

        if (parts.length > 1) {
          var typeSuffix = parts.pop();

          switch (typeSuffix) {
            case "str":
            case "int":
            case "date":
            case "real":
            case "bool":
            case "strs":
            case "ints":
            case "dates":
            case "reals":
            case "bools":
              return "".concat(camelcase(parts.join("_")), "_").concat(typeSuffix);

          }
        } // No type suffix found. Camel case the whole field name.


        return camelcase(fieldName);
      }
    }]);

    return Fullstory;
  }();

  var GA = /*#__PURE__*/function () {
    function GA(config, analytics) {
      _classCallCheck(this, GA);

      this.analytics = analytics;
      this.trackingID = config.trackingID;
      this.sendUserId = config.sendUserId || false;
      this.dimensions = config.dimensions || [];
      this.metrics = config.metrics || [];
      this.contentGroupings = config.contentGroupings || [];
      this.nonInteraction = config.nonInteraction || false;
      this.anonymizeIp = config.anonymizeIp || false;
      this.useGoogleAmpClientId = config.useGoogleAmpClientId || false;
      this.domain = config.domain || "auto";
      this.doubleClick = config.doubleClick || false;
      this.enhancedEcommerce = config.enhancedEcommerce || false;
      this.enhancedLinkAttribution = config.enhancedLinkAttribution || false;
      this.includeSearch = config.includeSearch || false;
      this.setAllMappedProps = config.setAllMappedProps || true;
      this.siteSpeedSampleRate = config.siteSpeedSampleRate || 1;
      this.sampleRate = config.sampleRate || 100;
      this.trackCategorizedPages = config.trackCategorizedPages || true;
      this.trackNamedPages = config.trackNamedPages || true;
      this.useRichEventNames = config.useRichEventNames || false;
      this.optimizeContainerId = config.optimize || "";
      this.resetCustomDimensionsOnPage = config.resetCustomDimensionsOnPage || [];
      this.enhancedEcommerceLoaded = 0;
      this.namedTracker = config.namedTracker || false;
      this.name = NAME$e;
      this.eventWithCategoryFieldProductScoped = ["product clicked", "product added", "product viewed", "product removed"];
    }

    _createClass(GA, [{
      key: "initializeGlobalObject",
      value: function initializeGlobalObject() {
        window.GoogleAnalyticsObject = "ga";

        window.ga = window.ga || function a() {
          window.ga.q = window.ga.q || [];
          window.ga.q.push(arguments);
        };

        window.ga.l = new Date().getTime();
      }
    }, {
      key: "loadScript",
      value: function loadScript() {
        ScriptLoader("google-analytics", "https://www.google-analytics.com/analytics.js");
      }
    }, {
      key: "init",
      value: function init() {
        var _this = this;

        this.pageCalled = false;
        this.dimensionsArray = {};
        var elementTo;
        this.dimensions.forEach(function (element) {
          if (element.to.startsWith("dimension")) {
            _this.dimensionsArray[element.from] = element.to;
          } else {
            /* eslint-disable no-param-reassign */
            elementTo = element.to.replace(/cd/g, "dimension");
            _this.dimensionsArray[element.from] = elementTo;
          }
        });
        this.metricsArray = {};
        this.metrics.forEach(function (element) {
          if (element.to.startsWith("dimension")) {
            _this.metricsArray[element.from] = element.to;
          } else {
            elementTo = element.to.replace(/cm/g, "metric");
            _this.metricsArray[element.from] = elementTo;
          }
        });
        this.contentGroupingsArray = {};
        this.contentGroupings.forEach(function (element) {
          _this.contentGroupingsArray[element.from] = element.to;
        });

        if (this.analytics.loadIntegration) {
          this.initializeGlobalObject();
          this.loadScript();
        } // create ga with these properties. if the properties are empty it will take default values.


        var config = {
          cookieDomain: this.domain || GA.prototype.defaults.domain,
          siteSpeedSampleRate: this.siteSpeedSampleRate,
          sampleRate: this.sampleRate,
          allowLinker: true,
          useAmpClientId: this.useGoogleAmpClientId
        }; // set tracker name to rudderGATracker if on

        if (this.namedTracker) {
          config.name = "rudderGATracker";
          this.trackerName = "rudderGATracker.";
        } else {
          this.trackerName = "";
        }

        window.ga("create", this.trackingID, config);

        if (this.analytics.loadIntegration) {
          if (this.optimizeContainerId) {
            window.ga("".concat(this.trackerName, "require"), this.optimizeContainerId);
          } // ecommerce is required


          if (!this.ecommerce) {
            window.ga("".concat(this.trackerName, "require"), "ecommerce");
            this.ecommerce = true;
          } // this is to display advertising


          if (this.doubleClick) {
            window.ga("".concat(this.trackerName, "require"), "displayfeatures");
          } // https://support.google.com/analytics/answer/2558867?hl=en


          if (this.enhancedLinkAttribution) {
            window.ga("".concat(this.trackerName, "require"), "linkid");
          }
        } // a warning is in ga debugger if anonymize is false after initialization


        if (this.anonymizeIp) {
          window.ga("".concat(this.trackerName, "set"), "anonymizeIp", true);
        }

        logger.debug("===in init GA===");
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        // send global id
        if (this.sendUserId && rudderElement.message.userId) {
          window.ga("".concat(this.trackerName, "set"), "userId", rudderElement.message.userId);
        } // custom dimensions and metrics


        var custom = this.metricsFunction(rudderElement.message.context.traits, this.dimensionsArray, this.metricsArray, this.contentGroupingsArray);

        if (Object.keys(custom).length) {
          window.ga("".concat(this.trackerName, "set"), custom);
        }

        logger.debug("in GoogleAnalyticsManager identify");
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        var _this2 = this;

        var self = this; // Ecommerce events

        var _rudderElement$messag = rudderElement.message,
            event = _rudderElement$messag.event,
            properties = _rudderElement$messag.properties,
            name = _rudderElement$messag.name;
        var options = this.extractCheckoutOptions(rudderElement);
        var props = rudderElement.message.properties;
        var products = properties.products;
        var total = properties.total;
        var data = {};
        var eventCategory = rudderElement.message.properties.category;
        var orderId = properties.order_id;
        var eventAction = event || name || "";
        var eventLabel = rudderElement.message.properties.label;
        var eventValue = "";
        var payload;
        var campaign = rudderElement.message.context.campaign;
        var params;
        var filters;
        var sorts;

        if (event === "Order Completed" && !this.enhancedEcommerce) {
          // order_id is required
          if (!orderId) {
            logger.debug("order_id not present events are not sent to GA");
            return;
          } // add transaction


          window.ga("".concat(this.trackerName, "ecommerce:addTransaction"), {
            affiliation: properties.affiliation,
            shipping: properties.shipping,
            revenue: total,
            tax: properties.tax,
            id: orderId,
            currency: properties.currency
          }); // products added

          products.forEach(function (product) {
            var productTrack = self.createProductTrack(rudderElement, product);
            window.ga("".concat(_this2.trackerName, "ecommerce:addItem"), {
              category: productTrack.properties.category,
              quantity: productTrack.properties.quantity,
              price: productTrack.properties.price,
              name: productTrack.properties.name,
              sku: productTrack.properties.sku,
              id: orderId,
              currency: productTrack.properties.currency
            });
          });
          window.ga("".concat(this.trackerName, "ecommerce:send"));
        } // enhanced ecommerce events
        else if (this.enhancedEcommerce) {
          switch (event) {
            case "Checkout Started":
            case "Checkout Step Viewed":
            case "Order Updated":
              this.loadEnhancedEcommerce(rudderElement);
              componentEach(products, function (product) {
                var productTrack = self.createProductTrack(rudderElement, product);
                productTrack = {
                  message: productTrack
                };
                self.enhancedEcommerceTrackProduct(productTrack);
              });
              window.ga("".concat(this.trackerName, "ec:setAction"), "checkout", {
                step: properties.step || 1,
                option: options || undefined
              });
              this.pushEnhancedEcommerce(rudderElement);
              break;

            case "Checkout Step Completed":
              if (!props.step) {
                logger.debug("step not present events are not sent to GA");
                return;
              }

              params = {
                step: props.step || 1,
                option: options || undefined
              };
              this.loadEnhancedEcommerce(rudderElement);
              window.ga("".concat(this.trackerName, "ec:setAction"), "checkout_option", params);
              window.ga("".concat(this.trackerName, "send"), "event", "Checkout", "Option");
              break;

            case "Order Completed":
              total = rudderElement.message.properties.total || rudderElement.message.properties.revenue || 0;

              if (!orderId) {
                logger.debug("order_id not present events are not sent to GA");
                return;
              }

              this.loadEnhancedEcommerce(rudderElement);
              componentEach(products, function (product) {
                var productTrack = self.createProductTrack(rudderElement, product);
                productTrack = {
                  message: productTrack
                };
                self.enhancedEcommerceTrackProduct(productTrack);
              });
              window.ga("".concat(this.trackerName, "ec:setAction"), "purchase", {
                id: orderId,
                affiliation: props.affiliation,
                revenue: total,
                tax: props.tax,
                shipping: props.shipping,
                coupon: props.coupon
              });
              this.pushEnhancedEcommerce(rudderElement);
              break;

            case "Order Refunded":
              if (!orderId) {
                logger.debug("order_id not present events are not sent to GA");
                return;
              }

              this.loadEnhancedEcommerce(rudderElement);
              componentEach(products, function (product) {
                var track = {
                  properties: product
                };
                window.ga("".concat(_this2.trackerName, "ec:addProduct"), {
                  id: track.properties.product_id || track.properties.id || track.properties.sku,
                  quantity: track.properties.quantity
                });
              });
              window.ga("".concat(this.trackerName, "ec:setAction"), "refund", {
                id: orderId
              });
              this.pushEnhancedEcommerce(rudderElement);
              break;

            case "Product Added":
              this.loadEnhancedEcommerce(rudderElement);
              this.enhancedEcommerceTrackProductAction(rudderElement, "add", null);
              this.pushEnhancedEcommerce(rudderElement);
              break;

            case "Product Removed":
              this.loadEnhancedEcommerce(rudderElement);
              this.enhancedEcommerceTrackProductAction(rudderElement, "remove", null);
              this.pushEnhancedEcommerce(rudderElement);
              break;

            case "Product Viewed":
              this.loadEnhancedEcommerce(rudderElement);
              if (props.list) data.list = props.list;
              this.enhancedEcommerceTrackProductAction(rudderElement, "detail", data);
              this.pushEnhancedEcommerce(rudderElement);
              break;

            case "Product Clicked":
              this.loadEnhancedEcommerce(rudderElement);
              if (props.list) data.list = props.list;
              this.enhancedEcommerceTrackProductAction(rudderElement, "click", data);
              this.pushEnhancedEcommerce(rudderElement);
              break;

            case "Promotion Viewed":
              this.loadEnhancedEcommerce(rudderElement);
              window.ga("".concat(this.trackerName, "ec:addPromo"), {
                id: props.promotion_id || props.id,
                name: props.name,
                creative: props.creative,
                position: props.position
              });
              this.pushEnhancedEcommerce(rudderElement);
              break;

            case "Promotion Clicked":
              this.loadEnhancedEcommerce(rudderElement);
              window.ga("".concat(this.trackerName, "ec:addPromo"), {
                id: props.promotion_id || props.id,
                name: props.name,
                creative: props.creative,
                position: props.position
              });
              window.ga("".concat(this.trackerName, "ec:setAction"), "promo_click", {});
              this.pushEnhancedEcommerce(rudderElement);
              break;

            case "Product List Viewed":
              this.loadEnhancedEcommerce(rudderElement);
              componentEach(products, function (product) {
                var item = {
                  properties: product
                };

                if (!(item.properties.product_id || item.properties.sku) && !item.properties.name) {
                  logger.debug("product_id/sku/name of product not present events are not sent to GA");
                  return;
                }

                var impressionObj = {
                  id: item.properties.product_id || item.properties.sku,
                  name: item.properties.name,
                  category: item.properties.category || props.category,
                  list: props.list_id || props.category || "products",
                  brand: item.properties.band,
                  variant: item.properties.variant,
                  price: item.properties.price,
                  position: self.getProductPosition(item, products)
                };
                impressionObj = _objectSpread2(_objectSpread2({}, impressionObj), self.metricsFunction(item.properties, self.dimensionsArray, self.metricsArray, self.contentGroupingsArray));
                Object.keys(impressionObj).forEach(function (key) {
                  if (impressionObj[key] === undefined) delete impressionObj[key];
                });
                window.ga("".concat(_this2.trackerName, "ec:addImpression"), impressionObj);
              });
              this.pushEnhancedEcommerce(rudderElement);
              break;

            case "Product List Filtered":
              props.filters = props.filters || [];
              props.sorts = props.sorts || [];
              filters = props.filters.map(function (obj) {
                return "".concat(obj.type, ":").concat(obj.value);
              }).join();
              sorts = props.sorters.map(function (obj) {
                return "".concat(obj.type, ":").concat(obj.value);
              }).join();
              this.loadEnhancedEcommerce(rudderElement);
              componentEach(products, function (product) {
                var item = {
                  properties: product
                };

                if (!(item.properties.product_id || item.properties.sku) && !item.properties.name) {
                  logger.debug("product_id/sku/name of product not present events are not sent to GA");
                  return;
                }

                var impressionObj = {
                  id: item.properties.product_id || item.sku,
                  name: item.name,
                  category: item.category || props.category,
                  list: props.list_id || props.category || "search results",
                  brand: props.brand,
                  variant: "".concat(filters, "::").concat(sorts),
                  price: item.price,
                  position: self.getProductPosition(item, products)
                };
                impressionObj = _objectSpread2({
                  impressionObj: impressionObj
                }, self.metricsFunction(item.properties, self.dimensionsArray, self.metricsArray, self.contentGroupingsArray));
                Object.keys(impressionObj).forEach(function (key) {
                  if (impressionObj[key] === undefined) delete impressionObj[key];
                });
                window.ga("".concat(_this2.trackerName, "ec:addImpression"), impressionObj);
              });
              this.pushEnhancedEcommerce(rudderElement);
              break;

            default:
              if (rudderElement.message.properties) {
                eventValue = rudderElement.message.properties.value ? rudderElement.message.properties.value : rudderElement.message.properties.revenue;
              }

              payload = {
                eventCategory: eventCategory || "All",
                eventAction: eventAction,
                eventLabel: eventLabel,
                eventValue: this.formatValue(eventValue),
                // Allow users to override their nonInteraction integration setting for any single particluar event.
                nonInteraction: rudderElement.message.properties.nonInteraction !== undefined ? !!rudderElement.message.properties.nonInteraction : !!this.nonInteraction
              };

              if (campaign) {
                if (campaign.name) payload.campaignName = campaign.name;
                if (campaign.source) payload.campaignSource = campaign.source;
                if (campaign.medium) payload.campaignMedium = campaign.medium;
                if (campaign.content) payload.campaignContent = campaign.content;
                if (campaign.term) payload.campaignKeyword = campaign.term;
              }

              payload = _objectSpread2({
                payload: payload
              }, this.setCustomDimenionsAndMetrics(rudderElement.message.properties));
              window.ga("".concat(this.trackerName, "send"), "event", payload.payload);
              logger.debug("in GoogleAnalyticsManager track");
          }
        } else {
          if (rudderElement.message.properties) {
            eventValue = rudderElement.message.properties.value ? rudderElement.message.properties.value : rudderElement.message.properties.revenue;
          }

          payload = {
            eventCategory: eventCategory || "All",
            eventAction: eventAction,
            eventLabel: eventLabel,
            eventValue: this.formatValue(eventValue),
            // Allow users to override their nonInteraction integration setting for any single particluar event.
            nonInteraction: rudderElement.message.properties.nonInteraction !== undefined ? !!rudderElement.message.properties.nonInteraction : !!this.nonInteraction
          };

          if (campaign) {
            if (campaign.name) payload.campaignName = campaign.name;
            if (campaign.source) payload.campaignSource = campaign.source;
            if (campaign.medium) payload.campaignMedium = campaign.medium;
            if (campaign.content) payload.campaignContent = campaign.content;
            if (campaign.term) payload.campaignKeyword = campaign.term;
          }

          payload = _objectSpread2({
            payload: payload
          }, this.setCustomDimenionsAndMetrics(rudderElement.message.properties));
          window.ga("".concat(this.trackerName, "send"), "event", payload.payload);
          logger.debug("in GoogleAnalyticsManager track");
        }
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("in GoogleAnalyticsManager page");
        var category = rudderElement.message.properties.category;
        var eventProperties = rudderElement.message.properties;
        var name;

        if (rudderElement.message.properties.category && rudderElement.message.name) {
          name = "".concat(rudderElement.message.properties.category, " ").concat(rudderElement.message.name);
        } else if (!rudderElement.message.properties.category && !rudderElement.message.name) {
          name = "";
        } else {
          name = rudderElement.message.name || rudderElement.message.properties.category;
        }

        var campaign = rudderElement.message.context.campaign || {};
        var pageview = {};
        var pagePath = this.path(eventProperties, this.includeSearch);
        var pageReferrer = rudderElement.message.properties.referrer || "";
        var pageTitle;
        if (!rudderElement.message.properties.category && !rudderElement.message.name) pageTitle = eventProperties.title;else if (!rudderElement.message.properties.category) pageTitle = rudderElement.message.name;else if (!rudderElement.message.name) pageTitle = rudderElement.message.properties.category;else pageTitle = name;
        pageview.page = pagePath;
        pageview.title = pageTitle;
        pageview.location = eventProperties.url;

        if (campaign) {
          if (campaign.name) pageview.campaignName = campaign.name;
          if (campaign.source) pageview.campaignSource = campaign.source;
          if (campaign.medium) pageview.campaignMedium = campaign.medium;
          if (campaign.content) pageview.campaignContent = campaign.content;
          if (campaign.term) pageview.campaignKeyword = campaign.term;
        }

        var resetCustomDimensions = {};

        for (var i = 0; i < this.resetCustomDimensionsOnPage.length; i += 1) {
          var property = this.resetCustomDimensionsOnPage[i].resetCustomDimensionsOnPage;

          if (this.dimensionsArray[property]) {
            resetCustomDimensions[this.dimensionsArray[property]] = null;
          }
        }

        window.ga("".concat(this.trackerName, "set"), resetCustomDimensions); // adds more properties to pageview which will be sent

        pageview = _objectSpread2(_objectSpread2({}, pageview), this.setCustomDimenionsAndMetrics(eventProperties));
        var payload = {
          page: pagePath,
          title: pageTitle
        };
        logger.debug("referrer: " + pageReferrer);
        logger.debug("document referrer: ", document.referrer);
        if (pageReferrer !== document.referrer) payload.referrer = pageReferrer;
        window.ga("".concat(this.trackerName, "set"), payload);
        if (this.pageCalled) delete pageview.location;
        window.ga("".concat(this.trackerName, "send"), "pageview", pageview); // categorized pages

        if (category && this.trackCategorizedPages) {
          if (this.useRichEventNames) {
            rudderElement.message.event = "Viewed ".concat(category, " Page");
            rudderElement.message.type = "track";
          }

          this.track(rudderElement, {
            nonInteraction: 1
          });
        } // named pages


        if (name && this.trackNamedPages) {
          if (this.useRichEventNames) {
            rudderElement.message.event = "Viewed ".concat(name, " Page");
            rudderElement.message.type = "track";
          }

          this.track(rudderElement, {
            nonInteraction: 1
          });
        }

        this.pageCalled = true;
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("in GA isLoaded");
        return !!window.gaplugins;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return !!window.gaplugins;
      }
      /**
       *
       *
       * @param  {} obj  incoming properties
       * @param  {} dimensions   the dimension mapping which is entered by the user in the ui. Eg: firstName : dimension1
       * @param  {} metrics  the metrics mapping which is entered by the user in the ui. Eg: age : metrics1
       * @param  {} contentGroupings the contentGrouping mapping which is entered by the user in the ui. Eg: section : contentGrouping1
       *
       * This function maps these dimensions,metrics and contentGroupings with the incoming properties to send it to GA where the user has to set the corresponding dimension/metric/content group.
       * For example if:
       * if obj -> {age: 24}
       * metrics -> {age: metric1}
       * then the function will return {metric1:24} and it will be shown sent to GA if metric1 is set there.
       *
       * if obj -> {age: 24}
       * metrics - {revenue: metric2}
       * then the function will return {} as there is no corresponding mapping of metric.
       *
       */

    }, {
      key: "metricsFunction",
      value: function metricsFunction(obj, dimensions, metrics, contentGroupings) {
        var ret = {};
        componentEach([metrics, dimensions, contentGroupings], function (group) {
          componentEach(group, function (prop, key) {
            var value = obj[prop];
            if (is_1.boolean(value)) value = value.toString();
            if (value || value === 0) ret[key] = value;
          });
        });
        return ret;
      }
    }, {
      key: "formatValue",
      value: function formatValue(value) {
        if (!value || value < 0) return 0;
        return Math.round(value);
      }
      /**
       * @param  {} props
       * @param  {} inputs
       */

    }, {
      key: "setCustomDimenionsAndMetrics",
      value: function setCustomDimenionsAndMetrics(props) {
        var ret = {};
        var custom = this.metricsFunction(props, this.dimensionsArray, this.metricsArray, this.contentGroupingsArray);

        if (Object.keys(custom).length) {
          if (this.setAllMappedProps) {
            window.ga("".concat(this.trackerName, "set"), custom);
          } else {
            Object.keys(custom).forEach(function (key) {
              ret[key] = custom[key];
            }); // each(custom, (key, value) => {
            //   ret[key] = value;
            // });
          }
        }

        return ret;
      }
      /**
       *  Return the path based on `properties` and `options`
       *
       * @param  {} properties
       * @param  {} includeSearch
       */

    }, {
      key: "path",
      value: function path(properties, includeSearch) {
        var str = properties.path;

        if (properties) {
          if (includeSearch && properties.search) {
            str += properties.search;
          }
        }

        return str;
      }
      /**
       * Creates a track out of product properties
       * @param  {} rudderElement
       * @param  {} properties
       */

    }, {
      key: "createProductTrack",
      value: function createProductTrack(rudderElement, properties) {
        var props = properties || {};
        props.currency = properties.currency || rudderElement.message.properties.currency;
        return {
          properties: props
        };
      }
      /**
       * Loads ec.js (unless already loaded)
       * @param  {} rudderElement
       * @param  {} a
       */

    }, {
      key: "loadEnhancedEcommerce",
      value: function loadEnhancedEcommerce(rudderElement) {
        if (this.enhancedEcommerceLoaded === 0) {
          window.ga("".concat(this.trackerName, "require"), "ec");
          this.enhancedEcommerceLoaded = 1;
        }

        window.ga("".concat(this.trackerName, "set"), "&cu", rudderElement.message.properties.currency);
      }
      /**
       * helper class to not repeat `ec:addProduct`
       * @param  {} rudderElement
       * @param  {} inputs
       */

    }, {
      key: "enhancedEcommerceTrackProduct",
      value: function enhancedEcommerceTrackProduct(rudderElement) {
        var props = rudderElement.message.properties;
        var product = {
          id: props.product_id || props.id || props.sku,
          name: props.name,
          category: props.category,
          quantity: props.quantity,
          price: props.price,
          brand: props.brand,
          variant: props.variant,
          currency: props.currency
        };

        if (props.position != null) {
          product.position = Math.round(props.position);
        }

        var coupon = props.coupon;
        if (coupon) product.coupon = coupon;
        product = _objectSpread2(_objectSpread2({}, product), this.metricsFunction(props, this.dimensionsArray, this.metricsArray, this.contentGroupingsArray));
        window.ga("".concat(this.trackerName, "ec:addProduct"), product);
      }
      /**
       * set action with data
       * @param  {} rudderElement
       * @param  {} action
       * @param  {} data
       * @param  {} inputs
       */

    }, {
      key: "enhancedEcommerceTrackProductAction",
      value: function enhancedEcommerceTrackProductAction(rudderElement, action, data) {
        this.enhancedEcommerceTrackProduct(rudderElement);
        window.ga("".concat(this.trackerName, "ec:setAction"), action, data || {});
      }
      /**
       * @param  {} rudderElement
       * @param  {} inputs
       */

    }, {
      key: "pushEnhancedEcommerce",
      value: function pushEnhancedEcommerce(rudderElement) {
        var _window$ga;

        var args = rejectArr(["send", "event", rudderElement.message.properties.category || "EnhancedEcommerce", rudderElement.message.event || "Action not defined", rudderElement.message.properties.label, _objectSpread2({
          nonInteraction: 1
        }, this.setCustomDimenionsAndMetrics(rudderElement.message.properties))]);
        var event = rudderElement.message.event;
        event = event.toLowerCase();

        if (this.eventWithCategoryFieldProductScoped.includes(event)) {
          args[2] = "EnhancedEcommerce";
        }

        (_window$ga = window.ga).call.apply(_window$ga, [window].concat(_toConsumableArray(args)));
      }
      /**
       * @param  {} item
       * @param  {} products
       */

    }, {
      key: "getProductPosition",
      value: function getProductPosition(item, products) {
        var position = item.properties.position;

        if (typeof position !== "undefined" && !Number.isNaN(Number(position)) && Number(position) > -1) {
          return position;
        }

        return products.map(function (x) {
          return x.product_id;
        }).indexOf(item.properties.product_id) + 1;
      }
      /**
       *extracts checkout options
       * @param  {} rudderElement
       */

    }, {
      key: "extractCheckoutOptions",
      value: function extractCheckoutOptions(rudderElement) {
        var options = [rudderElement.message.properties.paymentMethod, rudderElement.message.properties.shippingMethod]; // remove all nulls and join with commas.

        var valid = rejectArr(options);
        return valid.length > 0 ? valid.join(", ") : null;
      }
    }]);

    return GA;
  }();

  var GA$1 =  GA ;

  var requiredEventParameters = {
    PromotionId: "promotion_id",
    PromotionName: "promotion_name",
    Search: "search_term",
    ProductId: "item_id",
    ProductName: "item_name"
  }; // To Do : Future Scope :: We can remove this one and add everything in include list.
  // This will also simplify our existing code and complex logics related to that

  var includeParams = {
    CartShare: {
      defaults: {
        content_type: "Cart"
      },
      mappings: {
        share_via: "method",
        cart_id: "content_id"
      }
    },
    ProductShare: {
      defaults: {
        content_type: "Product"
      },
      mappings: {
        share_via: "method",
        product_id: "content_id"
      }
    },
    Search: {
      mappings: {
        query: "search_term"
      }
    },
    Promotion: {
      mappings: {
        position: "location_id"
      }
    }
  };
  var eventParametersConfigArray = {
    ListId: {
      src: "list_id",
      dest: "item_list_id",
      inItems: true
    },
    Category: {
      src: "category",
      dest: "item_list_name",
      inItems: true
    },
    Price: {
      src: "price",
      dest: "value"
    },
    Currency: {
      src: "currency",
      dest: "currency",
      inItems: true
    },
    Coupon: {
      src: "coupon",
      dest: "coupon",
      inItems: true
    },
    Affiliation: {
      src: "affiliation",
      dest: "affiliation",
      inItems: true
    },
    Shipping: {
      src: "shipping",
      dest: "shipping"
    },
    Tax: {
      src: "tax",
      dest: "tax"
    },
    Total: {
      src: "total",
      dest: "value"
    },
    OrderId: {
      src: "order_id",
      dest: "transaction_id"
    },
    ShippingMethod: {
      src: "shipping_method",
      dest: "shipping_tier"
    },
    PaymentMethod: {
      src: "payment_method",
      dest: "payment_type"
    }
  };
  var itemParametersConfigArray = [{
    src: "product_id",
    dest: "item_id"
  }, {
    src: "name",
    dest: "item_name"
  }, {
    src: "coupon",
    dest: "coupon"
  }, {
    src: "category",
    dest: "item_category"
  }, {
    src: "brand",
    dest: "item_brand"
  }, {
    src: "variant",
    dest: "item_variant"
  }, {
    src: "price",
    dest: "price"
  }, {
    src: "quantity",
    dest: "quantity"
  }, {
    src: "position",
    dest: "index"
  }];
  var eventNamesConfigArray = [// Browsing Section
  {
    src: ["products searched", "product searched"],
    dest: "search",
    requiredParams: requiredEventParameters.Search,
    onlyIncludeParams: includeParams.Search
  }, {
    src: ["product list viewed"],
    dest: "view_item_list",
    requiredParams: [requiredEventParameters.ProductId, requiredEventParameters.ProductName],
    hasItem: true,
    includeList: [eventParametersConfigArray.ListId, eventParametersConfigArray.Category]
  }, // Promotion Section
  {
    src: ["promotion viewed"],
    dest: "view_promotion",
    onlyIncludeParams: includeParams.Promotion
  }, {
    src: ["promotion clicked"],
    dest: "select_promotion",
    onlyIncludeParams: includeParams.Promotion
  }, // Ordering Section
  {
    src: ["product clicked", "products clicked"],
    dest: "select_item",
    requiredParams: [requiredEventParameters.ProductId, requiredEventParameters.ProductName],
    hasItem: true,
    includeList: [eventParametersConfigArray.ListId, eventParametersConfigArray.Category]
  }, {
    src: ["product viewed"],
    dest: "view_item",
    requiredParams: [requiredEventParameters.ProductId, requiredEventParameters.ProductName],
    hasItem: true,
    includeList: [eventParametersConfigArray.Currency, eventParametersConfigArray.Total]
  }, {
    src: ["product added"],
    dest: "add_to_cart",
    requiredParams: [requiredEventParameters.ProductId, requiredEventParameters.ProductName],
    hasItem: true,
    includeList: [eventParametersConfigArray.Currency, eventParametersConfigArray.Total]
  }, {
    src: ["product removed"],
    dest: "remove_from_cart",
    requiredParams: [requiredEventParameters.ProductId, requiredEventParameters.ProductName],
    hasItem: true,
    includeList: [eventParametersConfigArray.Currency, eventParametersConfigArray.Total]
  }, {
    src: ["cart viewed"],
    dest: "view_cart",
    requiredParams: [requiredEventParameters.ProductId, requiredEventParameters.ProductName],
    hasItem: true,
    includeList: [eventParametersConfigArray.Currency, eventParametersConfigArray.Total]
  }, {
    src: ["checkout started"],
    dest: "begin_checkout",
    requiredParams: [requiredEventParameters.ProductId, requiredEventParameters.ProductName],
    hasItem: true,
    includeList: [eventParametersConfigArray.Coupon, eventParametersConfigArray.Currency, eventParametersConfigArray.Total]
  }, {
    src: ["payment info entered"],
    dest: "add_payment_info",
    hasItem: false,
    includeList: [eventParametersConfigArray.PaymentMethod]
  }, {
    src: ["payment info entered"],
    dest: "add_shipping_info",
    hasItem: false,
    includeList: [eventParametersConfigArray.ShippingMethod]
  }, {
    src: ["order completed"],
    dest: "purchase",
    requiredParams: [requiredEventParameters.ProductId, requiredEventParameters.ProductName],
    hasItem: true,
    includeList: [eventParametersConfigArray.Affiliation, eventParametersConfigArray.Coupon, eventParametersConfigArray.Currency, eventParametersConfigArray.OrderId, eventParametersConfigArray.Shipping, eventParametersConfigArray.Tax, eventParametersConfigArray.Total]
  }, {
    src: ["order refunded"],
    dest: "refund",
    hasItem: true,
    includeList: [eventParametersConfigArray.Affiliation, eventParametersConfigArray.Coupon, eventParametersConfigArray.Currency, eventParametersConfigArray.OrderId, eventParametersConfigArray.Shipping, eventParametersConfigArray.Tax, eventParametersConfigArray.Total]
  },
  /* Coupon Section
    No Coupon Events present in GA4
  /----------  */
  // Wishlist Section
  {
    src: ["product added to wishlist"],
    dest: "add_to_wishlist",
    requiredParams: [requiredEventParameters.ProductId, requiredEventParameters.ProductName],
    hasItem: true,
    includeList: [eventParametersConfigArray.Currency, eventParametersConfigArray.Total]
  }, //-------
  // Sharing Section
  {
    src: ["product shared"],
    dest: "share",
    hasItem: false,
    onlyIncludeParams: includeParams.ProductShare
  }, {
    src: ["cart shared"],
    dest: "share",
    hasItem: false,
    onlyIncludeParams: includeParams.CartShare
  }, //---------
  {
    src: ["group"],
    dest: "join_group",
    hasItem: false
  }];

  var pageEventParametersConfigArray = [{
    src: "path",
    dest: "page_location"
  }, {
    src: "referrer",
    dest: "page_referrer"
  }, {
    src: "title",
    dest: "page_title"
  }];

  /**
   * Check if event name is not one of the following reserved names
   * @param {*} name
   */

  function isReservedName(name) {
    var reservedEventNames = ["ad_activeview", "ad_click", "ad_exposure", "ad_impression", "ad_query", "adunit_exposure", "app_clear_data", "app_install", "app_update", "app_remove", "error", "first_open", "first_visit", "in_app_purchase", "notification_dismiss", "notification_foreground", "notification_open", "notification_receive", "os_update", "screen_view", "session_start", "user_engagement"];
    return reservedEventNames.includes(name);
  }
  /**
   * map rudder event name to ga4 ecomm event name and return array
   * @param {*} event
   */


  function getDestinationEventName(event) {
    return eventNamesConfigArray.filter(function (p) {
      return p.src.includes(event.toLowerCase());
    });
  }
  /**
   * Create item array and add into destination parameters
   * If 'items' prop is present push new key value into it else create a new and push data
   * 'items' -> name of GA4 Ecommerce property name.
   * For now its hard coded, we can think of some better soln. later.
   * @param {*} dest
   * @param {*} key
   * @param {*} value
   */


  function createItemProperty(dest, key, value) {
    var destinationProperties = dest;

    if (!destinationProperties.items) {
      destinationProperties.items = [];
      destinationProperties.items.push(_defineProperty({}, key, value));
    } else {
      destinationProperties.items[0][key] = value;
    }

    return destinationProperties;
  }
  /**
   * Check if your payload contains required parameters to map to ga4 ecomm
   * @param {*} includeRequiredParams this can be boolean or an array or required object
   * @param {*} key
   * @param {*} src
   */


  function hasRequiredParameters(props, eventMappingObj) {
    var requiredParams = eventMappingObj.requiredParams || false;
    if (!requiredParams) return true;

    if (!Array.isArray(requiredParams)) {
      if (props[requiredParams]) {
        return true;
      }

      return false;
    }

    for (var i in props.items) {
      for (var p in requiredParams) {
        if (!props.items[i][requiredParams[p]]) {
          return false;
        }
      }
    }

    return true;
  }
  /**
   * TO DO Future Improvement ::::
   * Here we only support mapping single level object mapping.
   * Implement using recursion to handle multi level prop mapping.
   * @param {*} props { product_id: 123456_abcdef, name: "chess-board", list_id: "ls_abcdef", category: games }
   * @param {*} destParameterConfig
   * Defined Parameter present GA4/utils.js ex: [{ src: "category", dest: "item_list_name", inItems: true }]
   * @param {*} includeRequiredParams contains object of required parameter to be mapped from source payload
   * output: {
    "item_list_id": "ls_abcdef",
    "items": [
      {
        "item_id": "123456_abcdef",
        "item_name": "chess-board",
        "item_list_id": "ls_abc",
        "item_list_name": "games"
      }
    ],
    "item_list_name": "games"
  }
  */


  function getDestinationEventProperties(props, destParameterConfig) {
    var hasItem = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var destinationProperties = {};
    Object.keys(props).forEach(function (key) {
      destParameterConfig.forEach(function (param) {
        if (key === param.src) {
          // handle case where the key needs to go inside items as well as top level params in GA4
          if (param.inItems && hasItem) {
            destinationProperties = createItemProperty(destinationProperties, param.dest, props[key]);
          }

          destinationProperties[param.dest] = props[key];
        }
      });
    });
    return destinationProperties;
  }
  /**
   * Map rudder products arrays payload to ga4 ecomm items array
   * @param {*} products
   * @param {*} item
   */


  function getDestinationItemProperties(products, item) {
    var items = [];
    var obj = {};

    if (type(products) !== "array") {
      logger.debug("Event payload doesn't have products array");
    } else {
      // get the dest keys from itemParameters config
      // append the already created item object keys (this is done to get the keys that are actually top level props in Rudder payload but GA expects them under items too)
      products.forEach(function (p) {
        obj = _objectSpread2(_objectSpread2({}, getDestinationEventProperties(p, itemParametersConfigArray)), item && type(item) === "array" && item[0] || {});
        items.push(obj);
      });
    }

    return items;
  }
  /**
   * Generate ga4 page_view events payload
   * @param {*} props
   */


  function getPageViewProperty(props) {
    return getDestinationEventProperties(props, pageEventParametersConfigArray);
  }

  var GA4 = /*#__PURE__*/function () {
    function GA4(config, analytics) {
      _classCallCheck(this, GA4);

      this.measurementId = config.measurementId;
      this.analytics = analytics;
      this.sendUserId = config.sendUserId || false;
      this.blockPageView = config.blockPageViewEvent || false;
      this.extendPageViewParams = config.extendPageViewParams || false;
      this.extendGroupPayload = config.extendGroupPayload || false;
      this.name = NAME$f;
    }

    _createClass(GA4, [{
      key: "loadScript",
      value: function loadScript(measurementId, userId) {
        window.dataLayer = window.dataLayer || [];

        window.gtag = window.gtag || function gt() {
          // eslint-disable-next-line prefer-rest-params
          window.dataLayer.push(arguments);
        };

        window.gtag("js", new Date()); // This condition is not working, even after disabling page view
        // page_view is even getting called on page load

        if (this.blockPageView) {
          if (this.sendUserId) {
            window.gtag("config", measurementId, {
              user_id: userId,
              send_page_view: false
            });
          } else {
            window.gtag("config", measurementId, {
              send_page_view: false
            });
          }
        } else if (this.sendUserId) {
          window.gtag("config", measurementId, {
            user_id: userId
          });
        } else {
          window.gtag("config", measurementId);
        }

        ScriptLoader("google-analytics 4", "https://www.googletagmanager.com/gtag/js?id=".concat(measurementId));
      }
    }, {
      key: "init",
      value: function init() {
        // To do :: check how custom dimension and metrics is used
        var userId = this.analytics.userId || this.analytics.anonymousId;
        this.loadScript(this.measurementId, userId);
      }
      /* utility functions ---Start here ---  */

    }, {
      key: "isLoaded",
      value: function isLoaded() {
        return !!(window.gtag && window.gtag.push !== Array.prototype.push);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return !!(window.gtag && window.gtag.push !== Array.prototype.push);
      }
      /* utility functions --- Ends here ---  */

      /**
       * Function to get destination properties for both event parameters and items array if present
       * For top level properties, include only those properties that are in the includeList
       * @param {*} properties
       * @param {*} hasItem
       * @param {*} products
       * @param {*} includeList
       */

    }, {
      key: "getdestinationProperties",
      value: function getdestinationProperties(properties, hasItem, products, includeList) {
        var destinationProperties = {};
        destinationProperties = getDestinationEventProperties(properties, includeList, hasItem);

        if (hasItem) {
          // only for events where GA requires an items array to be sent
          // get the product related destination keys || if products is not present use the rudder message properties to get the product related destination keys
          destinationProperties.items = getDestinationItemProperties(products || [properties], destinationProperties.items);
        }

        return destinationProperties;
      }
      /**
       * Only include params that are present in given mapping config for things like Cart/Product shared, Product/Products shared
       * @param {*} params
       * @param {*} properties
       */

    }, {
      key: "getIncludedParameters",
      value: function getIncludedParameters(params, properties) {
        var destinationProperties = {};

        if (type(params) === "object") {
          var defaults = params.defaults,
              mappings = params.mappings;

          if (type(defaults) === "object") {
            Object.keys(defaults).forEach(function (key) {
              destinationProperties[key] = defaults[key];
            });
          }

          if (type(mappings) === "object") {
            Object.keys(mappings).forEach(function (key) {
              destinationProperties[mappings[key]] = properties[key];
            });
          }
        }

        return destinationProperties;
      }
    }, {
      key: "sendGAEvent",
      value: function sendGAEvent(event, parameters, checkRequiredParameters, eventMappingObj) {
        if (checkRequiredParameters) {
          if (!hasRequiredParameters(parameters, eventMappingObj)) {
            throw Error("Payload must have required parameters..");
          }
        }

        window.gtag("event", event, parameters);
      }
    }, {
      key: "handleEventMapper",
      value: function handleEventMapper(eventMappingObj, properties, products) {
        var destinationProperties = {};
        var event = eventMappingObj.dest;

        if (eventMappingObj.onlyIncludeParams) {
          /* Only include params that are present in given mapping config for things like Cart/Product shared, Product/Products shared
           */
          var includeParams = eventMappingObj.onlyIncludeParams;
          destinationProperties = this.getIncludedParameters(includeParams, properties);
        } else {
          destinationProperties = this.getdestinationProperties(properties, eventMappingObj.hasItem, products, eventMappingObj.includeList);
        }

        this.sendGAEvent(event, destinationProperties, true, eventMappingObj);
      }
      /**
       *
       * @param {*} rudderElement
       */

    }, {
      key: "track",
      value: function track(rudderElement) {
        var _this = this;

        var event = rudderElement.message.event;
        var properties = rudderElement.message.properties;
        var products = properties.products;

        if (!event || isReservedName(event)) {
          throw Error("Cannot call un-named/reserved named track event");
        } // get GA4 event name and corresponding configs defined to add properties to that event


        var eventMappingArray = getDestinationEventName(event);

        if (eventMappingArray && eventMappingArray.length) {
          eventMappingArray.forEach(function (events) {
            _this.handleEventMapper(events, properties, products);
          });
        } else {
          this.sendGAEvent(event, flattenJsonPayload(properties), false);
        }
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        window.gtag("set", "user_properties", flattenJsonPayload(this.analytics.userTraits));

        if (this.sendUserId && rudderElement.message.userId) {
          var userId = this.analytics.userId || this.analytics.anonymousId;

          if (this.blockPageView) {
            window.gtag("config", this.measurementId, {
              user_id: userId,
              send_page_view: false
            });
          } else {
            window.gtag("config", this.measurementId, {
              user_id: userId
            });
          }
        }

        logger.debug("in GoogleAnalyticsManager identify");
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        var pageProps = rudderElement.message.properties;
        if (!pageProps) return;
        pageProps = flattenJsonPayload(pageProps);

        if (this.extendPageViewParams) {
          window.gtag("event", "page_view", _objectSpread2(_objectSpread2({}, pageProps), getPageViewProperty(pageProps)));
        } else {
          window.gtag("event", "page_view", getPageViewProperty(pageProps));
        }
      }
    }, {
      key: "group",
      value: function group(rudderElement) {
        var _this2 = this;

        var groupId = rudderElement.message.groupId;
        var traits = rudderElement.message.traits;
        getDestinationEventName(rudderElement.message.type).forEach(function (events) {
          _this2.sendGAEvent(events.dest, _objectSpread2({
            group_id: groupId
          }, _this2.extendGroupPayload ? traits : {}));
        });
      }
    }]);

    return GA4;
  }();

  var GoogleAds = /*#__PURE__*/function () {
    function GoogleAds(config) {
      _classCallCheck(this, GoogleAds);

      // this.accountId = config.accountId;//AW-696901813
      this.conversionId = config.conversionID;
      this.pageLoadConversions = config.pageLoadConversions;
      this.clickEventConversions = config.clickEventConversions;
      this.defaultPageConversion = config.defaultPageConversion;
      this.dynamicRemarketing = config.dynamicRemarketing;
      this.sendPageView = config.sendPageView || true;
      this.conversionLinker = config.conversionLinker || true;
      this.disableAdPersonalization = config.disableAdPersonalization || false;
      this.name = NAME$g;
    }

    _createClass(GoogleAds, [{
      key: "init",
      value: function init() {
        var sourceUrl = "https://www.googletagmanager.com/gtag/js?id=".concat(this.conversionId);

        (function (id, src, document) {
          logger.debug("in script loader=== ".concat(id));
          var js = document.createElement("script");
          js.src = src;
          js.async = 1;
          js.type = "text/javascript";
          js.id = id;
          var e = document.getElementsByTagName("head")[0];
          logger.debug("==script==", e);
          e.appendChild(js);
        })("googleAds-integration", sourceUrl, document);

        window.dataLayer = window.dataLayer || [];

        window.gtag = function () {
          window.dataLayer.push(arguments);
        };

        window.gtag("js", new Date()); // Additional Settings

        var config = {};
        config.send_page_view = this.sendPageView;
        config.conversion_linker = this.conversionLinker;

        if (this.disableAdPersonalization) {
          window.gtag("set", "allow_ad_personalization_signals", false);
        }

        window.gtag("config", this.conversionId, config);
        logger.debug("===in init Google Ads===");
      }
    }, {
      key: "identify",
      value: function identify() {
        logger.debug("[GoogleAds] identify:: method not supported");
      } // https://developers.google.com/gtagjs/reference/event

    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("in GoogleAdsAnalyticsManager track"); // Dynamic remarketing disabled

        if (!this.dynamicRemarketing) {
          var conversionData = this.getConversionData(this.clickEventConversions, rudderElement.message.event);

          if (conversionData.conversionLabel) {
            var conversionLabel = conversionData.conversionLabel;
            var eventName = conversionData.eventName;
            var sendToValue = "".concat(this.conversionId, "/").concat(conversionLabel);
            var properties = {};

            if (rudderElement.message.properties) {
              properties.value = rudderElement.message.properties.revenue;
              properties.currency = rudderElement.message.properties.currency;
              properties.transaction_id = rudderElement.message.properties.order_id;
            }

            properties.send_to = sendToValue;
            properties = removeUndefinedAndNullValues(properties);
            window.gtag("event", eventName, properties);
          }
        } else {
          var event = rudderElement.message.event;

          if (!event) {
            logger.error("Event name not present");
            return;
          }

          var payload = {};
          var _sendToValue = this.conversionId;

          if (rudderElement.message.properties) {
            payload = rudderElement.message.properties;
          }

          payload.send_to = _sendToValue;
          window.gtag("event", event, payload);
        }
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("in GoogleAdsAnalyticsManager page"); // Dynamic re-marketing is disabled

        if (!this.dynamicRemarketing) {
          var conversionData = this.getConversionData(this.pageLoadConversions, rudderElement.message.name);

          if (conversionData.conversionLabel) {
            var conversionLabel = conversionData.conversionLabel;
            var eventName = conversionData.eventName;
            window.gtag("event", eventName, {
              send_to: "".concat(this.conversionId, "/").concat(conversionLabel)
            });
          }
        } else {
          var event = rudderElement.message.name;

          if (!event) {
            logger.error("Event name not present");
            return;
          }

          var payload = {};
          var sendToValue = this.conversionId;

          if (rudderElement.message.properties) {
            payload = rudderElement.message.properties;
          }

          payload.send_to = sendToValue;
          window.gtag("event", event, payload);
        }
      }
    }, {
      key: "getConversionData",
      value: function getConversionData(eventTypeConversions, eventName) {
        var conversionData = {};

        if (eventTypeConversions) {
          if (eventName) {
            eventTypeConversions.forEach(function (eventTypeConversion) {
              if (eventTypeConversion.name.toLowerCase() === eventName.toLowerCase()) {
                // rudderElement["message"]["name"]
                conversionData.conversionLabel = eventTypeConversion.conversionLabel;
                conversionData.eventName = eventTypeConversion.name;
              }
            });
          } else if (this.defaultPageConversion) {
            conversionData.conversionLabel = this.defaultPageConversion;
            conversionData.eventName = "Viewed a Page";
          }
        }

        return conversionData;
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        return window.dataLayer.push !== Array.prototype.push;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return window.dataLayer.push !== Array.prototype.push;
      }
    }]);

    return GoogleAds;
  }();

  var index =  GoogleAds ;

  var GoogleTagManager = /*#__PURE__*/function () {
    function GoogleTagManager(config) {
      _classCallCheck(this, GoogleTagManager);

      this.containerID = config.containerID;
      this.name = NAME$i;
      this.serverUrl = config.serverUrl;
    }

    _createClass(GoogleTagManager, [{
      key: "init",
      value: function init() {
        logger.debug("===in init GoogleTagManager===");
        var defaultUrl = "https://www.googletagmanager.com"; // ref: https://developers.google.com/tag-platform/tag-manager/server-side/send-data#update_the_gtmjs_source_domain

        window.finalUrl = this.serverUrl ? this.serverUrl : defaultUrl;

        (function (w, d, s, l, i) {
          w[l] = w[l] || [];
          w[l].push({
            "gtm.start": new Date().getTime(),
            event: "gtm.js"
          });
          var f = d.getElementsByTagName(s)[0];
          var j = d.createElement(s);
          var dl = l !== "dataLayer" ? "&l=".concat(l) : "";
          j.async = true;
          j.src = "".concat(window.finalUrl, "/gtm.js?id=").concat(i).concat(dl);
          f.parentNode.insertBefore(j, f);
        })(window, document, "script", "dataLayer", this.containerID);
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        // set the traits to the datalayer and put everything under the key traits
        // keeping it under the traits key as destructing might conflict with `message.properties`
        var rudderMessage = rudderElement.message;
        var props = {
          traits: rudderMessage.context.traits
        };
        this.sendToGTMDatalayer(props);
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("===in track GoogleTagManager===");
        var rudderMessage = rudderElement.message;

        var props = _objectSpread2({
          event: rudderMessage.event,
          userId: rudderMessage.userId,
          anonymousId: rudderMessage.anonymousId,
          // set the traits as well if there is any
          // it'll be null/undefined before identify call is made
          traits: rudderMessage.context.traits
        }, rudderMessage.properties);

        this.sendToGTMDatalayer(props);
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("===in page GoogleTagManager===");
        var rudderMessage = rudderElement.message;
        var pageName = rudderMessage.name;
        var pageCategory = rudderMessage.properties ? rudderMessage.properties.category : undefined;
        var eventName;

        if (pageName) {
          eventName = "Viewed ".concat(pageName, " page");
        }

        if (pageCategory && pageName) {
          eventName = "Viewed ".concat(pageCategory, " ").concat(pageName, " page");
        }

        if (!eventName) {
          eventName = "Viewed a Page";
        }

        var props = _objectSpread2({
          event: eventName,
          userId: rudderMessage.userId,
          anonymousId: rudderMessage.anonymousId,
          // set the traits as well if there is any
          // it'll be null/undefined before identify call is made
          traits: rudderMessage.context.traits
        }, rudderMessage.properties);

        this.sendToGTMDatalayer(props);
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        return !!(window.dataLayer && Array.prototype.push !== window.dataLayer.push);
      }
    }, {
      key: "sendToGTMDatalayer",
      value: function sendToGTMDatalayer(props) {
        window.dataLayer.push(props);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return !!(window.dataLayer && Array.prototype.push !== window.dataLayer.push);
      }
    }]);

    return GoogleTagManager;
  }();

  var processHeapProperties = function processHeapProperties(propertiesJson) {
    // flatten the json
    var propertiesJsonFlattened = flattenJson(propertiesJson);
    var processedProperties = {};
    Object.keys(propertiesJsonFlattened).forEach(function (key) {
      var value = propertiesJsonFlattened[key];

      if (isDefinedAndNotNull$1(value)) {
        // check if date. Then convert to iso.
        if (is_1.date(value)) {
          processedProperties[key] = toIso(value);
        } else {
          processedProperties[key] = value;
        }
      }
    });
    return processedProperties;
  };

  var Heap = /*#__PURE__*/function () {
    function Heap(config) {
      _classCallCheck(this, Heap);

      this.appId = config.appId;
      this.name = NAME$j;
    }
    /**
     * Initialise Heap
     * DOC: https://developers.heap.io/docs/web
     */


    _createClass(Heap, [{
      key: "init",
      value: function init() {
        window.heap = window.heap || [], heap.load = function (e, t) {
          window.heap.appid = e, window.heap.config = t = t || {};
          var r = document.createElement("script");
          r.type = "text/javascript", r.async = !0, r.src = "https://cdn.heapanalytics.com/js/heap-" + e + ".js";
          var a = document.getElementsByTagName("script")[0];
          a.parentNode.insertBefore(r, a);

          for (var n = function n(e) {
            return function () {
              heap.push([e].concat(Array.prototype.slice.call(arguments, 0)));
            };
          }, p = ["addEventProperties", "addUserProperties", "clearEventProperties", "identify", "resetIdentity", "removeEventProperty", "setEventProperties", "track", "unsetEventProperty"], o = 0; o < p.length; o++) {
            heap[p[o]] = n(p[o]);
          }
        };
        window.heap.load(this.appId);
      }
      /**
       * Check if loaaded
       */

    }, {
      key: "isLoaded",
      value: function isLoaded() {
        return !!(window.heap && window.heap.appid);
      }
      /**
       * Check if Ready
       */

    }, {
      key: "isReady",
      value: function isReady() {
        return !!(window.heap && window.heap.appid);
      } // DOC: https://developers.heap.io/reference#identify

    }, {
      key: "identify",
      value: function identify(rudderElement) {
        var _rudderElement$messag = rudderElement.message,
            userId = _rudderElement$messag.userId,
            context = _rudderElement$messag.context;

        if (userId) {
          window.heap.identify(userId);
        }

        var traits = context.traits; // DOC: https://developers.heap.io/reference#adduserproperties

        window.heap.addUserProperties(processHeapProperties(traits));
      } // DOC: https://developers.heap.io/reference#track

    }, {
      key: "track",
      value: function track(rudderElement) {
        var _rudderElement$messag2 = rudderElement.message,
            event = _rudderElement$messag2.event,
            properties = _rudderElement$messag2.properties;
        window.heap.track(event, processHeapProperties(properties));
      }
    }]);

    return Heap;
  }();

  var Hotjar = /*#__PURE__*/function () {
    function Hotjar(config) {
      _classCallCheck(this, Hotjar);

      this.siteId = config.siteID;
      this.name = NAME$k;
      this._ready = false;
    }

    _createClass(Hotjar, [{
      key: "init",
      value: function init() {
        logger.debug("===In init Hotjar===");
        window.hotjarSiteId = this.siteId;

        (function (h, o, t, j, a, r) {
          h.hj = h.hj || function () {
            (h.hj.q = h.hj.q || []).push(arguments);
          };

          h._hjSettings = {
            hjid: h.hotjarSiteId,
            hjsv: 6
          };
          a = o.getElementsByTagName("head")[0];
          r = o.createElement("script");
          r.async = 1;
          r.src = t + h._hjSettings.hjid + j + h._hjSettings.hjsv;
          a.appendChild(r);
        })(window, document, "https://static.hotjar.com/c/hotjar-", ".js?sv=");

        this._ready = true;
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("===In Hotjar identify===");
        var userId = rudderElement.message.userId || rudderElement.message.anonymousId;

        if (!userId) {
          logger.debug("[Hotjar] identify:: user id is required");
          return;
        }

        var traits = rudderElement.message.context.traits;
        window.hj("identify", rudderElement.message.userId, traits);
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("===In Hotjar track===");
        var event = rudderElement.message.event;

        if (!event) {
          logger.error("Event name not present");
          return;
        } // event name must not exceed 750 characters and can only contain alphanumeric, underscores, and dashes.
        // Ref - https://help.hotjar.com/hc/en-us/articles/4405109971095#the-events-api-call


        window.hj("event", event.replace(/\s\s+/g, " ").substring(0, 750).replaceAll(" ", "_"));
      }
    }, {
      key: "page",
      value: function page() {
        logger.debug("===In Hotjar page===");
        logger.debug("[Hotjar] page:: method not supported");
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("===In isLoaded Hotjar===");
        return this._ready;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("===In isReady Hotjar===");
        return this._ready;
      }
    }]);

    return Hotjar;
  }();

  var index$1 =  Hotjar ;

  var HubSpot = /*#__PURE__*/function () {
    function HubSpot(config) {
      _classCallCheck(this, HubSpot);

      this.hubId = config.hubID; // 6405167

      this.name = NAME$l;
    }

    _createClass(HubSpot, [{
      key: "init",
      value: function init() {
        var hubspotJs = "https://js.hs-scripts.com/".concat(this.hubId, ".js");
        ScriptLoader("hubspot-integration", hubspotJs);
        logger.debug("===in init HS===");
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("in HubspotAnalyticsManager identify");
        var traits = rudderElement.message.context.traits;
        var traitsValue = {};

        for (var k in traits) {
          if (!!Object.getOwnPropertyDescriptor(traits, k) && traits[k]) {
            var hubspotkey = k; // k.startsWith("rl_") ? k.substring(3, k.length) : k;

            if (Object.prototype.toString.call(traits[k]) == "[object Date]") {
              traitsValue[hubspotkey] = traits[k].getTime();
            } else {
              traitsValue[hubspotkey] = traits[k];
            }
          }
        }
        /* if (traitsValue["address"]) {
          let address = traitsValue["address"];
          //traitsValue.delete(address)
          delete traitsValue["address"];
          for (let k in address) {
            if (!!Object.getOwnPropertyDescriptor(address, k) && address[k]) {
              let hubspotkey = k;//k.startsWith("rl_") ? k.substring(3, k.length) : k;
              hubspotkey = hubspotkey == "street" ? "address" : hubspotkey;
              traitsValue[hubspotkey] = address[k];
            }
          }
        } */


        var userProperties = rudderElement.message.context.user_properties;

        for (var _k in userProperties) {
          if (!!Object.getOwnPropertyDescriptor(userProperties, _k) && userProperties[_k]) {
            var _hubspotkey = _k; // k.startsWith("rl_") ? k.substring(3, k.length) : k;

            traitsValue[_hubspotkey] = userProperties[_k];
          }
        }

        logger.debug(traitsValue);

        if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== undefined) {
          var _hsq = window._hsq = window._hsq || [];

          _hsq.push(["identify", traitsValue]);
        }
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("in HubspotAnalyticsManager track");

        var _hsq = window._hsq = window._hsq || [];

        var eventValue = {};
        eventValue.id = rudderElement.message.event;

        if (rudderElement.message.properties && (rudderElement.message.properties.revenue || rudderElement.message.properties.value)) {
          eventValue.value = rudderElement.message.properties.revenue || rudderElement.message.properties.value;
        }

        _hsq.push(["trackEvent", eventValue]);
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("in HubspotAnalyticsManager page");

        var _hsq = window._hsq = window._hsq || []; // logger.debug("path: " + rudderElement.message.properties.path);
        // _hsq.push(["setPath", rudderElement.message.properties.path]);

        /* _hsq.push(["identify",{
            email: "testtrackpage@email.com"
        }]); */


        if (rudderElement.message.properties && rudderElement.message.properties.path) {
          _hsq.push(["setPath", rudderElement.message.properties.path]);
        }

        _hsq.push(["trackPageView"]);
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("in hubspot isLoaded");
        return !!(window._hsq && window._hsq.push !== Array.prototype.push);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return !!(window._hsq && window._hsq.push !== Array.prototype.push);
      }
    }]);

    return HubSpot;
  }();

  var index$2 =  HubSpot ;

  var INTERCOM = /*#__PURE__*/function () {
    function INTERCOM(config) {
      _classCallCheck(this, INTERCOM);

      this.name = NAME$m;
      this.API_KEY = config.apiKey;
      this.APP_ID = config.appId;
      this.MOBILE_APP_ID = config.mobileAppId;
      logger.debug("Config ", config);
    }

    _createClass(INTERCOM, [{
      key: "init",
      value: function init() {
        window.intercomSettings = {
          app_id: this.APP_ID
        };

        (function () {
          var w = window;
          var ic = w.Intercom;

          if (typeof ic === "function") {
            ic("reattach_activator");
            ic("update", w.intercomSettings);
          } else {
            var d = document;

            var i = function i() {
              i.c(arguments);
            };

            i.q = [];

            i.c = function (args) {
              i.q.push(args);
            };

            w.Intercom = i;

            var l = function l() {
              var s = d.createElement("script");
              s.type = "text/javascript";
              s.async = true;
              s.src = "https://widget.intercom.io/widget/".concat(window.intercomSettings.app_id);
              var x = d.getElementsByTagName("script")[0];
              x.parentNode.insertBefore(s, x);
            };

            if (document.readyState === "complete") {
              l();
              window.intercom_code = true;
            } else if (w.attachEvent) {
              w.attachEvent("onload", l);
              window.intercom_code = true;
            } else {
              w.addEventListener("load", l, false);
              window.intercom_code = true;
            }
          }
        })();
      }
    }, {
      key: "page",
      value: function page() {
        // Get new messages of the current user
        window.Intercom("update");
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        var rawPayload = {};
        var context = rudderElement.message.context;
        var identityVerificationProps = context.Intercom ? context.Intercom : null;

        if (identityVerificationProps != null) {
          // user hash
          var userHash = context.Intercom.user_hash ? context.Intercom.user_hash : null;

          if (userHash != null) {
            rawPayload.user_hash = userHash;
          } // hide default launcher


          var hideDefaultLauncher = context.Intercom.hideDefaultLauncher ? context.Intercom.hideDefaultLauncher : null;

          if (hideDefaultLauncher != null) {
            rawPayload.hide_default_launcher = hideDefaultLauncher;
          }
        } // populate name if firstname and lastname is populated
        // if name is not set


        var _context$traits = context.traits,
            firstName = _context$traits.firstName,
            lastName = _context$traits.lastName,
            name = _context$traits.name;

        if (!name && (firstName || lastName)) {
          context.traits.name = "".concat(firstName, " ").concat(lastName).trim();
        } // map rudderPayload to desired


        Object.keys(context.traits).forEach(function (field) {
          if (context.traits.hasOwnProperty(field)) {
            var value = context.traits[field];

            if (field === "company") {
              var companies = [];
              var company = {}; // special handling string

              if (typeof context.traits[field] === "string") {
                company.company_id = md5$1(context.traits[field]);
              }

              var companyFields = _typeof(context.traits[field]) === "object" && Object.keys(context.traits[field]) || [];
              companyFields.forEach(function (key) {
                if (companyFields.hasOwnProperty(key)) {
                  if (key != "id") {
                    company[key] = context.traits[field][key];
                  } else {
                    company.company_id = context.traits[field][key];
                  }
                }
              });

              if (_typeof(context.traits[field]) === "object" && !companyFields.includes("id")) {
                company.company_id = md5$1(company.name);
              }

              companies.push(company);
              rawPayload.companies = companies;
            } else {
              rawPayload[field] = context.traits[field];
            }

            switch (field) {
              case "createdAt":
                rawPayload.created_at = value;
                break;

              case "anonymousId":
                rawPayload.user_id = value;
                break;
            }
          }
        });
        rawPayload.user_id = rudderElement.message.userId;
        window.Intercom("update", rawPayload);
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        var rawPayload = {};
        var message = rudderElement.message;
        var properties = message.properties ? Object.keys(message.properties) : null;
        properties.forEach(function (property) {
          var value = message.properties[property];

          if (value && _typeof(value) !== "object" && !Array.isArray(value)) {
            rawPayload[property] = value;
          }
        });

        if (message.event) {
          rawPayload.event_name = message.event;
        }

        rawPayload.user_id = message.userId ? message.userId : message.anonymousId;
        rawPayload.created_at = Math.floor(new Date(message.originalTimestamp).getTime() / 1000);
        window.Intercom("trackEvent", rawPayload.event_name, rawPayload);
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        return !!window.intercom_code;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return !!window.intercom_code;
      }
    }]);

    return INTERCOM;
  }();

  var Keen = /*#__PURE__*/function () {
    function Keen(config) {
      _classCallCheck(this, Keen);

      this.projectID = config.projectID;
      this.writeKey = config.writeKey;
      this.ipAddon = config.ipAddon;
      this.uaAddon = config.uaAddon;
      this.urlAddon = config.urlAddon;
      this.referrerAddon = config.referrerAddon;
      this.client = null;
      this.name = NAME$n;
    }

    _createClass(Keen, [{
      key: "init",
      value: function init() {
        logger.debug("===in init Keen===");
        ScriptLoader("keen-integration", "https://cdn.jsdelivr.net/npm/keen-tracking@4");
        var check = setInterval(checkAndInitKeen.bind(this), 1000);

        function initKeen(object) {
          object.client = new window.KeenTracking({
            projectId: object.projectID,
            writeKey: object.writeKey
          });
          return object.client;
        }

        function checkAndInitKeen() {
          if (window.KeenTracking !== undefined && window.KeenTracking !== void 0) {
            this.client = initKeen(this);
            clearInterval(check);
          }
        }
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("in Keen identify");
        var traits = rudderElement.message.context.traits;
        var userId = rudderElement.message.userId ? rudderElement.message.userId : rudderElement.message.anonymousId;
        var properties = rudderElement.message.properties ? _extends(properties, rudderElement.message.properties) : {};
        properties.user = {
          userId: userId,
          traits: traits
        };
        properties = this.getAddOn(properties);
        this.client.extendEvents(properties);
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("in Keen track");
        var event = rudderElement.message.event;
        var properties = rudderElement.message.properties;
        properties = this.getAddOn(properties);
        this.client.recordEvent(event, properties);
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("in Keen page");
        var pageName = rudderElement.message.name;
        var pageCategory = rudderElement.message.properties ? rudderElement.message.properties.category : undefined;
        var name = "Loaded a Page";

        if (pageName) {
          name = "Viewed ".concat(pageName, " page");
        }

        if (pageCategory && pageName) {
          name = "Viewed ".concat(pageCategory, " ").concat(pageName, " page");
        }

        var properties = rudderElement.message.properties;
        properties = this.getAddOn(properties);
        this.client.recordEvent(name, properties);
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("in Keen isLoaded");
        return !!(this.client != null);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return !!(this.client != null);
      }
    }, {
      key: "getAddOn",
      value: function getAddOn(properties) {
        var addOns = [];

        if (this.ipAddon) {
          properties.ip_address = "${keen.ip}";
          addOns.push({
            name: "keen:ip_to_geo",
            input: {
              ip: "ip_address"
            },
            output: "ip_geo_info"
          });
        }

        if (this.uaAddon) {
          properties.user_agent = "${keen.user_agent}";
          addOns.push({
            name: "keen:ua_parser",
            input: {
              ua_string: "user_agent"
            },
            output: "parsed_user_agent"
          });
        }

        if (this.urlAddon) {
          properties.page_url = document.location.href;
          addOns.push({
            name: "keen:url_parser",
            input: {
              url: "page_url"
            },
            output: "parsed_page_url"
          });
        }

        if (this.referrerAddon) {
          properties.page_url = document.location.href;
          properties.referrer_url = document.referrer;
          addOns.push({
            name: "keen:referrer_parser",
            input: {
              referrer_url: "referrer_url",
              page_url: "page_url"
            },
            output: "referrer_info"
          });
        }

        properties.keen = {
          addons: addOns
        };
        return properties;
      }
    }]);

    return Keen;
  }();

  var has$4 = Object.prototype.hasOwnProperty;
  /**
   * Copy the properties of one or more `objects` onto a destination object. Input objects are iterated over
   * in left-to-right order, so duplicate properties on later objects will overwrite those from
   * erevious ones. Only enumerable and own properties of the input objects are copied onto the
   * resulting object.
   *
   * @name extend
   * @api public
   * @category Object
   * @param {Object} dest The destination object.
   * @param {...Object} sources The source objects.
   * @return {Object} `dest`, extended with the properties of all `sources`.
   * @example
   * var a = { a: 'a' };
   * var b = { b: 'b' };
   * var c = { c: 'c' };
   *
   * extend(a, b, c);
   * //=> { a: 'a', b: 'b', c: 'c' };
   */

  var extend = function extend(dest
  /*, sources */
  ) {
    var sources = Array.prototype.slice.call(arguments, 1);

    for (var i = 0; i < sources.length; i += 1) {
      for (var key in sources[i]) {
        if (has$4.call(sources[i], key)) {
          dest[key] = sources[i][key];
        }
      }
    }

    return dest;
  };
  /*
   * Exports.
   */


  var extend_1 = extend;

  var Kissmetrics = /*#__PURE__*/function () {
    function Kissmetrics(config) {
      _classCallCheck(this, Kissmetrics);

      this.apiKey = config.apiKey;
      this.prefixProperties = config.prefixProperties;
      this.name = NAME$o;
    }

    _createClass(Kissmetrics, [{
      key: "init",
      value: function init() {
        logger.debug("===in init Kissmetrics===");
        window._kmq = window._kmq || [];

        var _kmk = window._kmk || this.apiKey;

        function _kms(u) {
          setTimeout(function () {
            var d = document;
            var f = d.getElementsByTagName("script")[0];
            var s = d.createElement("script");
            s.type = "text/javascript";
            s.async = true;
            s.src = u;
            f.parentNode.insertBefore(s, f);
          }, 1);
        }

        _kms("//i.kissmetrics.com/i.js");

        _kms("//scripts.kissmetrics.com/".concat(_kmk, ".2.js"));

        if (this.isEnvMobile()) {
          window._kmq.push(["set", {
            "Mobile Session": "Yes"
          }]);
        }
      }
    }, {
      key: "isEnvMobile",
      value: function isEnvMobile() {
        return navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/BlackBerry/i) || navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/Opera Mini/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPhone|iPod/i);
      } // source : https://github.com/segment-integrations/analytics.js-integration-kissmetrics/blob/master/lib/index.js

    }, {
      key: "toUnixTimestamp",
      value: function toUnixTimestamp(date) {
        date = new Date(date);
        return Math.floor(date.getTime() / 1000);
      } // source : https://github.com/segment-integrations/analytics.js-integration-kissmetrics/blob/master/lib/index.js

    }, {
      key: "clean",
      value: function clean(obj) {
        var ret = {};

        for (var k in obj) {
          if (obj.hasOwnProperty(k)) {
            var value = obj[k];
            if (value === null || typeof value === "undefined") continue; // convert date to unix

            if (is_1.date(value)) {
              ret[k] = this.toUnixTimestamp(value);
              continue;
            } // leave boolean as is


            if (is_1.bool(value)) {
              ret[k] = value;
              continue;
            } // leave  numbers as is


            if (is_1.number(value)) {
              ret[k] = value;
              continue;
            } // convert non objects to strings


            logger.debug(value.toString());

            if (value.toString() !== "[object Object]") {
              ret[k] = value.toString();
              continue;
            } // json
            // must flatten including the name of the original trait/property


            var nestedObj = {};
            nestedObj[k] = value;
            var flattenedObj = this.flatten(nestedObj, {
              safe: true
            }); // stringify arrays inside nested object to be consistent with top level behavior of arrays

            for (var key in flattenedObj) {
              if (is_1.array(flattenedObj[key])) {
                flattenedObj[key] = flattenedObj[key].toString();
              }
            }

            ret = extend_1(ret, flattenedObj);
            delete ret[k];
          }
        }

        return ret;
      } // source : https://github.com/segment-integrations/analytics.js-integration-kissmetrics/blob/master/lib/index.js

    }, {
      key: "flatten",
      value: function flatten(target, opts) {
        opts = opts || {};
        var delimiter = opts.delimiter || ".";
        var _opts = opts,
            maxDepth = _opts.maxDepth;
        var currentDepth = 1;
        var output = {};

        function step(object, prev) {
          for (var key in object) {
            if (object.hasOwnProperty(key)) {
              var value = object[key];
              var isarray = opts.safe && is_1.array(value);
              var type = Object.prototype.toString.call(value);
              var isobject = type === "[object Object]" || type === "[object Array]";
              var arr = [];
              var newKey = prev ? prev + delimiter + key : key;

              if (!opts.maxDepth) {
                maxDepth = currentDepth + 1;
              }

              for (var keys in value) {
                if (value.hasOwnProperty(keys)) {
                  arr.push(keys);
                }
              }

              if (!isarray && isobject && arr.length && currentDepth < maxDepth) {
                ++currentDepth;
                return step(value, newKey);
              }

              output[newKey] = value;
            }
          }
        }

        step(target);
        return output;
      } //  source : https://github.com/segment-integrations/analytics.js-integration-kissmetrics/blob/master/lib/index.js

    }, {
      key: "prefix",
      value: function prefix(event, properties) {
        var prefixed = {};
        componentEach(properties, function (key, val) {
          if (key === "Billing Amount") {
            prefixed[key] = val;
          } else if (key === "revenue") {
            prefixed["".concat(event, " - ").concat(key)] = val;
            prefixed["Billing Amount"] = val;
          } else {
            prefixed["".concat(event, " - ").concat(key)] = val;
          }
        });
        return prefixed;
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("in Kissmetrics identify");
        var traits = this.clean(rudderElement.message.context.traits);
        var userId = rudderElement.message.userId && rudderElement.message.userId != "" ? rudderElement.message.userId : undefined;

        if (userId) {
          window._kmq.push(["identify", userId]);
        }

        if (traits) {
          window._kmq.push(["set", traits]);
        }
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("in Kissmetrics track");
        var event = rudderElement.message.event;
        var properties = JSON.parse(JSON.stringify(rudderElement.message.properties));
        var timestamp = this.toUnixTimestamp(new Date());
        var revenue = getRevenue(properties);

        if (revenue) {
          properties.revenue = revenue;
        }

        var _properties = properties,
            products = _properties.products;

        if (products) {
          delete properties.products;
        }

        properties = this.clean(properties);
        logger.debug(JSON.stringify(properties));

        if (this.prefixProperties) {
          properties = this.prefix(event, properties);
        }

        window._kmq.push(["record", event, properties]);

        var iterator = function pushItem(product, i) {
          var item = product;
          if (this.prefixProperties) item = this.prefix(event, item);
          item._t = timestamp + i;
          item._d = 1;
          window.KM.set(item);
        }.bind(this);

        if (products) {
          window._kmq.push(function () {
            componentEach(products, iterator);
          });
        }
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("in Kissmetrics page");
        var pageName = rudderElement.message.name;
        var pageCategory = rudderElement.message.properties ? rudderElement.message.properties.category : undefined;
        var name = "Loaded a Page";

        if (pageName) {
          name = "Viewed ".concat(pageName, " page");
        }

        if (pageCategory && pageName) {
          name = "Viewed ".concat(pageCategory, " ").concat(pageName, " page");
        }

        var properties = rudderElement.message.properties;

        if (this.prefixProperties) {
          properties = this.prefix("Page", properties);
        }

        window._kmq.push(["record", name, properties]);
      }
    }, {
      key: "alias",
      value: function alias(rudderElement) {
        var prev = rudderElement.message.previousId;
        var userId = rudderElement.message.userId;

        window._kmq.push(["alias", userId, prev]);
      }
    }, {
      key: "group",
      value: function group(rudderElement) {
        var groupId = rudderElement.message.groupId;
        var groupTraits = rudderElement.message.traits;
        groupTraits = this.prefix("Group", groupTraits);

        if (groupId) {
          groupTraits["Group - id"] = groupId;
        }

        window._kmq.push(["set", groupTraits]);

        logger.debug("in Kissmetrics group");
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        return is_1.object(window.KM);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return is_1.object(window.KM);
      }
    }]);

    return Kissmetrics;
  }();

  /* eslint-disable no-param-reassign */

  var itemsPayload = function itemsPayload(item) {
    var itemObj = {};
    itemObj.ProductID = item.product_id;
    itemObj.SKU = item.sku;
    itemObj.ProductName = item.name;
    itemObj.Quantity = item.quantity;
    itemObj.ItemPrice = item.price;
    itemObj.RowTotal = item.total;
    itemObj.ProductURL = item.url;
    itemObj.ImageURL = item.image_url;
    itemObj.ProductCategories = item.categories;
    return itemObj;
  };

  var ecommEventPayload = function ecommEventPayload(event, message) {
    var payload = {};

    switch (event) {
      case "Viewed Product":
        {
          payload.ProductName = getValue(message, "properties.name");
          payload.ProductID = getValue(message, "properties.product_id");
          payload.SKU = getValue(message, "properties.sku");
          payload.ImageURL = getValue(message, "properties.image_url");
          payload.URL = getValue(message, "properties.url");
          payload.Brand = getValue(message, "properties.brand");
          payload.Price = getValue(message, "properties.price");
          payload.CompareAtPrice = getValue(message, "properties.compare_at_price");
          payload.Categories = getValue(message, "properties.categories");
          break;
        }

      case "Added to Cart":
        {
          payload.$value = getValue(message, "properties.value");
          payload.AddedItemProductName = getValue(message, "properties.name");
          payload.AddedItemProductID = getValue(message, "properties.product_id");
          payload.AddedItemSKU = getValue(message, "properties.sku");
          payload.AddedItemImageURL = getValue(message, "properties.image_url");
          payload.AddedItemURL = getValue(message, "properties.url");
          payload.AddedItemPrice = getValue(message, "properties.price");
          payload.AddedItemQuantity = getValue(message, "properties.quantity");
          payload.AddedItemCategories = getValue(message, "properties.categories");
          payload.ItemNames = getValue(message, "properties.item_names");
          payload.CheckoutURL = getValue(message, "properties.checkout_url");

          if (message.properties.items && Array.isArray(message.properties.items)) {
            var itemArr = [];
            message.properties.items.forEach(function (element) {
              var item = itemsPayload(element);
              item = removeUndefinedAndNullValues(item);

              if (isNotEmpty(item)) {
                itemArr.push(item);
              }
            });
            payload.Items = itemArr;
          }

          break;
        }

      case "Started Checkout":
        {
          payload.$event_id = getValue(message, "properties.order_id");
          payload.$value = getValue(message, "properties.value");
          payload.Categories = getValue(message, "properties.categories");
          payload.CheckoutURL = getValue(message, "properties.checkout_url");
          payload.ItemNames = getValue(message, "item_names");

          if (message.properties.items && Array.isArray(message.properties.items)) {
            var _itemArr = [];
            message.properties.items.forEach(function (element) {
              var item = itemsPayload(element);
              item = removeUndefinedAndNullValues(item);

              if (isNotEmpty(item)) {
                _itemArr.push(item);
              }
            });
            payload.Items = _itemArr;
          }

          break;
        }
    }

    if (payload) {
      payload = removeUndefinedAndNullValues(payload);
    }

    return payload;
  };

  var Klaviyo = /*#__PURE__*/function () {
    function Klaviyo(config) {
      _classCallCheck(this, Klaviyo);

      this.publicApiKey = config.publicApiKey;
      this.sendPageAsTrack = config.sendPageAsTrack;
      this.additionalPageInfo = config.additionalPageInfo;
      this.enforceEmailAsPrimary = config.enforceEmailAsPrimary;
      this.name = NAME$p;
      this.keysToExtract = ["context.traits"];
      this.exclusionKeys = ["email", "E-mail", "Email", "firstName", "firstname", "first_name", "lastName", "lastname", "last_name", "phone", "Phone", "title", "organization", "city", "City", "region", "country", "Country", "zip", "image", "timezone", "anonymousId", "userId", "properties"];
      this.ecomExclusionKeys = ["name", "product_id", "sku", "image_url", "url", "brand", "price", "compare_at_price", "quantity", "categories", "products", "product_names", "order_id", "value", "checkout_url", "item_names", "items", "checkout_url"];
      this.ecomEvents = ["product viewed", "product clicked", "product added", "checkout started"];
      this.eventNameMapping = {
        "product viewed": "Viewed Product",
        "product clicked": "Viewed Product",
        "product added": "Added to Cart",
        "checkout started": "Started Checkout"
      };
    }

    _createClass(Klaviyo, [{
      key: "init",
      value: function init() {
        logger.debug("===in init Klaviyo===");
        ScriptLoader("klaviyo-integration", "https://static.klaviyo.com/onsite/js/klaviyo.js?company_id=".concat(this.publicApiKey));
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("===in isLoaded Klaviyo===");
        return !!(window._learnq && window._learnq.push !== Array.prototype.push);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("===in isReady Klaviyo===");
        return !!(window._learnq && window._learnq.push !== Array.prototype.push);
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        var message = rudderElement.message;

        if (!(message.context && message.context.traits)) {
          logger.error("user traits not present");
          return;
        }

        var _getDefinedTraits = getDefinedTraits(message),
            userId = _getDefinedTraits.userId,
            email = _getDefinedTraits.email,
            phone = _getDefinedTraits.phone,
            firstName = _getDefinedTraits.firstName,
            lastName = _getDefinedTraits.lastName,
            city = _getDefinedTraits.city,
            country = _getDefinedTraits.country;

        var payload = {
          $id: userId,
          $email: email,
          $phone_number: phone,
          $first_name: firstName,
          $last_name: lastName,
          $city: city,
          $country: country,
          $organization: getValue(message, "context.traits.organization"),
          $title: getValue(message, "context.traits.title"),
          $region: getValue(message, "context.traits.region"),
          $zip: getValue(message, "context.traits.zip")
        };

        if (!payload.$email && !payload.$phone_number && !payload.$id) {
          logger.error("user id, phone or email not present");
          return;
        }

        if (this.enforceEmailAsPrimary) {
          delete payload.$id;
          payload._id = userId;
        } // Extract other K-V property from traits about user custom properties


        try {
          payload = extractCustomFields(message, payload, this.keysToExtract, this.exclusionKeys);
        } catch (err) {
          logger.debug("Error occured at extractCustomFields ".concat(err));
        }

        window._learnq.push(["identify", payload]);
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        var message = rudderElement.message;

        if (message.properties) {
          // ecomm events
          var event = getValue(message, "event");
          event = event ? event.trim().toLowerCase() : event;

          if (this.ecomEvents.includes(event)) {
            var payload = ecommEventPayload(this.eventNameMapping[event], message);
            var eventName = this.eventNameMapping[event];
            var customProperties = {};
            customProperties = extractCustomFields(message, customProperties, ["properties"], this.ecomExclusionKeys);

            if (isNotEmpty(customProperties)) {
              payload = _objectSpread2(_objectSpread2({}, payload), customProperties);
            }

            if (isNotEmpty(payload)) {
              window._learnq.push(["track", eventName, payload]);
            }
          } else {
            var propsPayload = message.properties;

            if (propsPayload.revenue) {
              propsPayload.$value = propsPayload.revenue;
              delete propsPayload.revenue;
            }

            window._learnq.push(["track", message.event, propsPayload]);
          }
        } else window._learnq.push(["track", message.event]);
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        var message = rudderElement.message;

        if (this.sendPageAsTrack) {
          var eventName;

          if (message.properties && message.properties.category && message.name) {
            eventName = "Viewed ".concat(message.properties.category, " ").concat(message.name, " page");
          } else if (message.name) {
            eventName = "Viewed ".concat(message.name, " page");
          } else {
            eventName = "Viewed a Page";
          }

          if (this.additionalPageInfo && message.properties) {
            window._learnq.push(["track", "".concat(eventName), message.properties]);
          } else {
            window._learnq.push(["track", "".concat(eventName)]);
          }
        } else {
          window._learnq.push(["track"]);
        }
      }
    }]);

    return Klaviyo;
  }();

  var LinkedInInsightTag = /*#__PURE__*/function () {
    function LinkedInInsightTag(config) {
      _classCallCheck(this, LinkedInInsightTag);

      this.name = NAME$r;
      this.partnerId = config.partnerId;
    }

    _createClass(LinkedInInsightTag, [{
      key: "init",
      value: function init() {
        logger.debug("===in init LinkedIn Insight Tag===");
        ScriptLoader("LinkedIn Insight Tag", "https://snap.licdn.com/li.lms-analytics/insight.min.js");

        if (!this.partnerId) {
          return;
        }

        window._linkedin_data_partner_id = this.partnerId;
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("=== in isLoaded LinkedIn Insight Tag===");
        return !!window._linkedin_data_partner_id;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("=== in isReady LinkedIn Insight Tag===");
        return !!window._linkedin_data_partner_id;
      }
    }]);

    return LinkedInInsightTag;
  }();

  var defaults$2 = {
    lotame_synch_time_key: "lt_synch_timestamp"
  };

  var LotameStorage = /*#__PURE__*/function () {
    function LotameStorage() {
      _classCallCheck(this, LotameStorage);

      this.storage = Storage$1; // new Storage();
    }

    _createClass(LotameStorage, [{
      key: "setLotameSynchTime",
      value: function setLotameSynchTime(value) {
        this.storage.setItem(defaults$2.lotame_synch_time_key, value);
      }
    }, {
      key: "getLotameSynchTime",
      value: function getLotameSynchTime() {
        return this.storage.getItem(defaults$2.lotame_synch_time_key);
      }
    }]);

    return LotameStorage;
  }();

  var lotameStorage = new LotameStorage();

  var Lotame = /*#__PURE__*/function () {
    function Lotame(config, analytics) {
      var _this = this;

      _classCallCheck(this, Lotame);

      this.name = NAME$s;
      this.analytics = analytics;
      this.storage = lotameStorage;
      this.bcpUrlSettingsPixel = config.bcpUrlSettingsPixel;
      this.bcpUrlSettingsIframe = config.bcpUrlSettingsIframe;
      this.dspUrlSettingsPixel = config.dspUrlSettingsPixel;
      this.dspUrlSettingsIframe = config.dspUrlSettingsIframe;
      this.mappings = {};
      config.mappings.forEach(function (mapping) {
        var key = mapping.key;
        var value = mapping.value;
        _this.mappings[key] = value;
      });
    }

    _createClass(Lotame, [{
      key: "init",
      value: function init() {
        logger.debug("===in init Lotame===");

        window.LOTAME_SYNCH_CALLBACK = function () {};
      }
    }, {
      key: "addPixel",
      value: function addPixel(source, width, height) {
        logger.debug("Adding pixel for :: ".concat(source));
        var image = document.createElement("img");
        image.src = source;
        image.setAttribute("width", width);
        image.setAttribute("height", height);
        logger.debug("Image Pixel :: ".concat(image));
        document.getElementsByTagName("body")[0].appendChild(image);
      }
    }, {
      key: "addIFrame",
      value: function addIFrame(source) {
        logger.debug("Adding iframe for :: ".concat(source));
        var iframe = document.createElement("iframe");
        iframe.src = source;
        iframe.title = "empty";
        iframe.setAttribute("id", "LOTCCFrame");
        iframe.setAttribute("tabindex", "-1");
        iframe.setAttribute("role", "presentation");
        iframe.setAttribute("aria-hidden", "true");
        iframe.setAttribute("style", "border: 0px; width: 0px; height: 0px; display: block;");
        logger.debug("IFrame :: ".concat(iframe));
        document.getElementsByTagName("body")[0].appendChild(iframe);
      }
    }, {
      key: "syncPixel",
      value: function syncPixel(userId) {
        var _this2 = this;

        logger.debug("===== in syncPixel ======");
        logger.debug("Firing DSP Pixel URLs");

        if (this.dspUrlSettingsPixel && this.dspUrlSettingsPixel.length > 0) {
          var currentTime = Date.now();
          this.dspUrlSettingsPixel.forEach(function (urlSettings) {
            var dspUrl = _this2.compileUrl(_objectSpread2(_objectSpread2({}, _this2.mappings), {}, {
              userId: userId,
              random: currentTime
            }), urlSettings.dspUrlTemplate);

            _this2.addPixel(dspUrl, "1", "1");
          });
        }

        logger.debug("Firing DSP IFrame URLs");

        if (this.dspUrlSettingsIframe && this.dspUrlSettingsIframe.length > 0) {
          var _currentTime = Date.now();

          this.dspUrlSettingsIframe.forEach(function (urlSettings) {
            var dspUrl = _this2.compileUrl(_objectSpread2(_objectSpread2({}, _this2.mappings), {}, {
              userId: userId,
              random: _currentTime
            }), urlSettings.dspUrlTemplate);

            _this2.addIFrame(dspUrl);
          });
        }

        this.storage.setLotameSynchTime(Date.now()); // emit on syncPixel

        if (this.analytics.methodToCallbackMapping.syncPixel) {
          this.analytics.emit("syncPixel", {
            destination: this.name
          });
        }
      }
    }, {
      key: "compileUrl",
      value: function compileUrl(map, url) {
        Object.keys(map).forEach(function (key) {
          if (map.hasOwnProperty(key)) {
            var replaceKey = "{{".concat(key, "}}");
            var regex = new RegExp(replaceKey, "gi");
            url = url.replace(regex, map[key]);
          }
        });
        return url;
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("in Lotame identify");
        var userId = rudderElement.message.userId;
        this.syncPixel(userId);
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("track not supported for lotame");
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        var _this3 = this;

        logger.debug("in Lotame page");
        logger.debug("Firing BCP Pixel URLs");

        if (this.bcpUrlSettingsPixel && this.bcpUrlSettingsPixel.length > 0) {
          var currentTime = Date.now();
          this.bcpUrlSettingsPixel.forEach(function (urlSettings) {
            var bcpUrl = _this3.compileUrl(_objectSpread2(_objectSpread2({}, _this3.mappings), {}, {
              random: currentTime
            }), urlSettings.bcpUrlTemplate);

            _this3.addPixel(bcpUrl, "1", "1");
          });
        }

        logger.debug("Firing BCP IFrame URLs");

        if (this.bcpUrlSettingsIframe && this.bcpUrlSettingsIframe.length > 0) {
          var _currentTime2 = Date.now();

          this.bcpUrlSettingsIframe.forEach(function (urlSettings) {
            var bcpUrl = _this3.compileUrl(_objectSpread2(_objectSpread2({}, _this3.mappings), {}, {
              random: _currentTime2
            }), urlSettings.bcpUrlTemplate);

            _this3.addIFrame(bcpUrl);
          });
        }

        if (rudderElement.message.userId && this.isPixelToBeSynched()) {
          this.syncPixel(rudderElement.message.userId);
        }
      }
    }, {
      key: "isPixelToBeSynched",
      value: function isPixelToBeSynched() {
        var lastSynchedTime = this.storage.getLotameSynchTime();
        var currentTime = Date.now();

        if (!lastSynchedTime) {
          return true;
        }

        var difference = Math.floor((currentTime - lastSynchedTime) / (1000 * 3600 * 24));
        return difference >= 7;
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("in Lotame isLoaded");
        return true;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return true;
      }
    }]);

    return Lotame;
  }();

  var Lytics = /*#__PURE__*/function () {
    function Lytics(config) {
      _classCallCheck(this, Lytics);

      this.accountId = config.accountId;
      this.stream = config.stream;
      this.blockload = config.blockload;
      this.loadid = config.loadid;
      this.name = NAME$t;
      this.forFirstName = ["firstname", "firstName"];
      this.forLastName = ["lastname", "lastName"];
    }

    _createClass(Lytics, [{
      key: "loadLyticsScript",
      value: function loadLyticsScript() {
        (function () {

          var o = window.jstag || (window.jstag = {}),
              r = [];

          function n(e) {
            o[e] = function () {
              for (var n = arguments.length, t = new Array(n), i = 0; i < n; i++) {
                t[i] = arguments[i];
              }

              r.push([e, t]);
            };
          }

          n("send"), n("mock"), n("identify"), n("pageView"), n("unblock"), n("getid"), n("setid"), n("loadEntity"), n("getEntity"), n("on"), n("once"), n("call"), o.loadScript = function (n, t, i) {
            var e = document.createElement("script");
            e.async = !0, e.src = n, e.onload = t, e.onerror = i;
            var o = document.getElementsByTagName("script")[0],
                r = o && o.parentNode || document.head || document.body,
                c = o || r.lastChild;
            return null != c ? r.insertBefore(e, c) : r.appendChild(e), this;
          }, o.init = function n(t) {
            return this.config = t, this.loadScript(t.src, function () {
              if (o.init === n) throw new Error("Load error!"); // eslint-disable-next-line no-unused-expressions

              o.init(o.config), // eslint-disable-next-line func-names
              function () {
                for (var n = 0; n < r.length; n++) {
                  var t = r[n][0],
                      i = r[n][1];
                  o[t].apply(o, i);
                }

                r = void 0;
              }();
            }), this;
          };
        })(); // Define config and initialize Lytics tracking tag.


        window.jstag.init({
          loadid: this.loadid,
          blocked: this.blockload,
          stream: this.stream,
          sessecs: 1800,
          src: document.location.protocol === "https:" ? "https://c.lytics.io/api/tag/".concat(this.accountId, "/latest.min.js") : "http://c.lytics.io/api/tag/".concat(this.accountId, "/latest.min.js"),
          pageAnalysis: {
            dataLayerPull: {
              disabled: true
            }
          }
        });
      }
    }, {
      key: "init",
      value: function init() {
        this.loadLyticsScript();
        logger.debug("===in init Lytics===");
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("in Lytics isLoaded");
        logger.debug(!!(window.jstag && window.jstag.push !== Array.prototype.push));
        return !!(window.jstag && window.jstag.push !== Array.prototype.push);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("in Lytics isReady");
        return !!(window.jstag && window.jstag.push !== Array.prototype.push);
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("in Lytics identify"); // eslint-disable-next-line camelcase

        var user_id = rudderElement.message.userId || rudderElement.message.anonymousId;
        var traits = rudderElement.message.context.traits;

        var payload = _objectSpread2({
          user_id: user_id
        }, traits);

        this.handleName(payload);
        window.jstag.send(this.stream, payload);
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("in Lytics page");
        var properties = rudderElement.message.properties;

        var payload = _objectSpread2({
          event: rudderElement.message.name
        }, properties);

        this.handleName(payload);
        window.jstag.pageView(this.stream, payload);
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("in Lytics track");
        var properties = rudderElement.message.properties;

        var payload = _objectSpread2({
          _e: rudderElement.message.event
        }, properties);

        this.handleName(payload);
        window.jstag.send(this.stream, payload);
      }
    }, {
      key: "handleName",
      value: function handleName(payload) {
        this.forFirstName.forEach(function (key) {
          if (payload[key]) {
            payload.first_name = payload[key];
            delete payload[key];
          }
        });
        this.forLastName.forEach(function (key) {
          if (payload[key]) {
            payload.last_name = payload[key];
            delete payload[key];
          }
        });
        return payload;
      }
    }]);

    return Lytics;
  }();

  var keysToExtract = ["context.traits"];
  var exclusionKeys = ["email", "E-mail", "Email", "phone", "Phone", "name", "Name", "lastName", "lastname", "last_name", "firstName", "firstname", "first_name"];
  var traitAliases = {
    created: "$created",
    email: "$email",
    firstName: "$first_name",
    lastName: "$last_name",
    lastSeen: "$last_seen",
    name: "$name",
    username: "$username",
    phone: "$phone"
  };

  var formatTraits = function formatTraits(message) {
    var _getDefinedTraits = getDefinedTraits(message),
        email = _getDefinedTraits.email,
        firstName = _getDefinedTraits.firstName,
        lastName = _getDefinedTraits.lastName,
        phone = _getDefinedTraits.phone,
        name = _getDefinedTraits.name;

    var outgoingTraits = {
      email: email,
      firstName: firstName,
      lastName: lastName,
      phone: phone,
      name: name
    }; // Extract other K-V property from traits about user custom properties

    try {
      outgoingTraits = extractCustomFields(message, outgoingTraits, keysToExtract, exclusionKeys);
    } catch (err) {
      logger.debug("Error occured at extractCustomFields ".concat(err));
    }

    return outgoingTraits;
  };

  var parseConfigArray = function parseConfigArray(arr, key) {
    if (!arr) {
      logger.debug("===Mixpanel: arr is undefined or null===");
      return;
    } // eslint-disable-next-line consistent-return


    return arr.map(function (item) {
      return item[key];
    });
  };
  /**
   * Since Mixpanel doesn't support lists of objects, invert each list of objects to a set of lists of object properties.
   * Treats list transformation atomically, e.g. will only transform if EVERY item in list is an object
   *
   * @api private
   * @param {Object} props
   * @example
   * input: {products: [{sku: 32, revenue: 99}, {sku:2, revenue: 103}]}
   * output: {products_skus: [32, 2], products_revenues: [99, 103]}
   */


  var inverseObjectArrays = function inverseObjectArrays(input) {
    var response = input;
    Object.keys(input).forEach(function (key) {
      var markToDelete = false;

      if (Array.isArray(input[key])) {
        // [{sku: 32, revenue: 99}, {sku:2, revenue: 103}]
        var tempArray = input[key];
        tempArray.forEach(function (obj) {
          // operate if object encountered in array
          if (_typeof(obj) === "object") {
            // {sku: 32, revenue: 99}
            Object.entries(obj).forEach(function (k) {
              var attrKey = "".concat(key, "_").concat(k[0], "s");
              if (attrKey in response) response[attrKey].push(k[1]);else response[attrKey] = [k[1]];
            });
            markToDelete = true;
          }
        });
        if (markToDelete) delete response[key];
      }
    });
    return response;
  };

  var extractTraits = function extractTraits(traits, traitAliasesParam) {
    for (var _i = 0, _Object$entries = Object.entries(traitAliasesParam); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      traits[value] = traits[key];
      delete traits[key];
    }

    return traits;
  };
  /**
   * Return union of two arrays
   *
   * @param {Array} x
   * @param {Array} y
   * @return {Array} res
   */


  var unionArrays = function unionArrays(x, y) {
    var res = new Set(); // store items of each array as set entries to avoid duplicates

    x.forEach(function (value) {
      res.add(value);
    });
    y.forEach(function (value) {
      res.add(value);
    });
    return _toConsumableArray(res);
  };
  /**
   * extend Mixpanel's special trait keys in the given `arr`.
   * @param {Array} arr
   * @return {Array}
   */


  var extendTraits = function extendTraits(arr) {
    var keys = [];
    Object.keys(traitAliases).forEach(function (key) {
      keys.push(key);
    });
    keys.forEach(function (key) {
      if (arr.indexOf(key) < 0) {
        arr.push(key);
      }
    });
    return arr;
  };
  /**
   * Map Special traits in the given `arr`.
   * From the TraitAliases for Mixpanel's special props
   *
   * @param {Array} arr
   * @return {Array}
   */


  var mapTraits = function mapTraits(arr) {
    var ret = new Array(arr.length);
    arr.forEach(function (key) {
      if (traitAliases.hasOwnProperty(key)) {
        ret.push(traitAliases[key]);
      } else {
        ret.push(key);
      }
    });
    return ret;
  };

  var Mixpanel = /*#__PURE__*/function () {
    function Mixpanel(config) {
      _classCallCheck(this, Mixpanel);

      this.name = NAME$u;
      this.accountId = config.accountId;
      this.token = config.token;
      this.people = config.people || false;
      this.dataResidency = config.dataResidency || "us";
      this.setAllTraitsByDefault = config.setAllTraitsByDefault || false;
      this.superProperties = config.superProperties || [];
      this.eventIncrements = config.eventIncrements || [];
      this.propIncrements = config.propIncrements || [];
      this.sourceName = config.sourceName;
      this.consolidatedPageCalls = config.consolidatedPageCalls || true;
      this.trackCategorizedPages = config.trackCategorizedPages || false;
      this.trackNamedPages = config.trackNamedPages || false;
      this.groupKeySettings = config.groupKeySettings || [];
      this.peopleProperties = config.peopleProperties || [];
      this.crossSubdomainCookie = config.crossSubdomainCookie || false;
      this.secureCookie = config.secureCookie || false;
      this.persistence = config.persistence || "none";
      this.traitAliases = {
        created: "$created",
        email: "$email",
        firstName: "$first_name",
        lastName: "$last_name",
        lastSeen: "$last_seen",
        name: "$name",
        username: "$username",
        phone: "$phone"
      };
    }

    _createClass(Mixpanel, [{
      key: "init",
      value: function init() {
        logger.debug("===in init Mixpanel==="); // eslint-disable-next-line no-var

        (function (f, b) {
          if (!b.__SV) {
            var e, g, i, h;
            window.mixpanel = b;
            b._i = [];

            b.init = function (e, f, c) {
              function g(a, d) {
                var b = d.split(".");
                2 == b.length && (a = a[b[0]], d = b[1]);

                a[d] = function () {
                  a.push([d].concat(Array.prototype.slice.call(arguments, 0)));
                };
              }

              var a = b;
              "undefined" !== typeof c ? a = b[c] = [] : c = "mixpanel";
              a.people = a.people || [];

              a.toString = function (a) {
                var d = "mixpanel";
                "mixpanel" !== c && (d += "." + c);
                a || (d += " (stub)");
                return d;
              };

              a.people.toString = function () {
                return a.toString(1) + ".people (stub)";
              };

              i = "disable time_event track track_pageview track_links track_forms track_with_groups add_group set_group remove_group register register_once alias unregister identify name_tag set_config reset opt_in_tracking opt_out_tracking has_opted_in_tracking has_opted_out_tracking clear_opt_in_out_tracking start_batch_senders people.set people.set_once people.unset people.increment people.append people.union people.track_charge people.clear_charges people.delete_user people.remove".split(" ");

              for (h = 0; h < i.length; h++) {
                g(a, i[h]);
              }

              var j = "set set_once union unset remove delete".split(" ");

              a.get_group = function () {
                function b(c) {
                  d[c] = function () {
                    call2_args = arguments;
                    call2 = [c].concat(Array.prototype.slice.call(call2_args, 0));
                    a.push([e, call2]);
                  };
                }

                for (var d = {}, e = ["get_group"].concat(Array.prototype.slice.call(arguments, 0)), c = 0; c < j.length; c++) {
                  b(j[c]);
                }

                return d;
              };

              b._i.push([e, f, c]);
            };

            b.__SV = 1.2;
            e = f.createElement("script");
            e.type = "text/javascript";
            e.async = !0;
            e.src = "undefined" !== typeof MIXPANEL_CUSTOM_LIB_URL ? MIXPANEL_CUSTOM_LIB_URL : "file:" === f.location.protocol && "//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//) ? "https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js" : "//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";
            g = f.getElementsByTagName("script")[0];
            g.parentNode.insertBefore(e, g);
          }
        })(document, window.mixpanel || []);

        var options = {
          cross_subdomain_cookie: this.crossSubdomainCookie || false,
          secure_cookie: this.secureCookie || false
        };

        if (this.persistence !== "none") {
          options.persistence_name = this.persistence;
        }

        if (this.dataResidency == "eu") {
          // https://developer.mixpanel.com/docs/implement-mixpanel#section-implementing-mixpanel-in-the-european-union-eu
          options.api_host = "https://api-eu.mixpanel.com";
        }

        window.mixpanel.init(this.token, options);
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("in Mixpanel isLoaded");
        logger.debug(!!(window.mixpanel && window.mixpanel.config));
        window.mixpanel.register({
          mp_lib: "Rudderstack: web"
        });
        return !!(window.mixpanel && window.mixpanel.config);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("in Mixpanel isReady");
        return !!(window.mixpanel && window.mixpanel.config);
      }
      /**
       * Identify
       * @param {*} rudderElement
       */

    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("in Mixpanel identify");
        var peopleProperties = parseConfigArray(this.peopleProperties, "property");
        peopleProperties = extendTraits(peopleProperties);
        var superProperties = parseConfigArray(this.superProperties, "property"); // eslint-disable-next-line camelcase

        var user_id = rudderElement.message.userId || rudderElement.message.anonymousId;
        var traits = formatTraits(rudderElement.message);
        var _traits = traits,
            email = _traits.email,
            username = _traits.username; // id

        if (user_id) window.mixpanel.identify(user_id); // name tag

        var nametag = email || username;
        if (nametag) window.mixpanel.name_tag(nametag);
        traits = extractTraits(traits, this.traitAliases);
        traits = removeUndefinedAndNullValues(traits); // determine which traits to union to existing properties and which to set as new properties

        var traitsToUnion = {};
        var traitsToSet = {};

        for (var key in traits) {
          if (!traits.hasOwnProperty(key)) continue;
          var trait = traits[key];

          if (Array.isArray(trait) && trait.length > 0) {
            traitsToUnion[key] = trait; // since mixpanel doesn't offer a union method for super properties we have to do it manually by retrieving the existing list super property
            // from mixpanel and manually unioning to it ourselves

            var existingTrait = window.mixpanel.get_property(key);

            if (existingTrait && Array.isArray(existingTrait)) {
              traits[key] = unionArrays(existingTrait, trait);
            }
          } else {
            traitsToSet[key] = trait;
          }
        }

        if (this.setAllTraitsByDefault) {
          window.mixpanel.register(traits);

          if (this.people) {
            window.mixpanel.people.set(traitsToSet);
            window.mixpanel.people.union(traitsToUnion);
          }
        } else {
          // explicitly set select traits as people and super properties
          var mappedSuperProps = mapTraits(superProperties);
          var superProps = pick(traits, mappedSuperProps || []);
          if (isNotEmpty(superProps)) window.mixpanel.register(superProps);

          if (this.people) {
            var mappedPeopleProps = mapTraits(peopleProperties);
            var peoplePropsToSet = pick(traitsToSet, mappedPeopleProps || []);
            var peoplePropsToUnion = pick(traitsToUnion, mappedPeopleProps || []);
            if (isNotEmpty(peoplePropsToSet)) window.mixpanel.people.set(peoplePropsToSet);
            if (isNotEmpty(peoplePropsToUnion)) window.mixpanel.people.union(peoplePropsToUnion);
          }
        }
      }
      /**
       * Page
       * @param {*} rudderElement
       */

    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("in Mixpanel page");
        var _rudderElement$messag = rudderElement.message,
            name = _rudderElement$messag.name,
            properties = _rudderElement$messag.properties;
        var category = properties.category; // consolidated Page Calls

        if (this.consolidatedPageCalls) {
          window.mixpanel.track("Loaded a Page", properties);
          return;
        } // categorized pages


        if (this.trackCategorizedPages && category) {
          // If this option is checked and name was also passed, used the full name which includes both category & name
          if (name) {
            window.mixpanel.track("Viewed ".concat(category, " ").concat(name, " Page"), properties);
            return;
          }

          window.mixpanel.track("Viewed ".concat(category, " Page "), properties);
          return;
        } // named pages


        if (name && this.trackNamedPages) {
          window.mixpanel.track("Viewed ".concat(name, " Page"), properties);
        }
      }
      /**
       * Track
       * https://mixpanel.com/help/reference/javascript#sending-events
       * https://mixpanel.com/help/reference/javascript#tracking-revenue
       * @param {*} rudderElement
       */

    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("in Mixpanel track");
        var message = rudderElement.message;
        var eventIncrements = parseConfigArray(this.eventIncrements, "property");
        var propIncrements = parseConfigArray(this.propIncrements, "property");
        var event = getValue(message, "event");
        var revenue = getValue(message, "properties.revenue") || getValue(message, "properties.total");
        var sourceName = this.sourceName;
        var props = getValue(message, "properties");

        if (isNotEmpty(props)) {
          props = inverseObjectArrays(props);
        }

        if (sourceName) {
          props = _objectSpread2({}, props);
          props.rudderstack_source_name = sourceName;
        } // delete mixpanel's reserved prosperties, so they don't conflict


        delete props.distinct_id;
        delete props.ip;
        delete props.mp_name_tag;
        delete props.mp_note;
        delete props.token; // Mixpanel People operations

        if (this.people) {
          // increment event count, check if the current event exists in eventIncrements
          if (eventIncrements.indexOf(event) !== -1) {
            window.mixpanel.people.increment(event);
            window.mixpanel.people.set("Last " + event, new Date());
          } // increment property counts
          // eslint-disable-next-line guard-for-in


          for (var key in props) {
            var prop = props[key];

            if (prop && propIncrements.indexOf(key) != -1) {
              window.mixpanel.people.increment(key, prop);
            }
          } // track revenue


          if (revenue) {
            window.mixpanel.people.track_charge(revenue);
          }
        } // track the event


        var query;

        if (props.link_query) {
          // DOM query
          query = props.link_query;
          delete props.link_query;
          window.mixpanel.track_links(query, event, props);
        } else if (props.form_query) {
          // DOM query
          query = props.form_query;
          delete props.form_query;
          window.mixpanel.track_forms(query, event, props);
        } else {
          window.mixpanel.track(event, props);
        }
      }
      /**
       * @param {*} rudderElement
       */

    }, {
      key: "group",
      value: function group(rudderElement) {
        logger.debug("in Mixpanel group");
        var _rudderElement$messag2 = rudderElement.message,
            userId = _rudderElement$messag2.userId,
            groupId = _rudderElement$messag2.groupId,
            traits = _rudderElement$messag2.traits;

        if (!userId) {
          logger.debug("===Mixpanel: valid userId is required for group===");
          return;
        }

        if (!groupId) {
          logger.debug("===Mixpanel: valid groupId is required for group===");
          return;
        }

        if (!this.groupKeySettings || this.groupKeySettings.length === 0) {
          logger.debug("===Mixpanel: groupIdentifierTraits is required for group===");
          return;
        }
        /**
         * groupIdentifierTraits: [ {trait: "<trait_value>"}, ... ]
         */


        var identifierTraitsList = parseConfigArray(this.groupKeySettings, "groupKey");

        if (traits && Object.keys(traits).length) {
          identifierTraitsList.forEach(function (trait) {
            window.mixpanel.get_group(trait, groupId).set_once(traits);
          });
        }

        identifierTraitsList.forEach(function (trait) {
          return window.mixpanel.set_group(trait, [groupId]);
        });
      }
      /**
       * @param {*} rudderElement
       */

    }, {
      key: "alias",
      value: function alias(rudderElement) {
        logger.debug("in Mixpanel alias");
        var _rudderElement$messag3 = rudderElement.message,
            previousId = _rudderElement$messag3.previousId,
            userId = _rudderElement$messag3.userId;

        if (!previousId) {
          logger.debug("===Mixpanel: previousId is required for alias call===");
          return;
        }

        if (!userId) {
          logger.debug("===Mixpanel: userId is required for alias call===");
          return;
        }

        if (window.mixpanel.get_distinct_id && window.mixpanel.get_distinct_id() === userId) {
          logger.debug("===Mixpanel: userId is same as previousId. Skipping alias ===");
          return;
        }

        window.mixpanel.alias(userId, previousId);
      }
    }]);

    return Mixpanel;
  }();

  var traitsMap = {
    firstName: "first_name",
    lastName: "last_name",
    firstname: "first_name",
    lastname: "last_name",
    email: "email",
    phone: "mobile",
    name: "user_name",
    username: "user_name",
    userName: "user_name",
    gender: "gender",
    birthday: "birthday",
    id: null
  };

  var MoEngage = /*#__PURE__*/function () {
    function MoEngage(config, analyticsinstance) {
      _classCallCheck(this, MoEngage);

      this.isLoaded = function () {
        logger.debug("in MoEngage isLoaded");
        return !!window.moeBannerText;
      };

      this.isReady = function () {
        logger.debug("in MoEngage isReady");
        return !!window.moeBannerText;
      };

      this.apiId = config.apiId;
      this.debug = config.debug;
      this.region = config.region;
      this.name = NAME$v;
      this.analyticsinstance = analyticsinstance;
    }

    _createClass(MoEngage, [{
      key: "init",
      value: function init() {
        var self = this;
        logger.debug("===in init MoEnagage==="); // loading the script for moengage web sdk

        /* eslint-disable */

        (function (i, s, o, g, r, a, m, n) {
          i.moengage_object = r;
          var t = {};

          var q = function q(f) {
            return function () {
              (i.moengage_q = i.moengage_q || []).push({
                f: f,
                a: arguments
              });
            };
          };

          var f = ["track_event", "add_user_attribute", "add_first_name", "add_last_name", "add_email", "add_mobile", "add_user_name", "add_gender", "add_birthday", "destroy_session", "add_unique_user_id", "moe_events", "call_web_push", "track", "location_type_attribute"];
          var h = {
            onsite: ["getData", "registerCallback"]
          };

          for (var k in f) {
            t[f[k]] = q(f[k]);
          }

          for (var k in h) {
            for (var l in h[k]) {
              null == t[k] && (t[k] = {}), t[k][h[k][l]] = q(k + "." + h[k][l]);
            }
          }

          a = s.createElement(o);
          m = s.getElementsByTagName(o)[0];
          a.async = 1;
          a.src = g;
          m.parentNode.insertBefore(a, m);

          i.moe = i.moe || function () {
            n = arguments[0];
            return t;
          };

          a.onload = function () {
            if (n) {
              i[r] = moe(n);
            }
          };
        })(window, document, "script", document.location.protocol === "https:" ? "https://cdn.moengage.com/webpush/moe_webSdk.min.latest.js" : "http://cdn.moengage.com/webpush/moe_webSdk.min.latest.js", "Moengage");
        /* eslint-enable */
        // setting the region if us then not needed.


        if (this.region !== "US") {
          self.moeClient = window.moe({
            app_id: this.apiId,
            debug_logs: this.debug ? 1 : 0,
            cluster: this.region === "EU" ? "eu" : "in"
          });
        } else {
          self.moeClient = window.moe({
            app_id: this.apiId,
            debug_logs: this.debug ? 1 : 0
          });
        }

        this.initialUserId = this.analyticsinstance.userId;
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("inside track"); // Check if the user id is same as previous session if not a new session will start

        if (!rudderElement.message) {
          logger.error("Payload not correct");
          return;
        }

        var _rudderElement$messag = rudderElement.message,
            event = _rudderElement$messag.event,
            properties = _rudderElement$messag.properties,
            userId = _rudderElement$messag.userId;

        if (userId) {
          if (this.initialUserId !== userId) {
            this.reset();
          }
        } // track event : https://docs.moengage.com/docs/tracking-events


        if (!event) {
          logger.error("Event name not present");
          return;
        }

        if (properties) {
          this.moeClient.track_event(event, properties);
        } else {
          this.moeClient.track_event(event);
        }
      }
    }, {
      key: "reset",
      value: function reset() {
        logger.debug("inside reset"); // reset the user id

        this.initialUserId = this.analyticsinstance.userId;
        this.moeClient.destroy_session();
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        var self = this;
        var userId = rudderElement.message.userId;
        var traits = null;

        if (rudderElement.message.context) {
          traits = rudderElement.message.context.traits;
        } // check if user id is same or not


        if (this.initialUserId !== userId) {
          this.reset();
        } // if user is present map


        if (userId) {
          this.moeClient.add_unique_user_id(userId);
        } // track user attributes : https://docs.moengage.com/docs/tracking-web-user-attributes


        if (traits) {
          each_1(function add(value, key) {
            // check if name is present
            if (key === "name") {
              self.moeClient.add_user_name(value);
            }

            if (Object.prototype.hasOwnProperty.call(traitsMap, key)) {
              var method = "add_".concat(traitsMap[key]);
              self.moeClient[method](value);
            } else {
              self.moeClient.add_user_attribute(key, value);
            }
          }, traits);
        }
      }
    }]);

    return MoEngage;
  }();

  var Optimizely = /*#__PURE__*/function () {
    function Optimizely(config, analytics) {
      var _this = this;

      _classCallCheck(this, Optimizely);

      this.referrerOverride = function (referrer) {
        if (referrer) {
          window.optimizelyEffectiveReferrer = referrer;
          return referrer;
        }

        return undefined;
      };

      this.sendDataToRudder = function (campaignState) {
        logger.debug(campaignState);
        var experiment = campaignState.experiment;
        var variation = campaignState.variation;
        var context = {
          integrations: {
            All: true
          }
        };
        var audiences = campaignState.audiences; // Reformatting this data structure into hash map so concatenating variation ids and names is easier later

        var audiencesMap = {};
        audiences.forEach(function (audience) {
          audiencesMap[audience.id] = audience.name;
        });
        var audienceIds = Object.keys(audiencesMap).sort().join();
        var audienceNames = Object.values(audiencesMap).sort().join(", ");

        if (_this.sendExperimentTrack) {
          var props = {
            campaignName: campaignState.campaignName,
            campaignId: campaignState.id,
            experimentId: experiment.id,
            experimentName: experiment.name,
            variationName: variation.name,
            variationId: variation.id,
            audienceId: audienceIds,
            // eg. '7527562222,7527111138'
            audienceName: audienceNames,
            // eg. 'Peaky Blinders, Trust Tree'
            isInCampaignHoldback: campaignState.isInCampaignHoldback
          }; // If this was a redirect experiment and the effective referrer is different from document.referrer,
          // this value is made available. So if a customer came in via google.com/ad -> tb12.com -> redirect experiment -> Belichickgoat.com
          // `experiment.referrer` would be google.com/ad here NOT `tb12.com`.

          if (experiment.referrer) {
            props.referrer = experiment.referrer;
            context.page = {
              referrer: experiment.referrer
            };
          } // For Google's nonInteraction flag


          if (_this.sendExperimentTrackAsNonInteractive) props.nonInteraction = 1; // If customCampaignProperties is provided overide the props with it.
          // If valid customCampaignProperties present it will override existing props.
          // const data = window.optimizely && window.optimizely.get("data");

          var data = campaignState;

          if (data && _this.customCampaignProperties.length > 0) {
            for (var index = 0; index < _this.customCampaignProperties.length; index += 1) {
              var rudderProp = _this.customCampaignProperties[index].from;
              var optimizelyProp = _this.customCampaignProperties[index].to;

              if (typeof props[optimizelyProp] !== "undefined") {
                props[rudderProp] = props[optimizelyProp];
                delete props[optimizelyProp];
              }
            }
          } // Send to Rudder


          _this.analytics.track("Experiment Viewed", props, context);
        }

        if (_this.sendExperimentIdentify) {
          var traits = {};
          traits["Experiment: ".concat(experiment.name)] = variation.name; // Send to Rudder

          _this.analytics.identify(traits);
        }
      };

      this.analytics = analytics;
      this.sendExperimentTrack = config.sendExperimentTrack;
      this.sendExperimentIdentify = config.sendExperimentIdentify;
      this.sendExperimentTrackAsNonInteractive = config.sendExperimentTrackAsNonInteractive;
      this.revenueOnlyOnOrderCompleted = config.revenueOnlyOnOrderCompleted;
      this.trackCategorizedPages = config.trackCategorizedPages;
      this.trackNamedPages = config.trackNamedPages;
      this.customCampaignProperties = config.customCampaignProperties ? config.customCampaignProperties : [];
      this.customExperimentProperties = config.customExperimentProperties ? config.customExperimentProperties : [];
      this.name = NAME$w;
    }

    _createClass(Optimizely, [{
      key: "init",
      value: function init() {
        logger.debug("=== in optimizely init ===");
        this.initOptimizelyIntegration(this.referrerOverride, this.sendDataToRudder);
      }
    }, {
      key: "initOptimizelyIntegration",
      value: function initOptimizelyIntegration(referrerOverride, sendCampaignData) {
        var newActiveCampaign = function newActiveCampaign(id, referrer) {
          var state = window.optimizely.get && window.optimizely.get("state");

          if (state) {
            var activeCampaigns = state.getCampaignStates({
              isActive: true
            });
            var campaignState = activeCampaigns[id];
            if (referrer) campaignState.experiment.referrer = referrer;
            sendCampaignData(campaignState);
          }
        };

        var checkReferrer = function checkReferrer() {
          var state = window.optimizely.get && window.optimizely.get("state");

          if (state) {
            var referrer = state.getRedirectInfo() && state.getRedirectInfo().referrer;

            if (referrer) {
              referrerOverride(referrer);
              return referrer;
            }
          }

          return undefined;
        };

        var registerFutureActiveCampaigns = function registerFutureActiveCampaigns() {
          window.optimizely = window.optimizely || [];
          window.optimizely.push({
            type: "addListener",
            filter: {
              type: "lifecycle",
              name: "campaignDecided"
            },
            handler: function handler(event) {
              var id = event.data.campaign.id;
              newActiveCampaign(id);
            }
          });
        };

        var registerCurrentlyActiveCampaigns = function registerCurrentlyActiveCampaigns() {
          window.optimizely = window.optimizely || [];
          var state = window.optimizely.get && window.optimizely.get("state");

          if (state) {
            var referrer = checkReferrer();
            var activeCampaigns = state.getCampaignStates({
              isActive: true
            });
            Object.keys(activeCampaigns).forEach(function (id) {
              if (referrer) {
                newActiveCampaign(id, referrer);
              } else {
                newActiveCampaign(id);
              }
            });
          } else {
            window.optimizely.push({
              type: "addListener",
              filter: {
                type: "lifecycle",
                name: "initialized"
              },
              handler: function handler() {
                checkReferrer();
              }
            });
          }
        };

        registerCurrentlyActiveCampaigns();
        registerFutureActiveCampaigns();
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("in Optimizely web track");
        var eventProperties = rudderElement.message.properties;
        var event = rudderElement.message.event;

        if (eventProperties.revenue && this.revenueOnlyOnOrderCompleted) {
          if (event === "Order Completed") {
            eventProperties.revenue = Math.round(eventProperties.revenue * 100);
          } else if (event !== "Order Completed") {
            delete eventProperties.revenue;
          }
        }

        var eventName = event.replace(/:/g, "_"); // can't have colons so replacing with underscores

        var payload = {
          type: "event",
          eventName: eventName,
          tags: eventProperties
        };
        window.optimizely.push(payload);
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("in Optimizely web page");
        var category = rudderElement.message.properties.category;
        var name = rudderElement.message.name;
        /* const contextOptimizely = {
          integrations: { All: false, Optimizely: true },
        }; */
        // categorized pages

        if (category && this.trackCategorizedPages) {
          // this.analytics.track(`Viewed ${category} page`, {}, contextOptimizely);
          rudderElement.message.event = "Viewed ".concat(category, " page");
          rudderElement.message.type = "track";
          this.track(rudderElement);
        } // named pages


        if (name && this.trackNamedPages) {
          // this.analytics.track(`Viewed ${name} page`, {}, contextOptimizely);
          rudderElement.message.event = "Viewed ".concat(name, " page");
          rudderElement.message.type = "track";
          this.track(rudderElement);
        }
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        return !!(window.optimizely && window.optimizely.push !== Array.prototype.push);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return !!(window.optimizely && window.optimizely.push !== Array.prototype.push);
      }
    }]);

    return Optimizely;
  }();

  var Pendo = /*#__PURE__*/function () {
    function Pendo(config, analytics) {
      _classCallCheck(this, Pendo);

      this.analytics = analytics;
      this.apiKey = !config.apiKey ? "" : config.apiKey;
      this.name = NAME$x;
      logger.debug("Config ", config);
    }

    _createClass(Pendo, [{
      key: "init",
      value: function init() {
        (function (apiKey) {
          (function (p, e, n, d, o) {
            var v, w, x, y, z;
            o = p[d] = p[d] || {};
            o._q = [];
            v = ["initialize", "identify", "updateOptions", "pageLoad", "track"];

            for (w = 0, x = v.length; w < x; ++w) {
              (function (m) {
                o[m] = o[m] || function () {
                  o._q[m === v[0] ? "unshift" : "push"]([m].concat([].slice.call(arguments, 0)));
                };
              })(v[w]);
            }

            y = e.createElement(n);
            y.async = !0;
            y.src = "https://cdn.pendo.io/agent/static/".concat(apiKey, "/pendo.js");
            z = e.getElementsByTagName(n)[0];
            z.parentNode.insertBefore(y, z);
          })(window, document, "script", "pendo");
        })(this.apiKey);

        this.initializeMe();
        logger.debug("===in init Pendo===");
      }
    }, {
      key: "initializeMe",
      value: function initializeMe() {
        var userId = this.analytics.userId || this.constructPendoAnonymousId(this.analytics.anonymousId);

        var accountObj = _objectSpread2({
          id: this.analytics.groupId
        }, this.analytics.groupTraits);

        var visitorObj = _objectSpread2({
          id: userId
        }, this.analytics.userTraits);

        window.pendo.initialize({
          account: accountObj,
          visitor: visitorObj
        });
      }
      /* utility functions ---Start here ---  */

    }, {
      key: "isLoaded",
      value: function isLoaded() {
        return !!(window.pendo && window.pendo.push !== Array.prototype.push);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return !!(window.pendo && window.pendo.push !== Array.prototype.push);
      }
    }, {
      key: "constructPendoAnonymousId",
      value: function constructPendoAnonymousId(id) {
        return "_PENDO_T_".concat(id);
      }
      /* utility functions --- Ends here ---  */

      /*
       * PENDO MAPPED FUNCTIONS :: identify, track, group
       */

      /* Pendo's identify call works intelligently, once u have identified a visitor/user,
       *or associated a visitor to a group/account then Pendo save this data in local storage and
       *any further upcoming calls are done taking user info from local.
       * To track user perndo maps user to Visitor in Pendo.
       */

    }, {
      key: "identify",
      value: function identify(rudderElement) {
        var visitorObj = {};
        var accountObj = {};
        var groupId = this.analytics.groupId;
        var id = this.analytics.userId || this.constructPendoAnonymousId(this.analytics.anonymousId);
        visitorObj = _objectSpread2({
          id: id
        }, this.analytics.userTraits);

        if (groupId) {
          accountObj = _objectSpread2({
            id: groupId
          }, this.analytics.groupTraits);
        }

        window.pendo.identify({
          visitor: visitorObj,
          account: accountObj
        });
      }
      /*
       *Group call maps to an account for which visitor belongs.
       *It is same as identify call but here we send account object.
       */

    }, {
      key: "group",
      value: function group(rudderElement) {
        var accountObj = {};
        var visitorObj = {};
        var _rudderElement$messag = rudderElement.message,
            userId = _rudderElement$messag.userId,
            traits = _rudderElement$messag.traits;
        accountObj.id = this.analytics.groupId || this.analytics.anonymousId;
        accountObj = _objectSpread2(_objectSpread2({}, accountObj), traits);

        if (userId) {
          visitorObj = _objectSpread2({
            id: userId
          }, rudderElement.message.context && rudderElement.message.context.traits);
        }

        window.pendo.identify({
          account: accountObj,
          visitor: visitorObj
        });
      }
      /* Once user is identified Pendo makes Track call to track user activity.
       */

    }, {
      key: "track",
      value: function track(rudderElement) {
        var event = rudderElement.message.event;

        if (!event) {
          throw Error("Cannot call un-named track event");
        }

        var props = rudderElement.message.properties;
        window.pendo.track(event, props);
      }
    }]);

    return Pendo;
  }();

  var eventMapping = [{
    src: ["order completed"],
    dest: "Checkout"
  }, {
    src: ["product added"],
    dest: "AddToCart",
    hasEmptyProducts: true
  }, {
    src: ["products searched", "product list filtered"],
    dest: "Search"
  }];
  var searchPropertyMapping = {
    src: "query",
    dest: "search_query"
  };
  var productPropertyMapping = [{
    src: ["product_id", "sku"],
    dest: "product_id"
  }, {
    src: "name",
    dest: "product_name"
  }, {
    src: "price",
    dest: "product_price"
  }, {
    src: "category",
    dest: "product_category"
  }, {
    src: "variant",
    dest: "product_variant"
  }, {
    src: "quantity",
    dest: "product_quantity"
  }, {
    src: "brand",
    dest: "product_brand"
  }];
  var propertyMapping = [{
    src: "revenue",
    dest: "value"
  }];
  var pinterestPropertySupport = ["value", "order_quantity", "currency", "order_id", "product_name", "product_id", "product_category", "product_variant", "product_variant_id", "product_price", "product_quantity", "product_brand", "promo_code", "property", "video_title", "lead_type", "coupon"];

  var PinterestTag = /*#__PURE__*/function () {
    function PinterestTag(config, analytics) {
      _classCallCheck(this, PinterestTag);

      this.analytics = analytics;
      this.tagId = !config.tagId ? "" : config.tagId;
      this.enhancedMatch = config.enhancedMatch || false;
      this.customProperties = config.customProperties || [];
      this.userDefinedEventsMapping = config.eventsMapping || [];
      this.name = NAME$y;
      logger.debug("config", config);
    }

    _createClass(PinterestTag, [{
      key: "loadScript",
      value: function loadScript() {
        !function (e) {
          if (!window.pintrk) {
            window.pintrk = function () {
              window.pintrk.queue.push(Array.prototype.slice.call(arguments));
            };

            var n = window.pintrk;
            n.queue = [], n.version = "3.0";
            var t = document.createElement("script");
            t.async = !0, t.src = e;
            var r = document.getElementsByTagName("script")[0];
            r.parentNode.insertBefore(t, r);
          }
        }("https://s.pinimg.com/ct/core.js");
      }
    }, {
      key: "handleEnhancedMatch",
      value: function handleEnhancedMatch() {
        var email = this.analytics.userTraits && this.analytics.userTraits.email;

        if (email && this.enhancedMatch) {
          window.pintrk("load", this.tagId, {
            em: email
          });
        } else {
          window.pintrk("load", this.tagId);
        }

        window.pintrk("page");
      }
    }, {
      key: "init",
      value: function init() {
        logger.debug("===in init Pinterest Tag===");
        this.loadScript();
        this.handleEnhancedMatch();
      }
      /* utility functions ---Start here ---  */

    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("===in isLoaded Pinterest Tag===");
        return !!(window.pintrk && window.pintrk.push !== Array.prototype.push);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("===in isReady Pinterest Tag===");
        return !!(window.pintrk && window.pintrk.push !== Array.prototype.push);
      }
      /* utility functions --- Ends here ---  */

    }, {
      key: "sendPinterestTrack",
      value: function sendPinterestTrack(eventName, pinterestObject) {
        window.pintrk("track", eventName, pinterestObject);
      }
      /**
       * Send rudder property and mappings array. This function will return data mapping destination property
       * @param {*} properties
       * @param {*} mappings
       * @returns Pinterest Products
       */

    }, {
      key: "getMappingObject",
      value: function getMappingObject(properties, mappings) {
        var isPersist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var pinterestObject = {};
        mappings.forEach(function (mapping) {
          pinterestObject = _objectSpread2(_objectSpread2({}, getDataFromSource(mapping.src, mapping.dest, properties)), pinterestObject);
        });

        if (isPersist) {
          return _objectSpread2(_objectSpread2({}, pinterestObject), properties);
        }

        return pinterestObject;
      }
      /**
       * This function  simply copies data from rudder payload to new object provided all
       * the key in properties is present in pinterestPropertySupport
       * @param {rudder properties} properties
       * @returns
       */

    }, {
      key: "getRawPayload",
      value: function getRawPayload(properties) {
        var data = {};
        var mappedProps = this.getMappingObject(properties, propertyMapping, true);
        Object.keys(mappedProps).forEach(function (p) {
          if (pinterestPropertySupport.includes(p)) {
            data[p] = mappedProps[p];
          }
        }); // This logic maps rudder query to search_query for Products Searched events

        if (isDefinedAndNotNull(properties[searchPropertyMapping.src])) {
          data[searchPropertyMapping.dest] = properties[searchPropertyMapping.src];
        }

        return data;
      }
      /**
       * This function will generate required pinterest object to be sent.
       * getRawPayload() will generate all the destination property excepts lineItems
       * If rudder payload has products array then line_items is generated
       * In case if the call is for event which has flag hasEmptyProducts to true, it will generate all
       * properties including lineItems even if it does not have products array in it ex: Product Added
       *
       * @param {rudder payload} properties
       * @param {*} hasEmptyProducts
       * @returns
       */

    }, {
      key: "generatePinterestObject",
      value: function generatePinterestObject(properties) {
        var _this = this;

        var hasEmptyProducts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var pinterestObject = this.getRawPayload(properties);
        var products = properties.products;

        if (hasEmptyProducts && !products) {
          products = [properties];
        }

        if (products) {
          var lineItems = [];
          products.forEach(function (p) {
            var product = _this.getMappingObject(p, productPropertyMapping);

            lineItems.push(product);
          });
          pinterestObject.line_items = lineItems;
        }

        if (this.customProperties.length > 0 && Object.keys(properties).length > 0) {
          var flattenPayload = flattenJsonPayload(properties);
          this.customProperties.forEach(function (custom) {
            // This check fails if user is sending boolean value as false
            // Adding toString because if the property value is boolean then it never gets reflected in destination
            if (isDefinedAndNotNull(flattenPayload[custom.properties])) {
              pinterestObject[custom.properties] = flattenPayload[custom.properties].toString();
            }
          });
        }

        return pinterestObject;
      }
      /**
       * This gives destination events .
       * Logics: If our eventMapping is not able to map the event that is sent by user payload then it will look into
       * userDefinedEventsMapping array. In case if it is not found there as well, it will return undefined.
       * @param {rudder event name} event
       * @returns
       */

    }, {
      key: "getDestinationEventName",
      value: function getDestinationEventName(event) {
        var destinationEvent = eventMapping.find(function (p) {
          return p.src.includes(event.toLowerCase());
        });

        if (!destinationEvent && this.userDefinedEventsMapping.length > 0) {
          var userDefinedEvent = this.userDefinedEventsMapping.find(function (e) {
            return e.from.toLowerCase() === event.toLowerCase();
          });

          if (userDefinedEvent && userDefinedEvent.to) {
            return {
              dest: userDefinedEvent.to,
              isUserDefinedEvent: true
            };
          }
        }

        return destinationEvent;
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        if (!rudderElement.message || !rudderElement.message.event) {
          return;
        }

        var _rudderElement$messag = rudderElement.message,
            properties = _rudderElement$messag.properties,
            event = _rudderElement$messag.event;
        var eventName = event;
        var destEvent = this.getDestinationEventName(event);

        if (isDefinedAndNotNull(destEvent)) {
          eventName = destEvent.dest;
        }

        var pinterestObject = this.generatePinterestObject(properties, destEvent === null || destEvent === void 0 ? void 0 : destEvent.hasEmptyProducts, destEvent === null || destEvent === void 0 ? void 0 : destEvent.isUserDefinedEvent);
        this.sendPinterestTrack(eventName, pinterestObject);
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        var _rudderElement$messag2 = rudderElement.message,
            category = _rudderElement$messag2.category,
            name = _rudderElement$messag2.name;
        var pageObject = {
          name: name || ""
        };
        var event = "PageVisit";

        if (category) {
          pageObject.category = category;
          event = "ViewCategory";
        }

        window.pintrk("track", event, pageObject);
      }
    }, {
      key: "identify",
      value: function identify() {
        var email = this.analytics.userTraits && this.analytics.userTraits.email;

        if (email) {
          window.pintrk("set", {
            em: email
          });
        }
      }
    }]);

    return PinterestTag;
  }();

  var QuantumMetric = /*#__PURE__*/function () {
    function QuantumMetric(config) {
      _classCallCheck(this, QuantumMetric);

      this.siteId = config.siteID; // 1549611

      this.name = NAME$D;
      this._ready = false;
    }

    _createClass(QuantumMetric, [{
      key: "init",
      value: function init() {
        if (window.QuantumMetricAPI) {
          return;
        }

        ScriptLoader("Quantum Metric", "https://cdn.quantummetric.com/qscripts/quantum-".concat(this.siteId, ".js"));

        if (window.QuantumMetricAPI) {
          this._ready = true;
        }

        logger.debug("===in init Quantum Metric===");
      }
    }, {
      key: "identify",
      value: function identify() {
        logger.debug("[QuantumMetric] track:: method not supported");
      }
    }, {
      key: "track",
      value: function track() {
        logger.debug("[QuantumMetric] track:: method not supported");
      }
    }, {
      key: "page",
      value: function page() {
        logger.debug("[QuantumMetric] page:: method not supported");
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        if (!this._ready && window.QuantumMetricAPI) {
          this._ready = true;
        }

        return this._ready;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return this.isLoaded();
      }
    }]);

    return QuantumMetric;
  }();

  var Posthog = /*#__PURE__*/function () {
    function Posthog(config, analytics) {
      var _this = this;

      _classCallCheck(this, Posthog);

      this.name = NAME$A;
      this.analytics = analytics;
      this.teamApiKey = config.teamApiKey;
      this.yourInstance = removeTrailingSlashes(config.yourInstance) || "https://app.posthog.com";
      this.autocapture = config.autocapture || false;
      this.capturePageView = config.capturePageView || false;
      this.disableSessionRecording = config.disableSessionRecording || false;
      this.disableCookie = config.disableCookie || false;
      this.propertyBlackList = [];
      this.xhrHeaders = {};
      this.enableLocalStoragePersistence = config.enableLocalStoragePersistence;

      if (config.xhrHeaders && config.xhrHeaders.length > 0) {
        config.xhrHeaders.forEach(function (header) {
          if (header && header.key && header.value && header.key.trim() !== "" && header.value.trim() !== "") {
            _this.xhrHeaders[header.key] = header.value;
          }
        });
      }

      if (config.propertyBlackList && config.propertyBlackList.length > 0) {
        config.propertyBlackList.forEach(function (element) {
          if (element && element.property && element.property.trim() !== "") {
            _this.propertyBlackList.push(element.property);
          }
        });
      }
    }

    _createClass(Posthog, [{
      key: "init",
      value: function init() {
        !function (t, e) {
          var o, n, p, r;
          e.__SV || (window.posthog = e, e._i = [], e.init = function (i, s, a) {
            function g(t, e) {
              var o = e.split(".");
              2 == o.length && (t = t[o[0]], e = o[1]), t[e] = function () {
                t.push([e].concat(Array.prototype.slice.call(arguments, 0)));
              };
            }

            (p = t.createElement("script")).type = "text/javascript", p.async = !0, p.src = s.api_host + "/static/array.js", (r = t.getElementsByTagName("script")[0]).parentNode.insertBefore(p, r);
            var u = e;

            for (void 0 !== a ? u = e[a] = [] : a = "posthog", u.people = u.people || [], u.toString = function (t) {
              var e = "posthog";
              return "posthog" !== a && (e += "." + a), t || (e += " (stub)"), e;
            }, u.people.toString = function () {
              return u.toString(1) + ".people (stub)";
            }, o = "capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags".split(" "), n = 0; n < o.length; n++) {
              g(u, o[n]);
            }

            e._i.push([i, s, a]);
          }, e.__SV = 1);
        }(document, window.posthog || []);
        var POSTHOG = this.analytics.loadOnlyIntegrations.POSTHOG;
        var configObject = {
          api_host: this.yourInstance,
          autocapture: this.autocapture,
          capture_pageview: this.capturePageView,
          disable_session_recording: this.disableSessionRecording,
          property_blacklist: this.propertyBlackList,
          disable_cookie: this.disableCookie
        };

        if (POSTHOG && POSTHOG.loaded) {
          configObject.loaded = POSTHOG.loaded;
        }

        if (this.xhrHeaders && Object.keys(this.xhrHeaders).length > 0) {
          configObject.xhr_headers = this.xhrHeaders;
        }

        if (this.enableLocalStoragePersistence) {
          configObject.persistence = "localStorage+cookie";
        }

        posthog.init(this.teamApiKey, configObject);
      }
      /**
       * superproperties should be part of rudderelement.message.integrations.POSTHOG object.
       * Once we call the posthog.register api, the corresponding property will be sent along with subsequent capture calls.
       * To remove the superproperties, we call unregister api.
       */

    }, {
      key: "processSuperProperties",
      value: function processSuperProperties(rudderElement) {
        var integrations = rudderElement.message.integrations;

        if (integrations && integrations.POSTHOG) {
          var _integrations$POSTHOG = integrations.POSTHOG,
              superProperties = _integrations$POSTHOG.superProperties,
              setOnceProperties = _integrations$POSTHOG.setOnceProperties,
              unsetProperties = _integrations$POSTHOG.unsetProperties;

          if (superProperties && Object.keys(superProperties).length > 0) {
            posthog.register(superProperties);
          }

          if (setOnceProperties && Object.keys(setOnceProperties).length > 0) {
            posthog.register_once(setOnceProperties);
          }

          if (unsetProperties && unsetProperties.length > 0) {
            unsetProperties.forEach(function (property) {
              if (property && property.trim() !== "") {
                posthog.unregister(property);
              }
            });
          }
        }
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("in Posthog identify"); // rudderElement.message.context will always be present as part of identify event payload.

        var traits = rudderElement.message.context.traits;
        var userId = rudderElement.message.userId;

        if (userId) {
          posthog.identify(userId, traits);
        }

        this.processSuperProperties(rudderElement);
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("in Posthog track");
        var _rudderElement$messag = rudderElement.message,
            event = _rudderElement$messag.event,
            properties = _rudderElement$messag.properties;
        this.processSuperProperties(rudderElement);
        posthog.capture(event, properties);
      }
      /**
       *
       *
       * @memberof Posthog
       */

    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("in Posthog page");
        this.processSuperProperties(rudderElement);
        posthog.capture("$pageview");
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("in Posthog isLoaded");
        return !!(window.posthog && window.posthog.__loaded);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return !!(window.posthog && window.posthog.__loaded);
      }
    }]);

    return Posthog;
  }();

  var ProfitWell = /*#__PURE__*/function () {
    function ProfitWell(config) {
      _classCallCheck(this, ProfitWell);

      this.publicApiKey = config.publicApiKey;
      this.siteType = config.siteType;
      this.name = NAME$B;
    }

    _createClass(ProfitWell, [{
      key: "init",
      value: function init() {
        logger.debug("===In init ProfitWell===");

        if (!this.publicApiKey) {
          logger.debug("===[ProfitWell]: Public API Key not found===");
          return;
        }

        window.publicApiKey = this.publicApiKey;
        var scriptTag = document.createElement("script");
        scriptTag.setAttribute("id", "profitwell-js");
        scriptTag.setAttribute("data-pw-auth", window.publicApiKey);
        document.body.appendChild(scriptTag);

        (function (i, s, o, g, r, a, m) {
          i[o] = i[o] || function () {
            (i[o].q = i[o].q || []).push(arguments);
          };

          a = s.createElement(g);
          m = s.getElementsByTagName(g)[0];
          a.async = 1;
          a.src = r + "?auth=" + window.publicApiKey;
          m.parentNode.insertBefore(a, m);
        })(window, document, "profitwell", "script", "https://public.profitwell.com/js/profitwell.js");
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("===In isLoaded ProfitWell===");
        return !!(window.profitwell && window.profitwell.length !== 0);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("===In isReady ProfitWell===");
        return !!(window.profitwell && window.profitwell.length !== 0);
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("===In ProfitWell identify===");

        if (this.siteType === "marketing") {
          window.profitwell("start", {});
          return;
        }

        var message = rudderElement.message;
        var email = getValue(message, "context.traits.email");

        if (email) {
          window.profitwell("start", {
            user_email: email
          });
          return;
        }

        var userId = getValue(message, "userId");

        if (userId) {
          window.profitwell("start", {
            user_id: userId
          });
          return;
        }

        logger.debug("===[ProfitWell]: email or userId is required for identify===");
      }
    }]);

    return ProfitWell;
  }();

  var Qualtrics = /*#__PURE__*/function () {
    function Qualtrics(config) {
      _classCallCheck(this, Qualtrics);

      this.name = NAME$C;
      this.projectId = config.projectId;
      this.brandId = config.brandId;
      this.enableGenericPageTitle = config.enableGenericPageTitle;
    }

    _createClass(Qualtrics, [{
      key: "init",
      value: function init() {
        logger.debug("===in init Qualtrics===");

        if (!this.projectId) {
          logger.debug("Project ID missing");
          return;
        }

        if (!this.brandId) {
          logger.debug("Brand ID missing");
          return;
        }

        var projectIdFormatted = this.projectId.replace(/_/g, "").toLowerCase().trim();
        var requestUrlFormatted = "https://".concat(projectIdFormatted, "-").concat(this.brandId, ".siteintercept.qualtrics.com/SIE/?Q_ZID=").concat(this.projectId);
        var requestIdFormatted = "QSI_S_".concat(this.projectId);

        (function () {
          var g = function g(e, h, f, _g) {
            this.get = function (a) {
              for (var a = a + "=", c = document.cookie.split(";"), b = 0, e = c.length; b < e; b++) {
                for (var d = c[b]; " " == d.charAt(0);) {
                  d = d.substring(1, d.length);
                }

                if (0 == d.indexOf(a)) return d.substring(a.length, d.length);
              }

              return null;
            };

            this.set = function (a, c) {
              var b = "",
                  b = new Date();
              b.setTime(b.getTime() + 6048e5);
              b = "; expires=" + b.toGMTString();
              document.cookie = a + "=" + c + b + "; path=/; ";
            };

            this.check = function () {
              var a = this.get(f);
              if (a) a = a.split(":");else if (100 != e) "v" == h && (e = Math.random() >= e / 100 ? 0 : 100), a = [h, e, 0], this.set(f, a.join(":"));else return !0;
              var c = a[1];
              if (100 == c) return !0;

              switch (a[0]) {
                case "v":
                  return !1;

                case "r":
                  return c = a[2] % Math.floor(100 / c), a[2]++, this.set(f, a.join(":")), !c;
              }

              return !0;
            };

            this.go = function () {
              if (this.check()) {
                var a = document.createElement("script");
                a.type = "text/javascript";
                a.src = _g;
                document.body && document.body.appendChild(a);
              }
            };

            this.start = function () {
              var t = this;
              "complete" !== document.readyState ? window.addEventListener ? window.addEventListener("load", function () {
                t.go();
              }, !1) : window.attachEvent && window.attachEvent("onload", function () {
                t.go();
              }) : t.go();
            };
          };

          try {
            new g(100, "r", requestIdFormatted, requestUrlFormatted).start();
          } catch (i) {}
        })();

        var div = document.createElement("div");
        div.setAttribute("id", String(this.projectId));
        window._qsie = window._qsie || [];
        document.getElementsByTagName("head")[0].appendChild(div);
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("===in Qualtrics isLoaded===");
        return !!(window._qsie && window.QSI && window.QSI.API);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("===in Qualtrics isReady===");
        return !!(window._qsie && window.QSI && window.QSI.API);
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("===in Qualtrics page===");
        var message = rudderElement.message;

        if (!message) {
          logger.debug("Message field is missing");
          return;
        }

        if (this.enableGenericPageTitle) {
          window._qsie.push("Viewed a Page");

          return;
        }

        var name = message.name,
            category = message.category,
            properties = message.properties;
        var categoryField = category || (properties && properties.category ? properties.category : null);

        if (!categoryField && !name) {
          logger.debug("generic title is disabled and no name or category field found");
          return;
        }

        var dynamicTitle = categoryField && name ? "Viewed ".concat(categoryField, " ").concat(name, " Page") : "Viewed ".concat(name, " Page");

        window._qsie.push(dynamicTitle);
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("===in Qualtrics track===");
        var message = rudderElement.message;

        if (!message) {
          logger.debug("Message field is missing");
          return;
        }

        if (!message.event) {
          logger.debug("Event field is undefined");
          return;
        }

        window._qsie.push(message.event);
      }
    }]);

    return Qualtrics;
  }();

  var RedditPixel = /*#__PURE__*/function () {
    function RedditPixel(config) {
      _classCallCheck(this, RedditPixel);

      this.advertiserId = config.advertiserId;
      this.name = NAME$E;
    }

    _createClass(RedditPixel, [{
      key: "init",
      value: function init() {
        logger.debug("===In init RedditPixel===");
        !function (w, d) {
          if (!w.rdt) {
            var p = w.rdt = function () {
              p.sendEvent ? p.sendEvent.apply(p, arguments) : p.callQueue.push(arguments);
            };

            p.callQueue = [];
            var t = d.createElement("script");
            t.src = "https://www.redditstatic.com/ads/pixel.js", t.async = !0;
            var s = d.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(t, s);
          }
        }(window, document);
        window.rdt("init", this.advertiserId);
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("===In isLoaded RedditPixel===");
        return !!(window.rdt && window.rdt.advertiserId === this.advertiserId);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("===In isReady RedditPixel===");
        return !!(window.rdt && window.rdt.advertiserId === this.advertiserId);
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("===In RedditPixel identify===");
        window.rdt("track", "SignUp");
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("===In RedditPixel track===");
        var event = rudderElement.message.event;

        if (!event) {
          logger.error("Event name is not present");
          return;
        }

        switch (event.toLowerCase()) {
          case "product added":
            window.rdt("track", "AddToCart");
            break;

          case "product added to wishlist":
            window.rdt("track", "AddToWishlist");
            break;

          case "order completed":
            window.rdt("track", "Purchase");
            break;

          case "lead":
            window.rdt("track", "Lead");
            break;

          case "view content":
            window.rdt("track", "ViewContent");
            break;

          case "search":
            window.rdt("track", "Search");
            break;

          default:
            logger.error("Invalid event ".concat(event, ". Track call not supported"));
            break;
        }
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("===In RedditPixel page===");
        window.rdt("track", "PageVisit");
      }
    }]);

    return RedditPixel;
  }();

  var convertObjectToArray = function convertObjectToArray(objectInput, propertyName) {
    return objectInput.map(function (objectItem) {
      return objectItem[propertyName];
    }).filter(function (e) {
      return isDefinedAndNotNullAndNotEmpty(e);
    });
  };

  var SentryScriptLoader = function SentryScriptLoader(id, src, integrity) {
    logger.debug("in script loader=== ".concat(id));
    var js = document.createElement("script");
    js.src = src;
    js.integrity = integrity;
    js.crossOrigin = "anonymous";
    js.type = "text/javascript";
    js.id = id;
    var e = document.getElementsByTagName("script")[0];
    logger.debug("==parent script==", e);
    logger.debug("==adding script==", js);
    e.parentNode.insertBefore(js, e);
  };

  var sentryInit = function sentryInit(allowUrls, denyUrls, ignoreErrors, includePathsArray, customVersionProperty, release, DSN, debugMode, environment, serverName) {
    var formattedAllowUrls = convertObjectToArray(allowUrls, "allowUrls");
    var formattedDenyUrls = convertObjectToArray(denyUrls, "denyUrls");
    var formattedIgnoreErrors = convertObjectToArray(ignoreErrors, "ignoreErrors");
    var formattedIncludePaths = convertObjectToArray(includePathsArray, "includePaths");
    var customRelease = customVersionProperty ? window[customVersionProperty] : null;
    var sentryConfig = {
      dsn: DSN,
      debug: debugMode,
      environment: environment || null,
      release: customRelease || release || null,
      serverName: serverName || null,
      allowUrls: formattedAllowUrls,
      denyUrls: formattedDenyUrls,
      ignoreErrors: formattedIgnoreErrors
    };
    var includePaths = [];

    if (formattedIncludePaths.length > 0) {
      // eslint-disable-next-line func-names
      includePaths = formattedIncludePaths.map(function (path) {
        var regex;

        try {
          regex = new RegExp(path);
        } catch (e) {// ignored
        }

        return regex;
      });
    }

    if (includePaths.length > 0) {
      sentryConfig.integrations = [];
      sentryConfig.integrations.push(new window.Sentry.Integrations.RewriteFrames({
        iteratee: function iteratee(frame) {
          // eslint-disable-next-line no-restricted-syntax
          var _iterator = _createForOfIteratorHelper(includePaths),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var path = _step.value;

              try {
                if (frame.filename.match(path)) {
                  frame.in_app = true;
                  return frame;
                }
              } catch (e) {// ignored
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          frame.in_app = false;
          return frame;
        }
      }));
    }

    return sentryConfig;
  };

  var Sentry = /*#__PURE__*/function () {
    function Sentry(config) {
      _classCallCheck(this, Sentry);

      this.name = NAME$F;
      this.dsn = config.dsn;
      this.debugMode = config.debugMode;
      this.environment = config.environment;
      this.ignoreErrors = config.ignoreErrors;
      this.includePathsArray = config.includePaths;
      this.logger = config.logger;
      this.allowUrls = config.allowUrls;
      this.denyUrls = config.denyUrls;
      this.release = config.release;
      this.customVersionProperty = config.customVersionProperty;
      this.serverName = config.serverName;
    }

    _createClass(Sentry, [{
      key: "init",
      value: function init() {
        logger.debug("===in init Sentry===");

        if (!this.dsn) {
          logger.debug("DSN is a mandatory field");
          return;
        }

        SentryScriptLoader("sentry", "https://browser.sentry-cdn.com/6.13.1/bundle.min.js", "sha384-vUP3nL55ipf9vVr3gDgKyDuYwcwOC8nZGAksntVhezPcr2QXl1Ls81oolaVSkPm+");
        SentryScriptLoader("plugin", "https://browser.sentry-cdn.com/6.13.1/rewriteframes.min.js", "sha384-WOm9k3kzVt1COFAB/zCXOFx4lDMtJh/2vmEizIwgog7OW0P/dPwl3s8f6MdwrD7q");
      } // eslint-disable-next-line class-methods-use-this

    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("===in Sentry isLoaded===");
        return !!(window.Sentry && isObject$1(window.Sentry) && window.Sentry.setUser && window.Sentry.Integrations.RewriteFrames);
      } // eslint-disable-next-line class-methods-use-this

    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("===in Sentry isReady===");

        if (window.Sentry && isObject$1(window.Sentry) && window.Sentry.setUser && window.Sentry.Integrations.RewriteFrames) {
          var sentryConfig = sentryInit(this.allowUrls, this.denyUrls, this.ignoreErrors, this.includePathsArray, this.customVersionProperty, this.release, this.dsn, this.debugMode, this.environment, this.serverName);
          window.Sentry.init(sentryConfig);

          if (this.logger) {
            window.Sentry.setTag("logger", this.logger);
          }

          return true;
        }

        return false;
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        var message = rudderElement.message;
        var traits = message.context.traits;

        var _getDefinedTraits = getDefinedTraits(message),
            email = _getDefinedTraits.email,
            name = _getDefinedTraits.name; // userId sent as id and username sent as name


        var userId = getValue(message, "userId");
        var ipAddress = getValue(message, "context.traits.ip_address");

        if (!userId && !email && !name && !ipAddress) {
          // if no user identification property is present the event will be dropped
          logger.debug("===[Sentry]: Any one of userId, email, name and ip_address is mandatory===");
          return;
        }

        var payload = _objectSpread2({
          id: userId,
          email: email,
          username: name,
          ip_address: ipAddress
        }, traits);

        window.Sentry.setUser(removeUndefinedAndNullValues(payload));
      }
    }]);

    return Sentry;
  }();

  var sendEvent = function sendEvent(event, payload) {
    if (isNotEmpty(payload)) {
      window.snaptr("track", event, payload);
    } else {
      window.snaptr("track", event);
    }
  };

  var getCommonEventPayload = function getCommonEventPayload(message) {
    var payload = {
      price: parseFloat(getValue(message, "properties.price")),
      client_deduplication_id: getValue(message, "properties.client_deduplication_id"),
      currency: getValue(message, "properties.currency"),
      transaction_id: getValue(message, "properties.transactionId") || getValue(message, "properties.transaction_id"),
      item_category: getValue(message, "properties.category"),
      description: getValue(message, "properties.description"),
      search_string: getValue(message, "properties.search_string"),
      number_items: parseInt(getValue(message, "properties.number_items"), 10),
      payment_info_available: parseInt(getValue(message, "properties.payment_info_available"), 10),
      sign_up_method: getValue(message, "properties.sign_up_method"),
      success: parseInt(getValue(message, "properties.success"), 10)
    };

    if (payload.payment_info_available !== 0 && payload.payment_info_available !== 1) {
      payload.payment_info_available = null;
    }

    if (payload.success !== 0 && payload.success !== 1) {
      payload.success = null;
    }

    payload = removeUndefinedAndNullValues(payload);
    return payload;
  };

  var eventPayload = function eventPayload(message) {
    var payload = getCommonEventPayload(message);
    payload.item_ids = getValue(message, "properties.item_ids");
    payload = removeUndefinedAndNullValues(payload);
    return payload;
  };

  var ecommEventPayload$1 = function ecommEventPayload(event, message) {
    var payload = getCommonEventPayload(message);

    switch (event.toLowerCase().trim()) {
      case "order completed":
        {
          var itemIds = [];
          var products = getValue(message, "properties.products");

          if (products && Array.isArray(products)) {
            products.forEach(function (element, index) {
              var pId = element.product_id;

              if (pId) {
                itemIds.push(pId);
              } else {
                logger.debug("product_id not present for product at index ".concat(index));
              }
            });
          } else {
            itemIds = null;
          }

          payload = _objectSpread2(_objectSpread2({}, payload), {}, {
            transaction_id: getValue(message, "properties.order_id"),
            item_ids: itemIds
          });
          break;
        }

      case "checkout started":
        {
          var _itemIds = [];

          var _products = getValue(message, "properties.products");

          if (_products && Array.isArray(_products)) {
            _products.forEach(function (element, index) {
              var pId = element.product_id;

              if (pId) {
                _itemIds.push(pId);
              } else {
                logger.debug("product_id not present for product at index ".concat(index));
              }
            });
          } else {
            _itemIds = null;
          }

          payload = _objectSpread2(_objectSpread2({}, payload), {}, {
            transaction_id: getValue(message, "properties.order_id"),
            item_ids: _itemIds
          });
          break;
        }

      case "product added":
        {
          var _itemIds2 = [];
          var pId = getValue(message, "properties.product_id");

          if (isDefinedAndNotNull$1(pId)) {
            _itemIds2.push(pId);
          } else {
            logger.debug("product_id is not present");
            _itemIds2 = null;
          }

          payload = _objectSpread2(_objectSpread2({}, payload), {}, {
            item_ids: _itemIds2
          });
          break;
        }

      case "payment info entered":
        payload = _objectSpread2(_objectSpread2({}, payload), {}, {
          transaction_id: getValue(message, "properties.checkout_id"),
          item_ids: getValue(message, "properties.item_ids")
        });
        break;

      case "promotion clicked":
        payload = _objectSpread2(_objectSpread2({}, payload), {}, {
          item_ids: getValue(message, "properties.item_ids")
        });
        break;

      case "promotion viewed":
        payload = _objectSpread2(_objectSpread2({}, payload), {}, {
          item_ids: getValue(message, "properties.item_ids")
        });
        break;

      case "product added to wishlist":
        {
          var _itemIds3 = [];

          var _pId = getValue(message, "properties.product_id");

          if (isDefinedAndNotNull$1(_pId)) {
            _itemIds3.push(_pId);
          } else {
            logger.debug("product_id is not present");
            _itemIds3 = null;
          }

          payload = _objectSpread2(_objectSpread2({}, payload), {}, {
            item_ids: _itemIds3
          });
          break;
        }

      case "product viewed":
        {
          var _itemIds4 = [];

          var _pId2 = getValue(message, "properties.product_id");

          if (_pId2) {
            _itemIds4.push(_pId2);
          } else {
            logger.debug("product_id is not present");
            _itemIds4 = null;
          }

          payload = _objectSpread2(_objectSpread2({}, payload), {}, {
            item_ids: _itemIds4
          });
          break;
        }

      case "product list viewed":
        {
          var _itemIds5 = [];

          var _products2 = getValue(message, "properties.products");

          if (_products2 && Array.isArray(_products2)) {
            _products2.forEach(function (element, index) {
              var pId = getValue(element, "product_id");

              if (pId) {
                _itemIds5.push(pId);
              } else {
                logger.debug("product_id not present for product at index ".concat(index));
              }
            });
          } else {
            _itemIds5 = null;
          }

          payload = _objectSpread2(_objectSpread2({}, payload), {}, {
            item_ids: _itemIds5
          });
          break;
        }

      case "products searched":
        payload = _objectSpread2(_objectSpread2({}, payload), {}, {
          search_string: getValue(message, "properties.query"),
          item_ids: getValue(message, "properties.item_ids")
        });
        break;
    }

    payload = removeUndefinedAndNullValues(payload);
    return payload;
  };

  var SnapPixel = /*#__PURE__*/function () {
    function SnapPixel(config) {
      _classCallCheck(this, SnapPixel);

      this.pixelId = config.pixelId;
      this.hashMethod = config.hashMethod;
      this.name = NAME$G;
      this.trackEvents = ["SIGN_UP", "OPEN_APP", "SAVE", "SUBSCRIBE", "COMPLETE_TUTORIAL", "INVITE", "LOGIN", "SHARE", "RESERVE", "ACHIEVEMENT_UNLOCKED", "SPENT_CREDITS", "RATE", "START_TRIAL", "LIST_VIEW"];
      this.ecomEvents = {
        PURCHASE: "PURCHASE",
        START_CHECKOUT: "START_CHECKOUT",
        ADD_CART: "ADD_CART",
        ADD_BILLING: "ADD_BILLING",
        AD_CLICK: "AD_CLICK",
        AD_VIEW: "AD_VIEW",
        ADD_TO_WISHLIST: "ADD_TO_WISHLIST",
        VIEW_CONTENT: "VIEW_CONTENT",
        SEARCH: "SEARCH"
      };
      this.customEvents = ["custom_event_1", "custom_event_2", "custom_event_3", "custom_event_4", "custom_event_5"];
    }

    _createClass(SnapPixel, [{
      key: "init",
      value: function init() {
        logger.debug("===In init SnapPixel===");

        (function (e, t, n) {
          if (e.snaptr) return;

          var a = e.snaptr = function () {
            a.handleRequest ? a.handleRequest.apply(a, arguments) : a.queue.push(arguments);
          };

          a.queue = [];
          var s = "script";
          var r = t.createElement(s);
          r.async = !0;
          r.src = n;
          var u = t.getElementsByTagName(s)[0];
          u.parentNode.insertBefore(r, u);
        })(window, document, "https://sc-static.net/scevent.min.js");

        var cookieData = Storage$1.getUserTraits();
        var payload = {
          user_email: cookieData.email,
          user_phone_number: cookieData.phone
        };

        if (!payload.user_email && !payload.user_phone_number) {
          logger.debug("User parameter (email or phone number) not found in cookie. identify is required");
          return;
        }

        if (this.hashMethod === "sha256") {
          if (isDefinedAndNotNull$1(payload.user_email)) {
            payload.user_email = sha256(payload.user_email).toString();
          }

          if (isDefinedAndNotNull$1(payload.user_phone_number)) {
            payload.user_phone_number = sha256(payload.user_phone_number).toString();
          }
        }

        payload = removeUndefinedAndNullValues(payload);
        window.snaptr("init", this.pixelId, payload);
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("===In isLoaded SnapPixel===");
        return !!window.snaptr;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("===In isReady SnapPixel===");
        return !!window.snaptr;
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("===In SnapPixel identify");
        var message = rudderElement.message;
        var payload = {
          user_email: getValue(message, "context.traits.email"),
          user_phone_number: getValue(message, "context.traits.phone")
        };

        if (!payload.user_email && !payload.user_phone_number) {
          logger.error("User parameter (email or phone number) is required");
          return;
        }

        if (this.hashMethod === "sha256") {
          if (isDefinedAndNotNull$1(payload.user_email)) {
            payload.user_email = sha256(payload.user_email).toString();
          }

          if (isDefinedAndNotNull$1(payload.user_phone_number)) {
            payload.user_phone_number = sha256(payload.user_phone_number).toString();
          }
        }

        payload = removeUndefinedAndNullValues(payload);
        window.snaptr("init", this.pixelId, payload);
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("===In SnapPixel track===");
        var message = rudderElement.message;
        var event = message.event;

        if (!event) {
          logger.error("Event name not present");
          return;
        }

        switch (event.toLowerCase().trim()) {
          case "order completed":
            sendEvent(this.ecomEvents.PURCHASE, ecommEventPayload$1(event, message));
            break;

          case "checkout started":
            sendEvent(this.ecomEvents.START_CHECKOUT, ecommEventPayload$1(event, message));
            break;

          case "product added":
            sendEvent(this.ecomEvents.ADD_CART, ecommEventPayload$1(event, message));
            break;

          case "payment info entered":
            sendEvent(this.ecomEvents.ADD_BILLING, ecommEventPayload$1(event, message));
            break;

          case "promotion clicked":
            sendEvent(this.ecomEvents.AD_CLICK, ecommEventPayload$1(event, message));
            break;

          case "promotion viewed":
            sendEvent(this.ecomEvents.AD_VIEW, ecommEventPayload$1(event, message));
            break;

          case "product added to wishlist":
            sendEvent(this.ecomEvents.ADD_TO_WISHLIST, ecommEventPayload$1(event, message));
            break;

          case "product viewed":
          case "product list viewed":
            sendEvent(this.ecomEvents.VIEW_CONTENT, ecommEventPayload$1(event, message));
            break;

          case "products searched":
            sendEvent(this.ecomEvents.SEARCH, ecommEventPayload$1(event, message));
            break;

          default:
            if (!this.trackEvents.includes(event.trim().toUpperCase()) && !this.customEvents.includes(event.trim().toLowerCase())) {
              logger.error("Event doesn't match with Snap Pixel Events!");
              return;
            }

            sendEvent(event, eventPayload(message));
            break;
        }
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("===In SnapPixel page===");
        var message = rudderElement.message;
        sendEvent("PAGE_VIEW", eventPayload(message));
      }
    }]);

    return SnapPixel;
  }();

  var TVSquared = /*#__PURE__*/function () {
    function TVSquared(config) {
      _classCallCheck(this, TVSquared);

      this.isLoaded = function () {
        logger.debug("in TVSqaured isLoaded");
        return !!(window._tvq && window._tvq.push !== Array.prototype.push);
      };

      this.isReady = function () {
        logger.debug("in TVSqaured isReady");
        return !!(window._tvq && window._tvq.push !== Array.prototype.push);
      };

      this.page = function () {
        window._tvq.push([function () {
          this.deleteCustomVariable(5, "page");
        }]);

        window._tvq.push(["trackPageView"]);
      };

      this.formatRevenue = function (revenue) {
        var rev = revenue;
        rev = parseFloat(rev.toString().replace(/^[^\d.]*/, ""));
        return rev;
      };

      this.brandId = config.brandId;
      this.clientId = config.clientId;
      this.eventWhiteList = config.eventWhiteList || [];
      this.customMetrics = config.customMetrics || [];
      this.name = NAME$H;
    }

    _createClass(TVSquared, [{
      key: "init",
      value: function init() {
        logger.debug("===in init TVSquared===");
        window._tvq = window._tvq || [];
        var url = document.location.protocol === "https:" ? "https://" : "http://";
        url += "collector-".concat(this.clientId, ".tvsquared.com/");

        window._tvq.push(["setSiteId", this.brandId]);

        window._tvq.push(["setTrackerUrl", "".concat(url, "tv2track.php")]);

        ScriptLoader("TVSquared-integration", "".concat(url, "tv2track.js"));
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        var _rudderElement$messag = rudderElement.message,
            event = _rudderElement$messag.event,
            userId = _rudderElement$messag.userId,
            anonymousId = _rudderElement$messag.anonymousId;
        var _rudderElement$messag2 = rudderElement.message.properties,
            revenue = _rudderElement$messag2.revenue,
            productType = _rudderElement$messag2.productType,
            category = _rudderElement$messag2.category,
            order_id = _rudderElement$messag2.order_id,
            promotion_id = _rudderElement$messag2.promotion_id;
        var i;
        var j;
        var whitelist = this.eventWhiteList.slice();
        whitelist = whitelist.filter(function (wl) {
          return wl.event !== "";
        });

        for (i = 0; i < whitelist.length; i += 1) {
          if (event.toUpperCase() === whitelist[i].event.toUpperCase()) {
            break;
          }

          if (i === whitelist.length - 1) {
            return;
          }
        }

        var session = {
          user: userId || anonymousId || ""
        };
        var action = {
          rev: revenue ? this.formatRevenue(revenue) : "",
          prod: category || productType || "",
          id: order_id || "",
          promo: promotion_id || ""
        };
        var customMetrics = this.customMetrics.slice();
        customMetrics = customMetrics.filter(function (cm) {
          return cm.propertyName !== "";
        });

        if (customMetrics.length) {
          for (j = 0; j < customMetrics.length; j += 1) {
            var key = customMetrics[j].propertyName;
            var value = rudderElement.message.properties[key];

            if (value) {
              action[key] = value;
            }
          }
        }

        window._tvq.push([function () {
          this.setCustomVariable(5, "session", JSON.stringify(session), "visit");
        }]);

        if (event.toUpperCase() !== "RESPONSE") {
          window._tvq.push([function () {
            this.setCustomVariable(5, event, JSON.stringify(action), "page");
          }]);

          window._tvq.push(["trackPageView"]);
        } else {
          window._tvq.push([function () {
            this.deleteCustomVariable(5, "page");
          }]);
        }
      }
    }]);

    return TVSquared;
  }();

  var VWO = /*#__PURE__*/function () {
    function VWO(config, analytics) {
      _classCallCheck(this, VWO);

      this.accountId = config.accountId; // 1549611

      this.settingsTolerance = config.settingsTolerance;
      this.isSPA = config.isSPA;
      this.libraryTolerance = config.libraryTolerance;
      this.useExistingJquery = config.useExistingJquery;
      this.sendExperimentTrack = config.sendExperimentTrack;
      this.sendExperimentIdentify = config.sendExperimentIdentify;
      this.name = NAME$I;
      this.analytics = analytics;
      logger.debug("Config ", config);
    }

    _createClass(VWO, [{
      key: "init",
      value: function init() {
        var _this$analytics$loadO, _this$analytics$loadO2;

        logger.debug("===In init VWO===");

        if ((_this$analytics$loadO = this.analytics.loadOnlyIntegrations) !== null && _this$analytics$loadO !== void 0 && (_this$analytics$loadO2 = _this$analytics$loadO.VWO) !== null && _this$analytics$loadO2 !== void 0 && _this$analytics$loadO2.loadIntegration) {
          var account_id = this.accountId;
          var settings_tolerance = this.settingsTolerance;
          var _library_tolerance = this.libraryTolerance;
          var _use_existing_jquery = this.useExistingJquery;
          var isSPA = this.isSPA;

          window._vwo_code = function () {
            var f = false;
            var d = document;
            return {
              use_existing_jquery: function use_existing_jquery() {
                return _use_existing_jquery;
              },
              library_tolerance: function library_tolerance() {
                return _library_tolerance;
              },
              finish: function finish() {
                if (!f) {
                  f = true;
                  var a = d.getElementById("_vis_opt_path_hides");
                  if (a) a.parentNode.removeChild(a);
                }
              },
              finished: function finished() {
                return f;
              },
              load: function load(a) {
                var b = d.createElement("script");
                b.src = a;
                b.type = "text/javascript";
                b.innerText;

                b.onerror = function () {
                  _vwo_code.finish();
                };

                d.getElementsByTagName("head")[0].appendChild(b);
              },
              init: function init() {
                var settings_timer = setTimeout("_vwo_code.finish()", settings_tolerance);
                var a = d.createElement("style");
                var b = "body{opacity:0 !important;filter:alpha(opacity=0) !important;background:none !important;}";
                var h = d.getElementsByTagName("head")[0];
                a.setAttribute("id", "_vis_opt_path_hides");
                a.setAttribute("type", "text/css");
                if (a.styleSheet) a.styleSheet.cssText = b;else a.appendChild(d.createTextNode(b));
                h.appendChild(a);
                this.load("//dev.visualwebsiteoptimizer.com/j.php?a=".concat(account_id, "&u=").concat(encodeURIComponent(d.URL), "&r=").concat(Math.random(), "&f=").concat(+isSPA));
                return settings_timer;
              }
            };
          }();

          window._vwo_settings_timer = window._vwo_code.init();
        } else {
          logger.debug("===[VWO]loadIntegration flag is disabled===");
        } // Send track or iddentify when


        if (this.sendExperimentTrack || this.experimentViewedIdentify) {
          this.experimentViewed();
        }
      }
    }, {
      key: "experimentViewed",
      value: function experimentViewed() {
        var _this = this;

        window.VWO = window.VWO || [];
        var self = this;
        window.VWO.push(["onVariationApplied", function (data) {
          if (!data) {
            return;
          }

          logger.debug("Variation Applied");
          var expId = data[1];
          var variationId = data[2];
          logger.debug("experiment id:", expId, "Variation Name:", _vwo_exp[expId].comb_n[variationId]);

          if (typeof _vwo_exp[expId].comb_n[variationId] !== "undefined" && ["VISUAL_AB", "VISUAL", "SPLIT_URL", "SURVEY"].indexOf(_vwo_exp[expId].type) > -1) {
            try {
              if (self.sendExperimentTrack) {
                logger.debug("Tracking...");

                _this.analytics.track("Experiment Viewed", {
                  experimentId: expId,
                  variationName: _vwo_exp[expId].comb_n[variationId]
                });
              }
            } catch (error) {
              logger.error("[VWO] experimentViewed:: ", error);
            }

            try {
              if (self.sendExperimentIdentify) {
                logger.debug("Identifying...");

                _this.analytics.identify(_defineProperty({}, "Experiment: ".concat(expId), _vwo_exp[expId].comb_n[variationId]));
              }
            } catch (error) {
              logger.error("[VWO] experimentViewed:: ", error);
            }
          }
        }]);
      }
    }, {
      key: "identify",
      value: function identify() {
        logger.debug("[VWO] identify:: method not supported");
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("===In VWO track===");
        var eventName = rudderElement.message.event;

        if (eventName === "Order Completed") {
          var total = rudderElement.message.properties ? rudderElement.message.properties.total || rudderElement.message.properties.revenue : 0;
          logger.debug("Revenue", total);
          window.VWO = window.VWO || [];
          window.VWO.push(["track.revenueConversion", total]);
        }
      }
    }, {
      key: "page",
      value: function page() {
        logger.debug("[VWO] page:: method not supported");
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("===In isLoaded VWO===");
        return !!window._vwo_code;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("===In isReady VWO===");
        return !!window._vwo_code;
      }
    }]);

    return VWO;
  }();

  var GoogleOptimize = /*#__PURE__*/function () {
    function GoogleOptimize(config) {
      _classCallCheck(this, GoogleOptimize);

      this.name = NAME$h;
      this.ga = config.ga;
      this.trackingId = config.trackingId;
      this.containerId = config.containerId;
      this.async = config.async;
      this.aflicker = config.aflicker;
    }

    _createClass(GoogleOptimize, [{
      key: "init",
      value: function init() {
        logger.debug("===in init Google Optimize===");

        if (!this.containerId) {
          return;
        } // load optimize script first


        ScriptLoader("Google Optimize", "https://www.googleoptimize.com/optimize.js?id=".concat(this.containerId), this.async);

        if (this.ga) {
          var gtag = function gtag() {
            dataLayer.push(arguments);
          };

          if (!this.trackingId) {
            return;
          }

          ScriptLoader("Google Tag Manager", "https://www.googletagmanager.com/gtag/js?id=".concat(this.trackingId));
          window.dataLayer = window.dataLayer || [];
          gtag("js", new Date());
          gtag("config", "".concat(this.trackingId));
        } // anti flicker snippet contains insertBefore since it needs to be executed before any other script
        // link -> https://support.google.com/optimize/answer/7100284?hl=en&ref_topic=6197443


        if (this.aflicker) {
          var flick = document.createElement("style");
          flick.innerHTML = ".async-hide { opacity: 0 !important}";
          var js = document.createElement("script");
          js.innerHTML = "(function(a,s,y,n,c,h,i,d,e){s.className+=' '+y;h.start=1*new Date;h.end=i=function(){s.className=s.className.replace(RegExp(' ?'+y),'')};(a[n]=a[n]||[]).hide=h;setTimeout(function(){i();h.end=null},c);h.timeout=c;})(window,document.documentElement,'async-hide','dataLayer',4000,{'".concat(this.containerId, "':true});");
          var e = document.getElementsByTagName("script")[0];
          e.parentNode.insertBefore(flick, e); // style tag in anti flicker snippet should be before the a-flicker script as per docs

          e.parentNode.insertBefore(js, e);
        }
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("=== in isLoaded Google Optimize===");
        return !!window.dataLayer;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("=== in isReady Google Optimize===");
        return !!window.dataLayer;
      }
    }]);

    return GoogleOptimize;
  }();

  // This function helps to populate the sale object
  var updateSaleObject = function updateSaleObject(sale, properties) {
    if (properties.total) sale.setTotalCost(properties.total);
    if (properties.fixedCost) sale.setFixedCost(properties.fixedCost);
    if (properties.order_id) sale.setOrderID(properties.order_id); // Post Affiliate Pro supports five extra data only.

    if (properties.data1) sale.setData1(properties.data1);
    if (properties.data2) sale.setData2(properties.data2);
    if (properties.data3) sale.setData3(properties.data3);
    if (properties.data4) sale.setData4(properties.data4);
    if (properties.data5) sale.setData5(properties.data5);
    if (properties.doNotDeleteCookies && properties.doNotDeleteCookies === true) sale.doNotDeleteCookies();
    if (properties.status) sale.setStatus(properties.status);
    if (properties.currency) sale.setCurrency(properties.currency);
    if (properties.customCommision) sale.setCustomCommission(properties.customCommision);
    if (properties.channel) sale.setChannelID(properties.channel);
    if (properties.coupon) sale.setCoupon(properties.coupon);
    if (properties.campaignId) sale.setCampaignID(properties.campaignId);
    if (properties.affiliateId) sale.setAffiliateID(properties.affiliateId);
  };

  var PostAffiliatePro = /*#__PURE__*/function () {
    function PostAffiliatePro(config) {
      _classCallCheck(this, PostAffiliatePro);

      this.name = NAME$z;
      this.url = config.url;
      this.mergeProducts = config.mergeProducts;
      this.accountId = config.accountId;
      this.affLinkId = config.affLinkId;
      this.idName = config.idName;
      this.cookieLinkId = config.cookieLinkId;
      this.cookieName = config.cookieName;
      this.affiliateToCustomField = config.affiliateToCustomField;
      this.campaignToCustomField = config.campaignToCustomField;
      this.cookieDomain = config.cookieDomain;
      this.cookieToCustomField = config.cookieToCustomField;
      this.disableTrackingMethod = config.disableTrackingMethod;
      this.paramNameUserId = config.paramNameUserId;
      this.clickEvents = config.clickEvents;
    }

    _createClass(PostAffiliatePro, [{
      key: "init",
      value: function init() {
        logger.debug("===in init Post Affiliate Pro===");

        if (!this.url) {
          logger.debug("URL is missing");
          return;
        }

        ScriptLoader("pap_x2s6df8d", this.url);
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("===In isLoaded Post Affiliate Pro===");
        return !!window.PostAffTracker;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("===In isReady Post Affiliate Pro===");

        if (window.PostAffTracker) {
          if (!this.disableTrackingMethod) window.PostAffTracker.disableTrackingMethod("F");
          if (this.paramNameUserId) window.PostAffTracker.setParamNameUserId(this.paramNameUserId);
          if (this.accountId) window.PostAffTracker.setAccountId(this.accountId);
          if (this.cookieDomain) window.PostAffTracker.setCookieDomain(this.cookieDomain);
          if (this.cookieToCustomField) window.PostAffTracker.writeCookieToCustomField(this.cookieToCustomField);
          if (this.affiliateToCustomField) window.PostAffTracker.writeAffiliateToCustomField(this.affiliateToCustomField);
          if (this.campaignToCustomField) window.PostAffTracker.writeCampaignToCustomField(this.campaignToCustomField);
          if (this.affLinkId && this.idName) window.PostAffTracker.writeAffiliateToLink(this.affLinkId, this.idName);
          if (this.cookieName && this.cookieLinkId) window.PostAffTracker.writeCookieToLink(this.cookieLinkId, this.cookieName);
          return true;
        }

        return false;
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("===In Post Affiliate Pro identify===");
        var message = rudderElement.message;
        var visitorId = getValue(message, "userId");
        window.PostAffTracker.setVisitorId(visitorId);
      } // eslint-disable-next-line lines-between-class-members

    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("===In Post Affiliate Pro track===");
        var clickEventsArr = this.clickEvents ? this.clickEvents.split(",") : null;
        var message = rudderElement.message;
        var event = message.event;
        var properties = message.properties; // We are going to call click event, for the event list given in dashboard only.

        if (clickEventsArr && clickEventsArr.includes(event)) {
          if (properties) {
            if (properties.data1) window.Data1 = properties.data1;
            if (properties.data2) window.Data2 = properties.data2;
            if (properties.affiliateId) window.AffiliateID = properties.affiliateId;
            if (properties.bannerId) window.BannerID = properties.bannerId;
            if (properties.campaignId) window.CampaignID = properties.campaignId;
            if (properties.channel) window.Channel = properties.channel;
          }

          window.PostAffTracker.track();
        } // We are supporting only one event for sale.


        if (event === "Order Completed") {
          var productsArr = properties && properties.products ? properties.products : null;

          if (productsArr) {
            if (this.mergeProducts) {
              window.sale = window.PostAffTracker.createSale();
              if (window.sale) updateSaleObject(window.sale, properties);
              var mergedProductId = [];

              for (var i = 0; i < productsArr.length; i += 1) {
                if (productsArr[i].product_id) mergedProductId.push(productsArr[i].product_id);
              }

              var merged = mergedProductId.join();
              if (merged) window.sale.setProductID(merged);
            } else {
              for (var _i = 0; _i < productsArr.length; _i += 1) {
                window["sale".concat(_i)] = window.PostAffTracker.createSale();
                updateSaleObject(window["sale".concat(_i)], properties);
                if (productsArr[_i].product_id) window["sale".concat(_i)].setProductID(productsArr[_i].product_id);
              }
            }
          } else {
            // If any product is not available.
            window.sale = window.PostAffTracker.createSale();
          }

          window.PostAffTracker.register();
        }
      } // reset() {
      //   window.PostAffTracker.setVisitorId(null);
      // }

    }]);

    return PostAffiliatePro;
  }();

  var createUser = function createUser(message) {
    var user = {};
    user.key = message.userId || message.anonymousId;
    var traits = message.context.traits;

    if (traits.anonymous !== undefined) {
      user.anonymous = traits.anonymous;
    }

    if (traits.avatar !== undefined) user.avatar = traits.avatar;
    if (traits.country !== undefined) user.country = traits.country;
    if (traits.custom !== undefined) user.custom = traits.custom;
    if (traits.email !== undefined) user.email = traits.email;
    if (traits.firstName !== undefined) user.firstName = traits.firstName;
    if (traits.ip !== undefined) user.ip = traits.ip;
    if (traits.lastName !== undefined) user.lastName = traits.lastName;
    if (traits.name !== undefined) user.name = traits.name;
    if (traits.privateAttributeNames !== undefined) user.privateAttributeNames = traits.privateAttributeNames;
    if (traits.secondary !== undefined) user.secondary = traits.secondary;
    return user;
  };

  var LaunchDarkly = /*#__PURE__*/function () {
    function LaunchDarkly(config) {
      _classCallCheck(this, LaunchDarkly);

      this.name = NAME$q;
      this.clientSideId = config.clientSideId;
    }

    _createClass(LaunchDarkly, [{
      key: "init",
      value: function init() {
        logger.debug("===in init LaunchDarkly===");

        if (!this.clientSideId) {
          logger.error("".concat(this.name, " :: Unable to initialize destination - clientSideId is missing in config"));
          return;
        }

        ScriptLoader(null, "https://unpkg.com/launchdarkly-js-client-sdk@2");
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("===In isLoaded LaunchDarkly===");
        return !!window.LDClient;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("===In isReady LaunchDarkly===");
        return this.isLoaded();
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        var message = rudderElement.message;
        window.user = createUser(message);

        if (window.ldclient) {
          window.ldclient.identify(window.user);
        } else {
          window.ldclient = window.LDClient.initialize(this.clientSideId, window.user);
        }
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        var _rudderElement$messag = rudderElement.message,
            event = _rudderElement$messag.event,
            properties = _rudderElement$messag.properties;

        if (window.ldclient) {
          window.ldclient.track(event, properties);
        } else logger.error("=== In LaunchDarkly, track is not supported before identify ===");
      }
    }, {
      key: "alias",
      value: function alias(rudderElement) {
        var message = rudderElement.message;
        var newUser = {
          key: message.userId
        };

        if (window.ldclient) {
          window.ldclient.alias(newUser, window.user);
        } else logger.error("=== In LaunchDarkly, alias is not supported before identify ===");
      }
    }]);

    return LaunchDarkly;
  }();

  var GA360 = /*#__PURE__*/function (_GA) {
    _inherits(GA360, _GA);

    var _super = _createSuper(GA360);

    function GA360(config, analytics) {
      var _this;

      _classCallCheck(this, GA360);

      _this = _super.call(this, config, analytics);
      _this.name = NAME$J;
      return _this;
    }

    _createClass(GA360, [{
      key: "init",
      value: function init() {
        logger.debug("===in init GA 360 ===");
        return _get(_getPrototypeOf(GA360.prototype), "init", this).call(this);
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("=========in GA 360 identify ==========");
        return _get(_getPrototypeOf(GA360.prototype), "identify", this).call(this, rudderElement);
      }
    }, {
      key: "track",
      value: function track(rudderElement) {
        logger.debug("=========in GA 360 track ==========");
        return _get(_getPrototypeOf(GA360.prototype), "track", this).call(this, rudderElement);
      }
    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("=========in GA 360 page ==========");
        return _get(_getPrototypeOf(GA360.prototype), "page", this).call(this, rudderElement);
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("=========in GA 360 load ==========");
        return _get(_getPrototypeOf(GA360.prototype), "isLoaded", this).call(this);
      }
    }, {
      key: "isReady",
      value: function isReady() {
        return _get(_getPrototypeOf(GA360.prototype), "isReady", this).call(this);
      }
    }]);

    return GA360;
  }(GA$1);

  /* eslint-disable no-param-reassign */
  var productEvent = function productEvent(properties) {
    if (properties.price) {
      properties.adroll_conversion_value = properties.price;
      delete properties.price;
    }

    return properties;
  };

  var orderEvent = function orderEvent(properties) {
    if (properties.orderId) {
      properties.order_id = properties.orderId;
      delete properties.orderId;
    }

    if (properties.revenue) {
      properties.adroll_conversion_value = properties.revenue;
      delete properties.revenue;
    } else {
      var productRevenue = 0;

      if (properties.products) {
        properties.products.forEach(function (product) {
          productRevenue += product.price;
        });
      }

      properties.adroll_conversion_value = productRevenue;
    }

    return properties;
  };

  var Adroll = /*#__PURE__*/function () {
    function Adroll(config) {
      _classCallCheck(this, Adroll);

      this.advId = config.advId;
      this.pixId = config.pixId;
      this.name = NAME$K;
      window.adroll_adv_id = this.advId;
      window.adroll_pix_id = this.pixId;
      this.eventsMap = config.eventsMap || [];
    }

    _createClass(Adroll, [{
      key: "init",
      value: function init() {
        logger.debug("===In init Adroll===");
        ScriptLoader("adroll roundtrip", "https://s.adroll.com/j/".concat(this.advId, "/roundtrip.js"));
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        logger.debug("===In isLoaded Adroll===");
        return !!window.__adroll;
      }
    }, {
      key: "isReady",
      value: function isReady() {
        logger.debug("===In isReady Adroll===");
        return !!window.__adroll;
      }
    }, {
      key: "identify",
      value: function identify(rudderElement) {
        logger.debug("===In Adroll Identify===");
        var message = rudderElement.message;
        var email = getValue(message, "context.traits.email") || getValue(message, "traits.email");

        if (!email) {
          logger.error("User parameter (email) is required for identify call");
          return;
        }

        window._adroll_email = email;

        window.__adroll.record_adroll_email("segment");
      } // record_adroll_email is used to attach a image pixel to the page connected to the user identified

    }, {
      key: "track",
      value: function track(rudderElement) {
        var PRODUCT_EVENTS = ["product clicked", "product viewed", "product added"];
        var ORDER_EVENTS = ["cart viewed", "checkout started", "order completed", "order cancelled", "order updated"];
        var message = rudderElement.message;
        var userId = message.userId,
            event = message.event,
            properties = message.properties;
        var eventsHashmap = getHashFromArray(this.eventsMap);
        var data;

        if (eventsHashmap[event.toLowerCase()]) {
          if (PRODUCT_EVENTS.includes(event.toLowerCase())) {
            if (userId) {
              properties.user_id = userId;
            }

            data = productEvent(properties);
          } else if (ORDER_EVENTS.includes(event.toLowerCase())) {
            if (userId) {
              properties.user_id = userId;
            }

            data = orderEvent(properties);
          } else {
            logger.error("The event ".concat(event, " is not supported in this integration. Aborting!"));
            return;
          }

          var segmentId = eventsHashmap[event.toLowerCase()];
          data.adroll_segments = segmentId;

          window.__adroll.record_user(data);
        } else {
          logger.error("The event ".concat(message.event, " is not mapped to any segmentId. Aborting!"));
        }
      } // record_user fires the correct pixel in accordance with the event configured in the dashboard
      // and the segment associated in adroll

    }, {
      key: "page",
      value: function page(rudderElement) {
        logger.debug("=== In Adroll Page ===");
        var message = rudderElement.message;
        var event = message.event,
            properties = message.properties;
        var eventsHashmap = getHashFromArray(this.eventsMap);
        message.event = "Viewed ".concat(message.name, " ").concat(message.category, " Page");
        var segmentId = eventsHashmap[message.event.toLowerCase()];
        properties.adroll_segments = segmentId;

        window.__adroll.record_user(properties); // record_user fires the correct pixel in accordance with the event configured in the dashboard
        // and the segment associated in adroll

      }
    }]);

    return Adroll;
  }();

  // (config-plan name, native destination.name , exported integration name(this one below))

  var integrations = {
    ADOBE_ANALYTICS: AdobeAnalytics,
    AM: Amplitude,
    APPCUES: Appcues,
    BINGADS: BingAds,
    BRAZE: Braze,
    BUGSNAG: Bugsnag,
    CHARTBEAT: Chartbeat,
    CLEVERTAP: Clevertap,
    COMSCORE: Comscore,
    CRITEO: Criteo,
    CUSTOMERIO: CustomerIO,
    DRIP: Drip,
    FACEBOOK_PIXEL: FacebookPixel,
    FULLSTORY: Fullstory,
    GA4: GA4,
    GA: GA$1,
    GOOGLEADS: index,
    GTM: GoogleTagManager,
    HEAP: Heap,
    HOTJAR: index$1,
    HS: index$2,
    INTERCOM: INTERCOM,
    KEEN: Keen,
    KISSMETRICS: Kissmetrics,
    KLAVIYO: Klaviyo,
    LINKEDIN_INSIGHT_TAG: LinkedInInsightTag,
    LOTAME: Lotame,
    LYTICS: Lytics,
    MOENGAGE: MoEngage,
    MP: Mixpanel,
    OPTIMIZELY: Optimizely,
    PENDO: Pendo,
    PINTEREST_TAG: PinterestTag,
    QUANTUMMETRIC: QuantumMetric,
    POSTHOG: Posthog,
    PROFITWELL: ProfitWell,
    QUALTRICS: Qualtrics,
    REDDIT_PIXEL: RedditPixel,
    SENTRY: Sentry,
    SNAP_PIXEL: SnapPixel,
    TVSQUARED: TVSquared,
    VWO: VWO,
    GOOGLE_OPTIMIZE: GoogleOptimize,
    POST_AFFILIATE_PRO: PostAffiliatePro,
    LAUNCHDARKLY: LaunchDarkly,
    GA360: GA360,
    ADROLL: Adroll
  };

  // Application class
  var RudderApp = /*#__PURE__*/_createClass(function RudderApp() {
    _classCallCheck(this, RudderApp);

    this.build = "1.0.0";
    this.name = "RudderLabs JavaScript SDK";
    this.namespace = "com.rudderlabs.javascript";
    this.version = "1.5.4";
  });

  // Library information class
  var RudderLibraryInfo = /*#__PURE__*/_createClass(function RudderLibraryInfo() {
    _classCallCheck(this, RudderLibraryInfo);

    this.name = "RudderLabs JavaScript SDK";
    this.version = "1.5.4";
  }); // Operating System information class


  var RudderOSInfo = /*#__PURE__*/_createClass(function RudderOSInfo() {
    _classCallCheck(this, RudderOSInfo);

    this.name = "";
    this.version = "";
  }); // Screen information class


  var RudderScreenInfo = /*#__PURE__*/_createClass(function RudderScreenInfo() {
    _classCallCheck(this, RudderScreenInfo);

    this.density = 0;
    this.width = 0;
    this.height = 0;
    this.innerWidth = 0;
    this.innerHeight = 0;
  }); // Device information class

  var RudderContext = /*#__PURE__*/_createClass(function RudderContext() {
    _classCallCheck(this, RudderContext);

    this.app = new RudderApp();
    this.traits = null;
    this.library = new RudderLibraryInfo(); // this.os = null;

    var os = new RudderOSInfo();
    os.version = ""; // skipping version for simplicity now

    var screen = new RudderScreenInfo(); // Depending on environment within which the code is executing, screen
    // dimensions can be set
    // User agent and locale can be retrieved only for browser
    // For server-side integration, same needs to be set by calling program

    {
      // running within browser
      screen.width = window.screen.width;
      screen.height = window.screen.height;
      screen.density = window.devicePixelRatio; // detect brave browser and append to the user agent

      if (navigator.brave && Object.getPrototypeOf(navigator.brave).isBrave) {
        var version = navigator.userAgent.match(/(Chrome)\/([\w\.]+)/i)[2];
        this.userAgent = "".concat(navigator.userAgent, " Brave/").concat(version);
      } else {
        this.userAgent = navigator.userAgent;
      } // property name differs based on browser version


      this.locale = navigator.language || navigator.browserLanguage;
      screen.innerWidth = window.innerWidth;
      screen.innerHeight = window.innerHeight;
    }

    this.os = os;
    this.screen = screen;
    this.device = null;
    this.network = null;
  });

  var RudderMessage = /*#__PURE__*/function () {
    function RudderMessage() {
      _classCallCheck(this, RudderMessage);

      this.channel = "web";
      this.context = new RudderContext();
      this.type = null;
      this.action = null;
      this.messageId = generateUUID().toString();
      this.originalTimestamp = new Date().toISOString();
      this.anonymousId = null;
      this.userId = null;
      this.event = null;
      this.properties = {};
      this.integrations = {}; // By default, all integrations will be set as enabled from client
      // Decision to route to specific destinations will be taken at server end

      this.integrations.All = true;
    } // Get property


    _createClass(RudderMessage, [{
      key: "getProperty",
      value: function getProperty(key) {
        return this.properties[key];
      } // Add property

    }, {
      key: "addProperty",
      value: function addProperty(key, value) {
        this.properties[key] = value;
      } // Validate whether this message is semantically valid for the type mentioned

    }, {
      key: "validateFor",
      value: function validateFor(messageType) {
        // First check that properties is populated
        if (!this.properties) {
          throw new Error("Key properties is required");
        } // Event type specific checks


        switch (messageType) {
          case MessageType.TRACK:
            // check if event is present
            if (!this.event) {
              throw new Error("Key event is required for track event");
            } // Next make specific checks for e-commerce events


            if (this.event in Object.values(ECommerceEvents)) {
              switch (this.event) {
                case ECommerceEvents.CHECKOUT_STEP_VIEWED:
                case ECommerceEvents.CHECKOUT_STEP_COMPLETED:
                case ECommerceEvents.PAYMENT_INFO_ENTERED:
                  this.checkForKey("checkout_id");
                  this.checkForKey("step");
                  break;

                case ECommerceEvents.PROMOTION_VIEWED:
                case ECommerceEvents.PROMOTION_CLICKED:
                  this.checkForKey("promotion_id");
                  break;

                case ECommerceEvents.ORDER_REFUNDED:
                  this.checkForKey("order_id");
                  break;
              }
            } else if (!this.properties.category) {
              // if category is not there, set to event
              this.properties.category = this.event;
            }

            break;

          case MessageType.PAGE:
            break;

          case MessageType.SCREEN:
            if (!this.properties.name) {
              throw new Error("Key 'name' is required in properties");
            }

            break;
        }
      } // Function for checking existence of a particular property

    }, {
      key: "checkForKey",
      value: function checkForKey(propertyName) {
        if (!this.properties[propertyName]) {
          throw new Error("Key '".concat(propertyName, "' is required in properties"));
        }
      }
    }]);

    return RudderMessage;
  }();

  var RudderElement = /*#__PURE__*/function () {
    function RudderElement() {
      _classCallCheck(this, RudderElement);

      this.message = new RudderMessage();
    } // Setters that in turn set the field values for the contained object


    _createClass(RudderElement, [{
      key: "setType",
      value: function setType(type) {
        this.message.type = type;
      }
    }, {
      key: "setProperty",
      value: function setProperty(rudderProperty) {
        this.message.properties = rudderProperty;
      }
    }, {
      key: "setUserProperty",
      value: function setUserProperty(rudderUserProperty) {
        this.message.user_properties = rudderUserProperty;
      }
    }, {
      key: "setUserId",
      value: function setUserId(userId) {
        this.message.userId = userId;
      }
    }, {
      key: "setEventName",
      value: function setEventName(eventName) {
        this.message.event = eventName;
      }
    }, {
      key: "updateTraits",
      value: function updateTraits(traits) {
        this.message.context.traits = traits;
      }
    }, {
      key: "getElementContent",
      value: function getElementContent() {
        return this.message;
      }
    }]);

    return RudderElement;
  }();

  var RudderElementBuilder = /*#__PURE__*/function () {
    function RudderElementBuilder() {
      _classCallCheck(this, RudderElementBuilder);

      this.rudderProperty = null;
      this.rudderUserProperty = null;
      this.event = null;
      this.userId = null;
      this.channel = null;
      this.type = null;
    } // Set the property


    _createClass(RudderElementBuilder, [{
      key: "setProperty",
      value: function setProperty(inputRudderProperty) {
        this.rudderProperty = inputRudderProperty;
        return this;
      } // Build and set the property object

    }, {
      key: "setPropertyBuilder",
      value: function setPropertyBuilder(rudderPropertyBuilder) {
        this.rudderProperty = rudderPropertyBuilder.build();
        return this;
      }
    }, {
      key: "setUserProperty",
      value: function setUserProperty(inputRudderUserProperty) {
        this.rudderUserProperty = inputRudderUserProperty;
        return this;
      }
    }, {
      key: "setUserPropertyBuilder",
      value: function setUserPropertyBuilder(rudderUserPropertyBuilder) {
        this.rudderUserProperty = rudderUserPropertyBuilder.build();
        return this;
      } // Setter methods for all variables. Instance is returned for each call in
      // accordance with the Builder pattern

    }, {
      key: "setEvent",
      value: function setEvent(event) {
        this.event = event;
        return this;
      }
    }, {
      key: "setUserId",
      value: function setUserId(userId) {
        this.userId = userId;
        return this;
      }
    }, {
      key: "setChannel",
      value: function setChannel(channel) {
        this.channel = channel;
        return this;
      }
    }, {
      key: "setType",
      value: function setType(eventType) {
        this.type = eventType;
        return this;
      }
    }, {
      key: "build",
      value: function build() {
        var element = new RudderElement();
        element.setUserId(this.userId);
        element.setType(this.type);
        element.setEventName(this.event);
        element.setProperty(this.rudderProperty);
        element.setUserProperty(this.rudderUserProperty);
        return element;
      }
    }]);

    return RudderElementBuilder;
  }();

  var IDX = 256,
      HEX = [],
      BUFFER;

  while (IDX--) {
    HEX[IDX] = (IDX + 256).toString(16).substring(1);
  }

  function v4() {
    var i = 0,
        num,
        out = '';

    if (!BUFFER || IDX + 16 > 256) {
      BUFFER = Array(i = 256);

      while (i--) {
        BUFFER[i] = 256 * Math.random() | 0;
      }

      i = IDX = 0;
    }

    for (; i < 16; i++) {
      num = BUFFER[IDX + i];
      if (i == 6) out += HEX[num & 15 | 64];else if (i == 8) out += HEX[num & 63 | 128];else out += HEX[num];
      if (i & 1 && i > 1 && i < 11) out += '-';
    }

    IDX++;
    return out;
  }

  var dist = /*#__PURE__*/Object.freeze({
    __proto__: null,
    v4: v4
  });

  var rngBrowser = createCommonjsModule(function (module) {
    // Unique ID creation requires a high quality random # generator.  In the
    // browser this is a little complicated due to unknown quality of Math.random()
    // and inconsistent support for the `crypto` API.  We do the best we can via
    // feature-detection
    // getRandomValues needs to be invoked in a context where "this" is a Crypto
    // implementation. Also, find the complete implementation of crypto on IE11.
    var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (getRandomValues) {
      // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
      var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

      module.exports = function whatwgRNG() {
        getRandomValues(rnds8);
        return rnds8;
      };
    } else {
      // Math.random()-based (RNG)
      //
      // If all else fails, use Math.random().  It's fast, but is of unspecified
      // quality.
      var rnds = new Array(16);

      module.exports = function mathRNG() {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
          rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
        }

        return rnds;
      };
    }
  });

  /**
   * Convert array of 16 byte values to UUID string format of the form:
   * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   */
  var byteToHex = [];

  for (var i = 0; i < 256; ++i) {
    byteToHex[i] = (i + 0x100).toString(16).substr(1);
  }

  function bytesToUuid(buf, offset) {
    var i = offset || 0;
    var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4

    return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');
  }

  var bytesToUuid_1 = bytesToUuid;

  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  var _nodeId;

  var _clockseq; // Previous uuid creation time


  var _lastMSecs = 0;
  var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];
    options = options || {};
    var node = options.node || _nodeId;
    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
    // specified.  We do this lazily to minimize issues related to insufficient
    // system entropy.  See #189

    if (node == null || clockseq == null) {
      var seedBytes = rngBrowser();

      if (node == null) {
        // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
        node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }

      if (clockseq == null) {
        // Per 4.2.2, randomize (14 bit) clockseq
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
      }
    } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


    var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock

    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 0x3fff;
    } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval


    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    } // Per 4.2.1.2 Throw error if too many uuids are requested


    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

    msecs += 12219292800000; // `time_low`

    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff; // `time_mid`

    var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff; // `time_high_and_version`

    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

    b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

    b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

    b[i++] = clockseq & 0xff; // `node`

    for (var n = 0; n < 6; ++n) {
      b[i + n] = node[n];
    }

    return buf ? buf : bytesToUuid_1(b);
  }

  var v1_1 = v1;

  function v4$1(options, buf, offset) {
    var i = buf && offset || 0;

    if (typeof options == 'string') {
      buf = options === 'binary' ? new Array(16) : null;
      options = null;
    }

    options = options || {};
    var rnds = options.random || (options.rng || rngBrowser)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

    if (buf) {
      for (var ii = 0; ii < 16; ++ii) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || bytesToUuid_1(rnds);
  }

  var v4_1 = v4$1;

  var uuid = v4_1;
  uuid.v1 = v1_1;
  uuid.v4 = v4_1;
  var uuid_1 = uuid;

  var uuid$1 = uuid_1.v4;
  var inMemoryStore = {
    _data: {},
    length: 0,
    setItem: function setItem(key, value) {
      this._data[key] = value;
      this.length = keys_1(this._data).length;
      return value;
    },
    getItem: function getItem(key) {
      if (key in this._data) {
        return this._data[key];
      }

      return null;
    },
    removeItem: function removeItem(key) {
      if (key in this._data) {
        delete this._data[key];
      }

      this.length = keys_1(this._data).length;
      return null;
    },
    clear: function clear() {
      this._data = {};
      this.length = 0;
    },
    key: function key(index) {
      return keys_1(this._data)[index];
    }
  };

  function isSupportedNatively() {
    try {
      if (!window.localStorage) return false;
      var key = uuid$1();
      window.localStorage.setItem(key, 'test_value');
      var value = window.localStorage.getItem(key);
      window.localStorage.removeItem(key); // handle localStorage silently failing

      return value === 'test_value';
    } catch (e) {
      // Can throw if localStorage is disabled
      return false;
    }
  }

  function pickStorage() {
    if (isSupportedNatively()) {
      return window.localStorage;
    } // fall back to in-memory


    return inMemoryStore;
  } // Return a shared instance


  var defaultEngine = pickStorage(); // Expose the in-memory store explicitly for testing

  var inMemoryEngine = inMemoryStore;
  var engine = {
    defaultEngine: defaultEngine,
    inMemoryEngine: inMemoryEngine
  };

  var defaultEngine$1 = engine.defaultEngine;
  var inMemoryEngine$1 = engine.inMemoryEngine;
  var json = JSON;
  /**
  * Store Implementation with dedicated
  */

  function Store$1(name, id, keys, optionalEngine) {
    this.id = id;
    this.name = name;
    this.keys = keys || {};
    this.engine = optionalEngine || defaultEngine$1;
    this.originalEngine = this.engine;
  }
  /**
  * Set value by key.
  */


  Store$1.prototype.set = function (key, value) {
    var compoundKey = this._createValidKey(key);

    if (!compoundKey) return;

    try {
      this.engine.setItem(compoundKey, json.stringify(value));
    } catch (err) {
      if (isQuotaExceeded(err)) {
        // switch to inMemory engine
        this._swapEngine(); // and save it there


        this.set(key, value);
      }
    }
  };
  /**
  * Get by Key.
  */


  Store$1.prototype.get = function (key) {
    try {
      var str = this.engine.getItem(this._createValidKey(key));

      if (str === null) {
        return null;
      }

      return json.parse(str);
    } catch (err) {
      return null;
    }
  };
  /**
   * Get original engine
   */


  Store$1.prototype.getOriginalEngine = function () {
    return this.originalEngine;
  };
  /**
  * Remove by Key.
  */


  Store$1.prototype.remove = function (key) {
    this.engine.removeItem(this._createValidKey(key));
  };
  /**
  * Ensure the key is valid
  */


  Store$1.prototype._createValidKey = function (key) {
    var name = this.name;
    var id = this.id;
    if (!keys_1(this.keys).length) return [name, id, key].join('.'); // validate and return undefined if invalid key

    var compoundKey;
    each_1(function (value) {
      if (value === key) {
        compoundKey = [name, id, key].join('.');
      }
    }, this.keys);
    return compoundKey;
  };
  /**
  * Switch to inMemoryEngine, bringing any existing data with.
  */


  Store$1.prototype._swapEngine = function () {
    var self = this; // grab existing data, but only for this page's queue instance, not all
    // better to keep other queues in localstorage to be flushed later
    // than to pull them into memory and remove them from durable storage

    each_1(function (key) {
      var value = self.get(key);
      inMemoryEngine$1.setItem([self.name, self.id, key].join('.'), value);
      self.remove(key);
    }, this.keys);
    this.engine = inMemoryEngine$1;
  };

  var store$1 = Store$1;

  function isQuotaExceeded(e) {
    var quotaExceeded = false;

    if (e.code) {
      switch (e.code) {
        case 22:
          quotaExceeded = true;
          break;

        case 1014:
          // Firefox
          if (e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
            quotaExceeded = true;
          }

          break;
      }
    } else if (e.number === -2147024882) {
      // Internet Explorer 8
      quotaExceeded = true;
    }

    return quotaExceeded;
  }

  var CLOCK_LATE_FACTOR = 2;
  var defaultClock = {
    setTimeout: function setTimeout(fn, ms) {
      return window.setTimeout(fn, ms);
    },
    clearTimeout: function clearTimeout(id) {
      return window.clearTimeout(id);
    },
    Date: window.Date
  };
  var clock = defaultClock;
  var modes = {
    ASAP: 1,
    RESCHEDULE: 2,
    ABANDON: 3
  };

  function Schedule() {
    this.tasks = {};
    this.nextId = 1;
  }

  Schedule.prototype.now = function () {
    return +new clock.Date();
  };

  Schedule.prototype.run = function (task, timeout, mode) {
    var id = this.nextId++;
    this.tasks[id] = clock.setTimeout(this._handle(id, task, timeout, mode || modes.ASAP), timeout);
    return id;
  };

  Schedule.prototype.cancel = function (id) {
    if (this.tasks[id]) {
      clock.clearTimeout(this.tasks[id]);
      delete this.tasks[id];
    }
  };

  Schedule.prototype.cancelAll = function () {
    each_1(clock.clearTimeout, this.tasks);
    this.tasks = {};
  };

  Schedule.prototype._handle = function (id, callback, timeout, mode) {
    var self = this;
    var start = self.now();
    return function () {
      delete self.tasks[id];

      if (mode >= modes.RESCHEDULE && start + timeout * CLOCK_LATE_FACTOR < self.now()) {
        if (mode === modes.RESCHEDULE) {
          self.run(callback, timeout, mode);
        }

        return;
      }

      return callback();
    };
  };

  Schedule.setClock = function (newClock) {
    clock = newClock;
  };

  Schedule.resetClock = function () {
    clock = defaultClock;
  };

  Schedule.Modes = modes;
  var schedule = Schedule;

  /**
   * Expose `debug()` as the module.
   */
  var debug_1$2 = debug$3;
  /**
   * Create a debugger with the given `name`.
   *
   * @param {String} name
   * @return {Type}
   * @api public
   */

  function debug$3(name) {
    if (!debug$3.enabled(name)) return function () {};
    return function (fmt) {
      fmt = coerce(fmt);
      var curr = new Date();
      var ms = curr - (debug$3[name] || curr);
      debug$3[name] = curr;
      fmt = name + ' ' + fmt + ' +' + debug$3.humanize(ms); // This hackery is required for IE8
      // where `console.log` doesn't have 'apply'

      window.console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    };
  }
  /**
   * The currently active debug mode names.
   */


  debug$3.names = [];
  debug$3.skips = [];
  /**
   * Enables a debug mode by name. This can include modes
   * separated by a colon and wildcards.
   *
   * @param {String} name
   * @api public
   */

  debug$3.enable = function (name) {
    try {
      localStorage.debug = name;
    } catch (e) {}

    var split = (name || '').split(/[\s,]+/),
        len = split.length;

    for (var i = 0; i < len; i++) {
      name = split[i].replace('*', '.*?');

      if (name[0] === '-') {
        debug$3.skips.push(new RegExp('^' + name.substr(1) + '$'));
      } else {
        debug$3.names.push(new RegExp('^' + name + '$'));
      }
    }
  };
  /**
   * Disable debug output.
   *
   * @api public
   */


  debug$3.disable = function () {
    debug$3.enable('');
  };
  /**
   * Humanize the given `ms`.
   *
   * @param {Number} m
   * @return {String}
   * @api private
   */


  debug$3.humanize = function (ms) {
    var sec = 1000,
        min = 60 * 1000,
        hour = 60 * min;
    if (ms >= hour) return (ms / hour).toFixed(1) + 'h';
    if (ms >= min) return (ms / min).toFixed(1) + 'm';
    if (ms >= sec) return (ms / sec | 0) + 's';
    return ms + 'ms';
  };
  /**
   * Returns true if the given mode name is enabled, false otherwise.
   *
   * @param {String} name
   * @return {Boolean}
   * @api public
   */


  debug$3.enabled = function (name) {
    for (var i = 0, len = debug$3.skips.length; i < len; i++) {
      if (debug$3.skips[i].test(name)) {
        return false;
      }
    }

    for (var i = 0, len = debug$3.names.length; i < len; i++) {
      if (debug$3.names[i].test(name)) {
        return true;
      }
    }

    return false;
  };
  /**
   * Coerce `val`.
   */


  function coerce(val) {
    if (val instanceof Error) return val.stack || val.message;
    return val;
  } // persist


  try {
    if (window.localStorage) debug$3.enable(localStorage.debug);
  } catch (e) {}

  var componentEmitter$1 = createCommonjsModule(function (module) {
    /**
     * Expose `Emitter`.
     */
    {
      module.exports = Emitter;
    }
    /**
     * Initialize a new `Emitter`.
     *
     * @api public
     */


    function Emitter(obj) {
      if (obj) return mixin(obj);
    }
    /**
     * Mixin the emitter properties.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */

    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }

      return obj;
    }
    /**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */


    Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
      return this;
    };
    /**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */


    Emitter.prototype.once = function (event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }

      on.fn = fn;
      this.on(event, on);
      return this;
    };
    /**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */


    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
      this._callbacks = this._callbacks || {}; // all

      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      } // specific event


      var callbacks = this._callbacks['$' + event];
      if (!callbacks) return this; // remove all handlers

      if (1 == arguments.length) {
        delete this._callbacks['$' + event];
        return this;
      } // remove specific handler


      var cb;

      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];

        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      } // Remove event specific arrays for event types that no
      // one is subscribed for to avoid memory leak.


      if (callbacks.length === 0) {
        delete this._callbacks['$' + event];
      }

      return this;
    };
    /**
     * Emit `event` with the given args.
     *
     * @param {String} event
     * @param {Mixed} ...
     * @return {Emitter}
     */


    Emitter.prototype.emit = function (event) {
      this._callbacks = this._callbacks || {};
      var args = new Array(arguments.length - 1),
          callbacks = this._callbacks['$' + event];

      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }

      if (callbacks) {
        callbacks = callbacks.slice(0);

        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }

      return this;
    };
    /**
     * Return array of callbacks for `event`.
     *
     * @param {String} event
     * @return {Array}
     * @api public
     */


    Emitter.prototype.listeners = function (event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks['$' + event] || [];
    };
    /**
     * Check if this emitter has `event` handlers.
     *
     * @param {String} event
     * @return {Boolean}
     * @api public
     */


    Emitter.prototype.hasListeners = function (event) {
      return !!this.listeners(event).length;
    };
  });

  var require$$0 = getCjsExportFromNamespace(dist);

  var uuid$2 = require$$0.v4;
  var debug$4 = debug_1$2('localstorage-retry'); // Some browsers don't support Function.prototype.bind, so just including a simplified version here

  function bind(func, obj) {
    return function () {
      return func.apply(obj, arguments);
    };
  }
  /**
   * @callback processFunc
   * @param {Mixed} item The item added to the queue to process
   * @param {Function} done A function to call when processing is completed.
   *   @param {Error} Optional error parameter if the processing failed
   *   @param {Response} Optional response parameter to emit for async handling
   */

  /**
   * Constructs a Queue backed by localStorage
   *
   * @constructor
   * @param {String} name The name of the queue. Will be used to find abandoned queues and retry their items
   * @param {Object} [opts] Optional argument to override `maxItems`, `maxAttempts`, `minRetryDelay, `maxRetryDelay`, `backoffFactor` and `backoffJitter`.
   * @param {processFunc} fn The function to call in order to process an item added to the queue
   */


  function Queue(name, opts, fn) {
    if (typeof opts === 'function') fn = opts;
    this.name = name;
    this.id = uuid$2();
    this.fn = fn;
    this.maxItems = opts.maxItems || Infinity;
    this.maxAttempts = opts.maxAttempts || Infinity;
    this.backoff = {
      MIN_RETRY_DELAY: opts.minRetryDelay || 1000,
      MAX_RETRY_DELAY: opts.maxRetryDelay || 30000,
      FACTOR: opts.backoffFactor || 2,
      JITTER: opts.backoffJitter || 0
    }; // painstakingly tuned. that's why they're not "easily" configurable

    this.timeouts = {
      ACK_TIMER: 1000,
      RECLAIM_TIMER: 3000,
      RECLAIM_TIMEOUT: 10000,
      RECLAIM_WAIT: 500
    };
    this.keys = {
      IN_PROGRESS: 'inProgress',
      QUEUE: 'queue',
      RECLAIM_START: 'reclaimStart',
      RECLAIM_END: 'reclaimEnd',
      ACK: 'ack'
    };
    this._schedule = new schedule();
    this._processId = 0; // Set up our empty queues

    this._store = new store$1(this.name, this.id, this.keys);

    this._store.set(this.keys.IN_PROGRESS, {});

    this._store.set(this.keys.QUEUE, []); // bind recurring tasks for ease of use


    this._ack = bind(this._ack, this);
    this._checkReclaim = bind(this._checkReclaim, this);
    this._processHead = bind(this._processHead, this);
    this._running = false;
  }
  /**
   * Mix in event emitter
   */


  componentEmitter$1(Queue.prototype);
  /**
   * Starts processing the queue
   */

  Queue.prototype.start = function () {
    if (this._running) {
      this.stop();
    }

    this._running = true;

    this._ack();

    this._checkReclaim();

    this._processHead();
  };
  /**
   * Stops processing the queue
   */


  Queue.prototype.stop = function () {
    this._schedule.cancelAll();

    this._running = false;
  };
  /**
   * Decides whether to retry. Overridable.
   *
   * @param {Object} item The item being processed
   * @param {Number} attemptNumber The attemptNumber (1 for first retry)
   * @param {Error} error The error from previous attempt, if there was one
   * @return {Boolean} Whether to requeue the message
   */


  Queue.prototype.shouldRetry = function (_, attemptNumber) {
    if (attemptNumber > this.maxAttempts) return false;
    return true;
  };
  /**
   * Calculates the delay (in ms) for a retry attempt
   *
   * @param {Number} attemptNumber The attemptNumber (1 for first retry)
   * @return {Number} The delay in milliseconds to wait before attempting a retry
   */


  Queue.prototype.getDelay = function (attemptNumber) {
    var ms = this.backoff.MIN_RETRY_DELAY * Math.pow(this.backoff.FACTOR, attemptNumber);

    if (this.backoff.JITTER) {
      var rand = Math.random();
      var deviation = Math.floor(rand * this.backoff.JITTER * ms);

      if (Math.floor(rand * 10) < 5) {
        ms -= deviation;
      } else {
        ms += deviation;
      }
    }

    return Number(Math.min(ms, this.backoff.MAX_RETRY_DELAY).toPrecision(1));
  };
  /**
   * Adds an item to the queue
   *
   * @param {Mixed} item The item to process
   */


  Queue.prototype.addItem = function (item) {
    this._enqueue({
      item: item,
      attemptNumber: 0,
      time: this._schedule.now(),
      id: uuid$2()
    });
  };
  /**
   * Adds an item to the retry queue
   *
   * @param {Mixed} item The item to retry
   * @param {Number} attemptNumber The attempt number (1 for first retry)
   * @param {Error} [error] The error from previous attempt, if there was one
   * @param {String} [id] The id of the queued message used for tracking duplicate entries
   */


  Queue.prototype.requeue = function (item, attemptNumber, error, id) {
    if (this.shouldRetry(item, attemptNumber, error)) {
      this._enqueue({
        item: item,
        attemptNumber: attemptNumber,
        time: this._schedule.now() + this.getDelay(attemptNumber),
        id: id || uuid$2()
      });
    } else {
      this.emit('discard', item, attemptNumber);
    }
  };

  Queue.prototype._enqueue = function (entry) {
    var queue = this._store.get(this.keys.QUEUE) || [];
    queue = queue.slice(-(this.maxItems - 1));
    queue.push(entry);
    queue = queue.sort(function (a, b) {
      return a.time - b.time;
    });

    this._store.set(this.keys.QUEUE, queue);

    if (this._running) {
      this._processHead();
    }
  };

  Queue.prototype._processHead = function () {
    var self = this;
    var store = this._store; // cancel the scheduled task if it exists

    this._schedule.cancel(this._processId); // Pop the head off the queue


    var queue = store.get(this.keys.QUEUE) || [];
    var inProgress = store.get(this.keys.IN_PROGRESS) || {};

    var now = this._schedule.now();

    var toRun = [];

    function enqueue(el, id) {
      toRun.push({
        item: el.item,
        done: function handle(err, res) {
          var inProgress = store.get(self.keys.IN_PROGRESS) || {};
          delete inProgress[id];
          store.set(self.keys.IN_PROGRESS, inProgress);
          self.emit('processed', err, res, el.item);

          if (err) {
            self.requeue(el.item, el.attemptNumber + 1, err, el.id);
          }
        }
      });
    }

    var inProgressSize = Object.keys(inProgress).length;

    while (queue.length && queue[0].time <= now && inProgressSize++ < self.maxItems) {
      var el = queue.shift();
      var id = uuid$2(); // Save this to the in progress map

      inProgress[id] = {
        item: el.item,
        attemptNumber: el.attemptNumber,
        time: self._schedule.now()
      };
      enqueue(el, id);
    }

    store.set(this.keys.QUEUE, queue);
    store.set(this.keys.IN_PROGRESS, inProgress);
    each_1(function (el) {
      // TODO: handle fn timeout
      try {
        self.fn(el.item, el.done);
      } catch (err) {
        debug$4('Process function threw error: ' + err);
      }
    }, toRun); // re-read the queue in case the process function finished immediately or added another item

    queue = store.get(this.keys.QUEUE) || [];

    this._schedule.cancel(this._processId);

    if (queue.length > 0) {
      this._processId = this._schedule.run(this._processHead, queue[0].time - now, schedule.Modes.ASAP);
    }
  }; // Ack continuously to prevent other tabs from claiming our queue


  Queue.prototype._ack = function () {
    this._store.set(this.keys.ACK, this._schedule.now());

    this._store.set(this.keys.RECLAIM_START, null);

    this._store.set(this.keys.RECLAIM_END, null);

    this._schedule.run(this._ack, this.timeouts.ACK_TIMER, schedule.Modes.ASAP);
  };

  Queue.prototype._checkReclaim = function () {
    var self = this;

    function tryReclaim(store) {
      store.set(self.keys.RECLAIM_START, self.id);
      store.set(self.keys.ACK, self._schedule.now());

      self._schedule.run(function () {
        if (store.get(self.keys.RECLAIM_START) !== self.id) return;
        store.set(self.keys.RECLAIM_END, self.id);

        self._schedule.run(function () {
          if (store.get(self.keys.RECLAIM_END) !== self.id) return;
          if (store.get(self.keys.RECLAIM_START) !== self.id) return;

          self._reclaim(store.id);
        }, self.timeouts.RECLAIM_WAIT, schedule.Modes.ABANDON);
      }, self.timeouts.RECLAIM_WAIT, schedule.Modes.ABANDON);
    }

    function findOtherQueues(name) {
      var res = [];

      var storage = self._store.getOriginalEngine();

      for (var i = 0; i < storage.length; i++) {
        var k = storage.key(i);
        var parts = k.split('.');
        if (parts.length !== 3) continue;
        if (parts[0] !== name) continue;
        if (parts[2] !== 'ack') continue;
        res.push(new store$1(name, parts[1], self.keys));
      }

      return res;
    }

    each_1(function (store) {
      if (store.id === self.id) return;
      if (self._schedule.now() - store.get(self.keys.ACK) < self.timeouts.RECLAIM_TIMEOUT) return;
      tryReclaim(store);
    }, findOtherQueues(this.name));

    this._schedule.run(this._checkReclaim, this.timeouts.RECLAIM_TIMER, schedule.Modes.RESCHEDULE);
  };

  Queue.prototype._reclaim = function (id) {
    var self = this;
    var other = new store$1(this.name, id, this.keys);
    var our = {
      queue: this._store.get(this.keys.QUEUE) || []
    };
    var their = {
      inProgress: other.get(this.keys.IN_PROGRESS) || {},
      queue: other.get(this.keys.QUEUE) || []
    };
    var trackMessageIds = [];

    var addConcatQueue = function addConcatQueue(queue, incrementAttemptNumberBy) {
      each_1(function (el) {
        var id = el.id || uuid$2();

        if (trackMessageIds.indexOf(id) >= 0) {
          self.emit('duplication', el.item, el.attemptNumber);
        } else {
          our.queue.push({
            item: el.item,
            attemptNumber: el.attemptNumber + incrementAttemptNumberBy,
            time: self._schedule.now(),
            id: id
          });
          trackMessageIds.push(id);
        }
      }, queue);
    }; // add their queue to ours, resetting run-time to immediate and copying the attempt#


    addConcatQueue(their.queue, 0); // if the queue is abandoned, all the in-progress are failed. retry them immediately and increment the attempt#

    addConcatQueue(their.inProgress, 1);
    our.queue = our.queue.sort(function (a, b) {
      return a.time - b.time;
    });

    this._store.set(this.keys.QUEUE, our.queue); // remove all keys


    other.remove(this.keys.IN_PROGRESS);
    other.remove(this.keys.QUEUE);
    other.remove(this.keys.RECLAIM_START);
    other.remove(this.keys.RECLAIM_END);
    other.remove(this.keys.ACK); // process the new items we claimed

    this._processHead();
  };

  var lib$2 = Queue;

  var queueOptions = {
    maxRetryDelay: 360000,
    minRetryDelay: 1000,
    backoffFactor: 2,
    maxAttempts: 10,
    maxItems: 100
  };

  var XHRQueue = /*#__PURE__*/function () {
    function XHRQueue() {
      _classCallCheck(this, XHRQueue);

      this.url = "";
      this.writeKey = "";
    }

    _createClass(XHRQueue, [{
      key: "init",
      value: function init(writeKey, url, options) {
        this.url = url;
        this.writeKey = writeKey;

        if (options) {
          // TODO: add checks for value - has to be +ve?
          _extends(queueOptions, options);
        }

        this.payloadQueue = new lib$2("rudder", queueOptions, function (item, done) {
          // apply sentAt at flush time and reset on each retry
          item.message.sentAt = getCurrentTimeFormatted(); // send this item for processing, with a callback to enable queue to get the done status
          // eslint-disable-next-line no-use-before-define

          this.processQueueElement(item.url, item.headers, item.message, 10 * 1000, // eslint-disable-next-line consistent-return
          function (err, res) {
            if (err) {
              return done(err);
            }

            done(null, res);
          });
        }.bind(this)); // start queue

        this.payloadQueue.start();
      }
      /**
       * the queue item proceesor
       * @param {*} url to send requests to
       * @param {*} headers
       * @param {*} message
       * @param {*} timeout
       * @param {*} queueFn the function to call after request completion
       */

    }, {
      key: "processQueueElement",
      value: function processQueueElement(url, headers, message, timeout, queueFn) {
        try {
          var xhr = new XMLHttpRequest();
          xhr.open("POST", url, true);

          for (var k in headers) {
            xhr.setRequestHeader(k, headers[k]);
          }

          xhr.timeout = timeout;
          xhr.ontimeout = queueFn;
          xhr.onerror = queueFn;

          xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
              if (xhr.status === 429 || xhr.status >= 500 && xhr.status < 600) {
                handleError(new Error("request failed with status: ".concat(xhr.status).concat(xhr.statusText, " for url: ").concat(url)));
                queueFn(new Error("request failed with status: ".concat(xhr.status).concat(xhr.statusText, " for url: ").concat(url)));
              } else {
                logger.debug("====== request processed successfully: ".concat(xhr.status));
                queueFn(null, xhr.status);
              }
            }
          };

          xhr.send(JSON.stringify(message, replacer));
        } catch (error) {
          queueFn(error);
        }
      }
    }, {
      key: "enqueue",
      value: function enqueue(message, type) {
        var headers = {
          "Content-Type": "application/json",
          Authorization: "Basic ".concat(btoa("".concat(this.writeKey, ":"))),
          AnonymousId: btoa(message.anonymousId)
        }; // add items to the queue

        this.payloadQueue.addItem({
          url: "".concat(this.url, "/v1/").concat(type),
          headers: headers,
          message: message
        });
      }
    }]);

    return XHRQueue;
  }();

  var defaults$3 = {
    queue: "queue",
    maxPayloadSize: 64 * 1000
  };

  var BeaconQueue = /*#__PURE__*/function () {
    function BeaconQueue() {
      _classCallCheck(this, BeaconQueue);

      this.storage = Store;
      this.maxItems = 10;
      this.flushQueueTimeOut = undefined;
      this.timeOutActive = false;
      this.flushQueueTimeOutInterval = 1000 * 60 * 10; // 10 mins

      this.url = "";
      this.writekey = "";
      this.queueName = "".concat(defaults$3.queue, ".").concat(Date.now());
    }

    _createClass(BeaconQueue, [{
      key: "sendQueueDataForBeacon",
      value: function sendQueueDataForBeacon() {
        this.sendDataFromQueueAndDestroyQueue();
      }
    }, {
      key: "init",
      value: function init(writekey, url, options) {
        this.url = url;
        this.writekey = writekey;
        if (options.maxItems) this.maxItems = options.maxItems;
        if (options.flushQueueInterval) this.flushQueueTimeOutInterval = options.flushQueueInterval;
        var sendQueueData = this.sendQueueDataForBeacon.bind(this);
        window.addEventListener("unload", sendQueueData);
      }
    }, {
      key: "getQueue",
      value: function getQueue() {
        return this.storage.get(this.queueName);
      }
    }, {
      key: "setQueue",
      value: function setQueue(value) {
        this.storage.set(this.queueName, value);
      }
      /**
       *
       * Utility method for excluding null and empty values in JSON
       * @param {*} _key
       * @param {*} value
       * @returns
       */

    }, {
      key: "replacer",
      value: function replacer(_key, value) {
        if (value === null || value === undefined) {
          return undefined;
        }

        return value;
      }
    }, {
      key: "enqueue",
      value: function enqueue(message) {
        var queue = this.getQueue() || [];
        queue = queue.slice(-(this.maxItems - 1));
        queue.push(message);
        var batch = queue.slice(0);
        var data = {
          batch: batch
        };
        var dataToSend = JSON.stringify(data, this.replacer);

        if (dataToSend.length > defaults$3.maxPayloadSize) {
          batch = queue.slice(0, queue.length - 1);
          this.flushQueue(batch);
          queue = this.getQueue();
          queue.push(message);
        }

        this.setQueue(queue);
        this.setTimer();

        if (queue.length === this.maxItems) {
          this.flushQueue(batch);
        }
      }
    }, {
      key: "sendDataFromQueueAndDestroyQueue",
      value: function sendDataFromQueueAndDestroyQueue() {
        this.sendDataFromQueue();
        this.storage.remove(this.queueName);
      }
    }, {
      key: "sendDataFromQueue",
      value: function sendDataFromQueue() {
        var queue = this.getQueue();

        if (queue && queue.length > 0) {
          var batch = queue.slice(0, queue.length);
          this.flushQueue(batch);
        }
      }
    }, {
      key: "flushQueue",
      value: function flushQueue(batch) {
        batch.map(function (event) {
          event.sentAt = new Date().toISOString();
        });
        var data = {
          batch: batch
        };
        var payload = JSON.stringify(data, this.replacer);
        var blob = new Blob([payload], {
          type: "text/plain"
        });
        var isPushed = navigator.sendBeacon("".concat(this.url, "?writeKey=").concat(this.writekey), blob);

        if (!isPushed) {
          logger.debug("Unable to send data");
        }

        this.setQueue([]);
        this.clearTimer();
      }
    }, {
      key: "setTimer",
      value: function setTimer() {
        if (!this.timeOutActive) {
          this.flushQueueTimeOut = setTimeout(this.sendDataFromQueue.bind(this), this.flushQueueTimeOutInterval);
          this.timeOutActive = true;
        }
      }
    }, {
      key: "clearTimer",
      value: function clearTimer() {
        if (this.timeOutActive) {
          clearTimeout(this.flushQueueTimeOut);
          this.timeOutActive = false;
        }
      }
    }]);

    return BeaconQueue;
  }();

  var MESSAGE_LENGTH = 32 * 1000; // ~32 Kb

  /**
   *
   * @class EventRepository responsible for adding events into
   * flush queue and sending data to rudder backend
   * in batch and maintains order of the event.
   */

  var EventRepository = /*#__PURE__*/function () {
    /**
     *Creates an instance of EventRepository.
     * @memberof EventRepository
     */
    function EventRepository() {
      _classCallCheck(this, EventRepository);

      this.queue = undefined;
    }

    _createClass(EventRepository, [{
      key: "initialize",
      value: function initialize(writeKey, url, options) {
        var queueOptions = {};
        var targetUrl = url.slice(-1) === "/" ? url.slice(0, -1) : url;

        if (options && options.useBeacon && navigator.sendBeacon) {
          if (options && options.beaconQueueOptions && options.beaconQueueOptions != null && _typeof(options.beaconQueueOptions) === "object") {
            queueOptions = options.beaconQueueOptions;
          }

          targetUrl = "".concat(targetUrl, "/beacon/v1/batch");
          this.queue = new BeaconQueue();
        } else {
          if (options && options.useBeacon) {
            logger.info("[EventRepository] sendBeacon feature not available in this browser :: fallback to XHR");
          }

          if (options && options.queueOptions && options.queueOptions != null && _typeof(options.queueOptions) === "object") {
            queueOptions = options.queueOptions;
          }

          this.queue = new XHRQueue();
        }

        this.queue.init(writeKey, targetUrl, queueOptions);
      }
      /**
       *
       *
       * @param {RudderElement} rudderElement
       * @memberof EventRepository
       */

    }, {
      key: "enqueue",
      value: function enqueue(rudderElement, type) {
        var message = rudderElement.getElementContent();
        message.originalTimestamp = message.originalTimestamp || getCurrentTimeFormatted();
        message.sentAt = getCurrentTimeFormatted(); // add this, will get modified when actually being sent
        // check message size, if greater log an error

        if (JSON.stringify(message).length > MESSAGE_LENGTH) {
          logger.error("[EventRepository] enqueue:: message length greater 32 Kb ", message);
        }

        this.queue.enqueue(message, type);
      }
    }]);

    return EventRepository;
  }();

  var eventRepository = new EventRepository(); // eslint-disable-next-line import/prefer-default-export

  function addDomEventHandlers(rudderanalytics) {
    var handler = function handler(e) {
      e = e || window.event;
      var target = e.target || e.srcElement;

      if (isTextNode(target)) {
        target = target.parentNode;
      }

      if (shouldTrackDomEvent(target, e)) {
        logger.debug('to be tracked ', e.type);
      } else {
        logger.debug('not to be tracked ', e.type);
      }

      trackWindowEvent(e, rudderanalytics);
    };

    register_event(document, 'submit', handler, true);
    register_event(document, 'change', handler, true);
    register_event(document, 'click', handler, true);
    rudderanalytics.page();
  }

  function register_event(element, type, handler, useCapture) {
    if (!element) {
      logger.error('[Autotrack] register_event:: No valid element provided to register_event');
      return;
    }

    element.addEventListener(type, handler, !!useCapture);
  }

  function shouldTrackDomEvent(el, event) {
    if (!el || isTag(el, 'html') || !isElementNode(el)) {
      return false;
    }

    var tag = el.tagName.toLowerCase();

    switch (tag) {
      case 'html':
        return false;

      case 'form':
        return event.type === 'submit';

      case 'input':
        if (['button', 'submit'].indexOf(el.getAttribute('type')) === -1) {
          return event.type === 'change';
        }

        return event.type === 'click';

      case 'select':
      case 'textarea':
        return event.type === 'change';

      default:
        return event.type === 'click';
    }
  }

  function isTag(el, tag) {
    return el && el.tagName && el.tagName.toLowerCase() === tag.toLowerCase();
  }

  function isElementNode(el) {
    return el && el.nodeType === 1; // Node.ELEMENT_NODE - use integer constant for browser portability
  }

  function isTextNode(el) {
    return el && el.nodeType === 3; // Node.TEXT_NODE - use integer constant for browser portability
  } // excerpt from https://github.com/mixpanel/mixpanel-js/blob/master/src/autotrack-utils.js


  function shouldTrackElement(el) {
    if (!el.parentNode || isTag(el, 'body')) return false;
    var curEl = el;

    while (curEl.parentNode && !isTag(curEl, 'body')) {
      var _classes = getClassName(el).split(' '); // if explicitly specified "rudder-no-track", even at parent level, dont track the child nodes too.


      if (_classes.indexOf('rudder-no-track') >= 0) {
        return false;
      }

      curEl = curEl.parentNode;
    } // if explicitly set "rudder-include", at element level, then track the element even if the element is hidden or sensitive.


    var classes = getClassName(el).split(' ');

    if (classes.indexOf('rudder-include') >= 0) {
      return true;
    } // for general elements, do not track input/select/textarea(s)


    if (isTag(el, 'input') || isTag(el, 'select') || isTag(el, 'textarea') || el.getAttribute('contenteditable') === 'true') {
      return false;
    } else if (el.getAttribute('contenteditable') === 'inherit') {
      for (curEl = el.parentNode; curEl.parentNode && !isTag(curEl, 'body'); curEl = curEl.parentNode) {
        if (curEl.getAttribute('contenteditable') === 'true') {
          return false;
        }
      }
    } // do not track hidden/password elements


    var type = el.type || '';

    if (typeof type === 'string') {
      // it's possible for el.type to be a DOM element if el is a form with a child input[name="type"]
      switch (type.toLowerCase()) {
        case 'hidden':
          return false;

        case 'password':
          return false;
      }
    } // filter out data from fields that look like sensitive field -
    // safeguard - match with regex with possible strings as id or name of an element for creditcard, password, ssn, pan, adhar


    var name = el.name || el.id || '';

    if (typeof name === 'string') {
      // it's possible for el.name or el.id to be a DOM element if el is a form with a child input[name="name"]
      var sensitiveNameRegex = /^adhar|cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pan|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i;

      if (sensitiveNameRegex.test(name.replace(/[^a-zA-Z0-9]/g, ''))) {
        return false;
      }
    }

    return true;
  }

  function getClassName(el) {
    switch (_typeof(el.className)) {
      case 'string':
        return el.className;

      case 'object':
        // handle cases where className might be SVGAnimatedString or some other type
        return el.className.baseVal || el.getAttribute('class') || '';

      default:
        // future proof
        return '';
    }
  }

  function trackWindowEvent(e, rudderanalytics) {
    var target = e.target || e.srcElement;
    var formValues;

    if (isTextNode(target)) {
      target = target.parentNode;
    }

    if (shouldTrackDomEvent(target, e)) {
      if (target.tagName.toLowerCase() == 'form') {
        formValues = {};

        for (var i = 0; i < target.elements.length; i++) {
          var formElement = target.elements[i];

          if (shouldTrackElement(formElement) && isValueToBeTrackedFromTrackingList(formElement, rudderanalytics.trackValues)) {
            var name = formElement.id ? formElement.id : formElement.name;

            if (name && typeof name === 'string') {
              var key = formElement.id ? formElement.id : formElement.name; // formElement.value gives the same thing

              var value = formElement.id ? document.getElementById(formElement.id).value : document.getElementsByName(formElement.name)[0].value;

              if (formElement.type === 'checkbox' || formElement.type === 'radio') {
                value = formElement.checked;
              }

              if (key.trim() !== '') {
                formValues[encodeURIComponent(key)] = encodeURIComponent(value);
              }
            }
          }
        }
      }

      var targetElementList = [];
      var curEl = target;

      if (isExplicitNoTrack(curEl)) {
        return false;
      }

      while (curEl.parentNode && !isTag(curEl, 'body')) {
        if (shouldTrackElement(curEl)) {
          targetElementList.push(curEl);
        }

        curEl = curEl.parentNode;
      }

      var elementsJson = [];
      var href;
      targetElementList.forEach(function (el) {
        // if the element or a parent element is an anchor tag
        // include the href as a property
        if (el.tagName.toLowerCase() === 'a') {
          href = el.getAttribute('href');
          href = isValueToBeTracked(href) && href;
        }

        elementsJson.push(getPropertiesFromElement(el, rudderanalytics));
      });

      if (targetElementList && targetElementList.length == 0) {
        return false;
      }

      var elementText = '';
      var text = getText(target);

      if (text && text.length) {
        elementText = text;
      }

      var props = {
        event_type: e.type,
        page: getDefaultPageProperties(),
        elements: elementsJson,
        el_attr_href: href,
        el_text: elementText
      };

      if (formValues) {
        props.form_values = formValues;
      }

      logger.debug('web_event', props);
      rudderanalytics.track('autotrack', props);
      return true;
    }
  }

  function isExplicitNoTrack(el) {
    var classes = getClassName(el).split(' ');

    if (classes.indexOf('rudder-no-track') >= 0) {
      return true;
    }

    return false;
  } // excerpt from https://github.com/mixpanel/mixpanel-js/blob/master/src/autotrack-utils.js


  function isValueToBeTracked(value) {
    if (value === null || value === undefined) {
      return false;
    }

    if (typeof value === 'string') {
      value = value.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''); // check to see if input value looks like a credit card number
      // see: https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9781449327453/ch04s20.html

      var ccRegex = /^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/;

      if (ccRegex.test((value || '').replace(/[- ]/g, ''))) {
        return false;
      } // check to see if input value looks like a social security number


      var ssnRegex = /(^\d{3}-?\d{2}-?\d{4}$)/;

      if (ssnRegex.test(value)) {
        return false;
      } // check to see if input value looks like a adhar number


      var adharRegex = /(^\d{4}-?\d{4}-?\d{4}$)/;

      if (adharRegex.test(value)) {
        return false;
      } // check to see if input value looks like a PAN number


      var panRegex = /(^\w{5}-?\d{4}-?\w{1}$)/;

      if (panRegex.test(value)) {
        return false;
      }
    }

    return true;
  } // if the element name is provided in the valTrackingList while loading rudderanalytics, track the value.

  /**
   *
   * @param {*} el
   * @param {*} includeList - valTrackingList provided in rudderanalytics.load()
   */


  function isValueToBeTrackedFromTrackingList(el, includeList) {
    var elAttributesLength = el.attributes.length;

    for (var i = 0; i < elAttributesLength; i++) {
      var value = el.attributes[i].value;

      if (includeList.indexOf(value) > -1) {
        return true;
      }
    }

    return false;
  }

  function getText(el) {
    var text = '';
    el.childNodes.forEach(function (value) {
      if (value.nodeType === Node.TEXT_NODE) {
        var textContent = value.nodeValue.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''); // take each word from the text content and check whether the value should be tracked. Also, replace the whitespaces.

        var textValue = textContent.split(/(\s+)/).filter(isValueToBeTracked).join('').replace(/[\r\n]/g, ' ');
        text += textValue;
      }
    });
    return text.trim();
  }

  function getPropertiesFromElement(elem, rudderanalytics) {
    var props = {
      classes: getClassName(elem).split(' '),
      tag_name: elem.tagName.toLowerCase()
    };
    var attrLength = elem.attributes.length;

    for (var i = 0; i < attrLength; i++) {
      var name = elem.attributes[i].name;
      var value = elem.attributes[i].value;

      if (value && isValueToBeTracked(value)) {
        props["attr__".concat(name)] = value;
      }

      if ((name == 'name' || name == 'id') && isValueToBeTrackedFromTrackingList(elem, rudderanalytics.trackValues)) {
        props.field_value = name == 'id' ? document.getElementById(value).value : document.getElementsByName(value)[0].value;

        if (elem.type === 'checkbox' || elem.type === 'radio') {
          props.field_value = elem.checked;
        }
      }
    }

    var nthChild = 1;
    var nthOfType = 1;
    var currentElem = elem;

    while (currentElem = previousElementSibling(currentElem)) {
      nthChild++;

      if (currentElem.tagName === elem.tagName) {
        nthOfType++;
      }
    }

    props.nth_child = nthChild;
    props.nth_of_type = nthOfType;
    return props;
  }

  function previousElementSibling(el) {
    if (el.previousElementSibling) {
      return el.previousElementSibling;
    }

    do {
      el = el.previousSibling;
    } while (el && !isElementNode(el));

    return el;
  }

  /**
   * @description This is utility function for crc32 algorithm
   * @version v1.0.0 
   */

  /**
   * @description generate crc table
   * @params none
   * @returns arrray of CRC table
   */
  var makeCRCTable = function makeCRCTable() {
    var crcTable = [];
    var c;

    for (var n = 0; n < 256; n++) {
      c = n;

      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;
      }

      crcTable[n] = c;
    }

    return crcTable;
  };
  /**
   * 
   * @param {string} str
   * @returns {Bystream} crc32
   */


  var crc32 = function crc32(str) {
    var crcTable = makeCRCTable();
    var crc = 0 ^ -1;

    for (var i = 0; i < str.length; i++) {
      crc = crc >>> 8 ^ crcTable[(crc ^ str.charCodeAt(i)) & 0xff];
    }

    return (crc ^ -1) >>> 0;
  };

  /**
   * @description An interface to fetch user device details.
   * @version v1.0.0
   */
  var USER_INTERFACE = {
    /**
     * @param {*} req
     * @returns {string} user language
     */
    getUserLanguage: function getUserLanguage() {
      return navigator && navigator.language;
    },

    /** 
     * @param {*} req 
     * @returns {string} userAgent
     */
    getUserAgent: function getUserAgent() {
      return navigator && navigator.userAgent;
    }
  };

  /**
   * @description This is utility function for decoding from base 64 to utf8
   * @version v1.0.0 
   */

  /**
   * @param {string} str base64
   * @returns {string} utf8 
   */
  function b64DecodeUnicode(str) {
    // Going backwards: from bytestream, to percent-encoding, to original string.
    return decodeURIComponent(atob(str).split('').map(function (c) {
      return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));
  }
  /**
   * @param {string} value
   * @return {string}
   */


  function decode$3() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    data = data.endsWith("..") ? data.substr(0, data.length - 2) : data;
    return b64DecodeUnicode(data);
  }

  /**
   * @description AMP Linker Parser (works for Rudder, GA or any other linker created by following Google's linker standard.)
   * @version v1.0.0
   * @author Parth Mahajan, Ayush Mehra
   */
  var KEY_VALIDATOR = /^[a-zA-Z0-9\-_.]+$/;
  var CHECKSUM_OFFSET_MAX_MIN = 1;
  var VALID_VERSION = 1;
  var DELIMITER = "*";
  /**
   * Return the key value pairs
   * @param {string} value
   * @return {?Object<string, string>}
   */

  function parseLinker(value) {
    var linkerObj = parseLinkerParamValue(value);

    if (!linkerObj) {
      return null;
    }

    var checksum = linkerObj.checksum,
        serializedIds = linkerObj.serializedIds;

    if (!isCheckSumValid(serializedIds, checksum)) {
      return null;
    }

    return deserialize(serializedIds);
  }
  /**
   * Parse the linker param value to version checksum and serializedParams
   * @param {string} value
   * @return {?Object}
   */


  function parseLinkerParamValue(value) {
    var parts = value.split(DELIMITER);
    var isEven = parts.length % 2 == 0;

    if (parts.length < 4 || !isEven) {
      // Format <version>*<checksum>*<key1>*<value1>
      // Note: linker makes sure there's at least one pair of non empty key value
      // Make sure there is at least three delimiters.
      return null;
    }

    var version = Number(parts.shift());

    if (version !== VALID_VERSION) {
      return null;
    }

    var checksum = parts.shift();
    var serializedIds = parts.join(DELIMITER);
    return {
      checksum: checksum,
      serializedIds: serializedIds
    };
  }
  /**
   * Check if the checksum is valid with time offset tolerance.
   * @param {string} serializedIds
   * @param {string} checksum
   * @return {boolean}
   */


  function isCheckSumValid(serializedIds, checksum) {
    var userAgent = USER_INTERFACE.getUserAgent();
    var language = USER_INTERFACE.getUserLanguage();

    for (var i = 0; i <= CHECKSUM_OFFSET_MAX_MIN; i++) {
      var calculateCheckSum = getCheckSum(serializedIds, i, userAgent, language);

      if (calculateCheckSum == checksum) {
        return true;
      }
    }

    return false;
  }
  /**
   * Deserialize the serializedIds and return keyValue pairs.
   * @param {string} serializedIds
   * @return {!Object<string, string>}
   */


  function deserialize(serializedIds) {
    var keyValuePairs = {};
    var params = serializedIds.split(DELIMITER);

    for (var i = 0; i < params.length; i += 2) {
      var key = params[i];
      var valid = KEY_VALIDATOR.test(key);

      if (!valid) {
        continue;
      }

      var value = decode$3(params[i + 1]); //const value = params[i + 1];

      keyValuePairs[key] = value;
    }

    return keyValuePairs;
  }
  /**
   * Create a unique checksum hashing the fingerprint and a few other values.
   * @param {string} serializedIds
   * @param {number=} opt_offsetMin
   * @return {string}
   */


  function getCheckSum(serializedIds, opt_offsetMin, userAgent, language) {
    var fingerprint = getFingerprint(userAgent, language);
    var offset = opt_offsetMin || 0;
    var timestamp = getMinSinceEpoch() - offset;
    var crc = crc32([fingerprint, timestamp, serializedIds].join(DELIMITER)); // Encoded to base36 for less bytes.

    return crc.toString(36);
  }
  /**
   * Generates a semi-unique value for page visitor.
   * @return {string}
   */


  function getFingerprint(userAgent, language) {
    var date = new Date();
    var timezone = date.getTimezoneOffset();
    return [userAgent, timezone, language].join(DELIMITER);
  }
  /**
   * Rounded time used to check if t2 - t1 is within our time tolerance.
   * @return {number}
   */


  function getMinSinceEpoch() {
    // Timestamp in minutes, floored.
    return Math.floor(Date.now() / 60000);
  }

  /* eslint-disable class-methods-use-this */

  var OneTrust = /*#__PURE__*/function () {
    function OneTrust(sourceConfig) {
      var _this = this;

      _classCallCheck(this, OneTrust);

      this.sourceConfig = sourceConfig; // If user does not load onetrust sdk before loading rudderstack sdk
      // we will not be filtering any of the destinations.

      if (!window.OneTrust || !window.OnetrustActiveGroups) {
        throw new Error("OneTrust resources are not accessible. Thus all the destinations will be loaded");
      } // OneTrust Cookie Compliance populates a data layer object OnetrustActiveGroups with
      // the cookie categories that the user has consented to.
      // Eg: ',C0001,C0003,'
      // We split it and save it as an array.


      var userSetConsentGroupIds = window.OnetrustActiveGroups.split(","); // Ids user has consented
      // Get information about the cookie script - data includes, consent models, cookies in preference centre, etc.
      // We get the groups(cookie categorization), user has created in one trust account.

      var oneTrustAllGroupsInfo = window.OneTrust.GetDomainData().Groups;
      this.userSetConsentGroupNames = []; // Get the names of the cookies consented by the user in the browser.

      oneTrustAllGroupsInfo.forEach(function (group) {
        var CustomGroupId = group.CustomGroupId,
            GroupName = group.GroupName;

        if (userSetConsentGroupIds.includes(CustomGroupId)) {
          _this.userSetConsentGroupNames.push(GroupName.toUpperCase().trim());
        }
      });
    }

    _createClass(OneTrust, [{
      key: "isEnabled",
      value: function isEnabled(destConfig) {
        var _this2 = this;

        try {
          /**
          * Structure of onetrust consent group destination config.
          * 
          * "oneTrustConsentGroup": [
                            {
                                "oneTrustConsentGroup": "Performance Cookies"
                            },
                            {
                                "oneTrustConsentGroup": "Functional Cookies"
                            },
                            {
                                "oneTrustConsentGroup": ""
                            }
                        ]
          *
          */
          var oneTrustCookieCategories = destConfig.oneTrustCookieCategories; // mapping of the destination with the consent group name
          // If the destination do not have this mapping events will be sent.

          if (!oneTrustCookieCategories) {
            return true;
          } // Change the structure of oneTrustConsentGroup as an array and filter values if empty string
          // Eg:
          // ["Performance Cookies", "Functional Cookies"]


          var oneTrustConsentGroupArr = oneTrustCookieCategories.map(function (c) {
            return c.oneTrustCookieCategory;
          }).filter(function (n) {
            return n;
          });
          var containsAllConsent = true; // Check if all the destination's mapped cookie categories are consented by the user in the browser.

          containsAllConsent = oneTrustConsentGroupArr.every(function (element) {
            return _this2.userSetConsentGroupNames.includes(element.toUpperCase().trim());
          });
          return containsAllConsent;
        } catch (e) {
          logger.error("Error during onetrust cookie consent management ".concat(e));
          return true;
        }
      }
    }]);

    return OneTrust;
  }();

  var CookieConsentFactory = /*#__PURE__*/function () {
    function CookieConsentFactory() {
      _classCallCheck(this, CookieConsentFactory);
    }

    _createClass(CookieConsentFactory, null, [{
      key: "initialize",
      value: function initialize(cookieConsentOptions) {
        var _cookieConsentOptions;

        /**
         *
         * check which type of cookie consent manager needs to be called if enabled
         * for now we have only OneTrust.
         * But if new cookie consent manager options are implemented,
         * we need to make sure only one of them is enabled by the user in the
         * load options
         *
         */
        if (cookieConsentOptions !== null && cookieConsentOptions !== void 0 && (_cookieConsentOptions = cookieConsentOptions.oneTrust) !== null && _cookieConsentOptions !== void 0 && _cookieConsentOptions.enabled) {
          // This is P1. When we have an ui in source side to turn on/off of cookie consent
          // if (sourceConfig &&
          //     sourceConfig.cookieConsentManager &&
          // sourceConfig.cookieConsentManager.oneTrust &&
          // sourceConfig.cookieConsentManager.oneTrustenabled) {
          return new OneTrust(); // }
        }

        return null;
      }
    }]);

    return CookieConsentFactory;
  }();

  var queryDefaults = {
    trait: "ajs_trait_",
    prop: "ajs_prop_"
  }; // https://unpkg.com/test-rudder-sdk@1.0.5/dist/browser.js

  /**
   * Add the rudderelement object to flush queue
   *
   * @param {RudderElement} rudderElement
   */

  function enqueue(rudderElement, type) {
    if (!this.eventRepository) {
      this.eventRepository = eventRepository;
    }

    this.eventRepository.enqueue(rudderElement, type);
  }
  /**
   * class responsible for handling core
   * event tracking functionalities
   */


  var Analytics = /*#__PURE__*/function () {
    /**
     * Creates an instance of Analytics.
     * @memberof Analytics
     */
    function Analytics() {
      _classCallCheck(this, Analytics);

      this.autoTrackHandlersRegistered = false;
      this.autoTrackFeatureEnabled = false;
      this.initialized = false;
      this.areEventsReplayed = false;
      this.trackValues = [];
      this.eventsBuffer = [];
      this.clientIntegrations = [];
      this.loadOnlyIntegrations = {};
      this.clientIntegrationObjects = undefined;
      this.successfullyLoadedIntegration = [];
      this.failedToBeLoadedIntegration = [];
      this.toBeProcessedArray = [];
      this.toBeProcessedByIntegrationArray = [];
      this.storage = Storage$1;
      this.eventRepository = eventRepository;
      this.sendAdblockPage = false;
      this.sendAdblockPageOptions = {};
      this.clientSuppliedCallbacks = {};

      this.readyCallback = function () {};

      this.executeReadyCallback = undefined;
      this.methodToCallbackMapping = {
        syncPixel: "syncPixelCallback"
      };
      this.loaded = false;
      this.loadIntegration = true;
      this.cookieConsentOptions = {};
    }
    /**
     * initialize the user after load config
     */


    _createClass(Analytics, [{
      key: "initializeUser",
      value: function initializeUser() {
        this.userId = this.storage.getUserId() != undefined ? this.storage.getUserId() : "";
        this.userTraits = this.storage.getUserTraits() != undefined ? this.storage.getUserTraits() : {};
        this.groupId = this.storage.getGroupId() != undefined ? this.storage.getGroupId() : "";
        this.groupTraits = this.storage.getGroupTraits() != undefined ? this.storage.getGroupTraits() : {};
        this.anonymousId = this.getAnonymousId(); // save once for storing older values to encrypted

        this.storage.setUserId(this.userId);
        this.storage.setAnonymousId(this.anonymousId);
        this.storage.setGroupId(this.groupId);
        this.storage.setUserTraits(this.userTraits);
        this.storage.setGroupTraits(this.groupTraits);
      }
    }, {
      key: "setInitialPageProperties",
      value: function setInitialPageProperties() {
        var initialReferrer = this.storage.getInitialReferrer();
        var initialReferringDomain = this.storage.getInitialReferringDomain();

        if (initialReferrer == null && initialReferringDomain == null) {
          initialReferrer = getReferrer();
          initialReferringDomain = getReferringDomain(initialReferrer);
          this.storage.setInitialReferrer(initialReferrer);
          this.storage.setInitialReferringDomain(initialReferringDomain);
        }
      }
      /**
       * Process the response from control plane and
       * call initialize for integrations
       *
       * @param {*} status
       * @param {*} response
       * @memberof Analytics
       */

    }, {
      key: "processResponse",
      value: function processResponse(status, response) {
        try {
          logger.debug("===in process response=== ".concat(status));

          if (typeof response === "string") {
            response = JSON.parse(response);
          }

          if (response.source.useAutoTracking && !this.autoTrackHandlersRegistered) {
            this.autoTrackFeatureEnabled = true;
            addDomEventHandlers(this);
            this.autoTrackHandlersRegistered = true;
          }

          response.source.destinations.forEach(function (destination, index) {
            logger.debug("Destination ".concat(index, " Enabled? ").concat(destination.enabled, " Type: ").concat(destination.destinationDefinition.name, " Use Native SDK? true"));

            if (destination.enabled) {
              this.clientIntegrations.push({
                name: destination.destinationDefinition.name,
                config: destination.config
              });
            }
          }, this);
          logger.debug("this.clientIntegrations: ", this.clientIntegrations); // intersection of config-plane native sdk destinations with sdk load time destination list

          this.clientIntegrations = findAllEnabledDestinations(this.loadOnlyIntegrations, this.clientIntegrations);
          var cookieConsent; // Call the cookie consent factory to initialize and return the type of cookie
          // consent being set. For now we only support OneTrust.

          try {
            cookieConsent = CookieConsentFactory.initialize(this.cookieConsentOptions);
          } catch (e) {
            logger.error(e);
          } // If cookie consent object is return we filter according to consents given by user
          // else we do not consider any filtering for cookie consent.


          this.clientIntegrations = this.clientIntegrations.filter(function (intg) {
            return integrations[intg.name] != undefined && (!cookieConsent || // check if cookie consent object is present and then do filtering
            cookieConsent && cookieConsent.isEnabled(intg.config));
          });
          this.init(this.clientIntegrations);
        } catch (error) {
          handleError(error);
          logger.debug("===handling config BE response processing error===");
          logger.debug("autoTrackHandlersRegistered", this.autoTrackHandlersRegistered);

          if (this.autoTrackFeatureEnabled && !this.autoTrackHandlersRegistered) {
            addDomEventHandlers(this);
            this.autoTrackHandlersRegistered = true;
          }
        }
      }
      /**
       * Initialize integrations by addinfg respective scripts
       * keep the instances reference in core
       *
       * @param {*} intgArray
       * @returns
       * @memberof Analytics
       */

    }, {
      key: "init",
      value: function init(intgArray) {
        var _this = this;

        var self = this;
        logger.debug("supported intgs ", integrations); // this.clientIntegrationObjects = [];

        if (!intgArray || intgArray.length == 0) {
          if (this.readyCallback) {
            this.readyCallback();
          }

          this.toBeProcessedByIntegrationArray = [];
          return;
        }

        var intgInstance;
        intgArray.forEach(function (intg) {
          try {
            logger.debug("[Analytics] init :: trying to initialize integration name:: ", intg.name);
            var intgClass = integrations[intg.name];
            var destConfig = intg.config;
            intgInstance = new intgClass(destConfig, self);
            intgInstance.init();
            logger.debug("initializing destination: ", intg);

            _this.isInitialized(intgInstance).then(_this.replayEvents);
          } catch (e) {
            logger.error("[Analytics] initialize integration (integration.init()) failed :: ", intg.name);

            _this.failedToBeLoadedIntegration.push(intgInstance);
          }
        });
      } // eslint-disable-next-line class-methods-use-this

    }, {
      key: "replayEvents",
      value: function replayEvents(object) {
        if (object.successfullyLoadedIntegration.length + object.failedToBeLoadedIntegration.length === object.clientIntegrations.length && !object.areEventsReplayed) {
          logger.debug("===replay events called====", " successfully loaded count: ", object.successfullyLoadedIntegration.length, " failed loaded count: ", object.failedToBeLoadedIntegration.length); // eslint-disable-next-line no-param-reassign

          object.clientIntegrationObjects = []; // eslint-disable-next-line no-param-reassign

          object.clientIntegrationObjects = object.successfullyLoadedIntegration;
          logger.debug("==registering after callback===", " after to be called after count : ", object.clientIntegrationObjects.length);
          object.executeReadyCallback = after_1(object.clientIntegrationObjects.length, object.readyCallback);
          logger.debug("==registering ready callback===");
          object.on("ready", object.executeReadyCallback);
          object.clientIntegrationObjects.forEach(function (intg) {
            logger.debug("===looping over each successful integration====");

            if (!intg.isReady || intg.isReady()) {
              logger.debug("===letting know I am ready=====", intg.name);
              object.emit("ready");
            }
          });

          if (object.toBeProcessedByIntegrationArray.length > 0) {
            // send the queued events to the fetched integration
            object.toBeProcessedByIntegrationArray.forEach(function (event) {
              var methodName = event[0];
              event.shift(); // convert common names to sdk identified name

              if (Object.keys(event[0].message.integrations).length > 0) {
                tranformToRudderNames(event[0].message.integrations);
              } // if not specified at event level, All: true is default


              var clientSuppliedIntegrations = event[0].message.integrations; // get intersection between config plane native enabled destinations
              // (which were able to successfully load on the page) vs user supplied integrations

              var succesfulLoadedIntersectClientSuppliedIntegrations = findAllEnabledDestinations(clientSuppliedIntegrations, object.clientIntegrationObjects); // send to all integrations now from the 'toBeProcessedByIntegrationArray' replay queue

              for (var i = 0; i < succesfulLoadedIntersectClientSuppliedIntegrations.length; i += 1) {
                try {
                  if (!succesfulLoadedIntersectClientSuppliedIntegrations[i].isFailed || !succesfulLoadedIntersectClientSuppliedIntegrations[i].isFailed()) {
                    if (succesfulLoadedIntersectClientSuppliedIntegrations[i][methodName]) {
                      var sendEvent = !object.IsEventBlackListed(event[0].message.event, succesfulLoadedIntersectClientSuppliedIntegrations[i].name); // Block the event if it is blacklisted for the device-mode destination

                      if (sendEvent) {
                        var _succesfulLoadedInter;

                        var clonedBufferEvent = lodash_clonedeep(event);

                        (_succesfulLoadedInter = succesfulLoadedIntersectClientSuppliedIntegrations[i])[methodName].apply(_succesfulLoadedInter, _toConsumableArray(clonedBufferEvent));
                      }
                    }
                  }
                } catch (error) {
                  handleError(error);
                }
              }
            });
            object.toBeProcessedByIntegrationArray = [];
          }

          object.areEventsReplayed = true;
        }
      }
    }, {
      key: "pause",
      value: function pause(time) {
        return new Promise(function (resolve) {
          setTimeout(resolve, time);
        });
      }
    }, {
      key: "isInitialized",
      value: function isInitialized(instance) {
        var _this2 = this;

        var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return new Promise(function (resolve) {
          if (instance.isLoaded()) {
            logger.debug("===integration loaded successfully====", instance.name);

            _this2.successfullyLoadedIntegration.push(instance);

            return resolve(_this2);
          }

          if (time >= MAX_WAIT_FOR_INTEGRATION_LOAD) {
            logger.debug("====max wait over====");

            _this2.failedToBeLoadedIntegration.push(instance);

            return resolve(_this2);
          }

          _this2.pause(INTEGRATION_LOAD_CHECK_INTERVAL).then(function () {
            logger.debug("====after pause, again checking====");
            return _this2.isInitialized(instance, time + INTEGRATION_LOAD_CHECK_INTERVAL).then(resolve);
          });
        });
      }
      /**
       * Process page params and forward to page call
       *
       * @param {*} category
       * @param {*} name
       * @param {*} properties
       * @param {*} options
       * @param {*} callback
       * @memberof Analytics
       */

    }, {
      key: "page",
      value: function page(category, name, properties, options, callback) {
        if (!this.loaded) return;
        if (typeof options === "function") callback = options, options = null;
        if (typeof properties === "function") callback = properties, options = properties = null;
        if (typeof name === "function") callback = name, options = properties = name = null;
        if (_typeof(category) === "object" && category != null && category != undefined) options = name, properties = category, name = category = null;
        if (_typeof(name) === "object" && name != null && name != undefined) options = properties, properties = name, name = null;
        if (typeof category === "string" && typeof name !== "string") name = category, category = null;

        if (this.sendAdblockPage && category != "RudderJS-Initiated") {
          this.sendSampleRequest();
        }

        this.processPage(category, name, properties, options, callback);
      }
      /**
       * Process track params and forward to track call
       *
       * @param {*} event
       * @param {*} properties
       * @param {*} options
       * @param {*} callback
       * @memberof Analytics
       */

    }, {
      key: "track",
      value: function track(event, properties, options, callback) {
        if (!this.loaded) return;
        if (typeof options === "function") callback = options, options = null;
        if (typeof properties === "function") callback = properties, options = null, properties = null;
        this.processTrack(event, properties, options, callback);
      }
      /**
       * Process identify params and forward to indentify  call
       *
       * @param {*} userId
       * @param {*} traits
       * @param {*} options
       * @param {*} callback
       * @memberof Analytics
       */

    }, {
      key: "identify",
      value: function identify(userId, traits, options, callback) {
        if (!this.loaded) return;
        if (typeof options === "function") callback = options, options = null;
        if (typeof traits === "function") callback = traits, options = null, traits = null;
        if (_typeof(userId) === "object") options = traits, traits = userId, userId = this.userId;
        this.processIdentify(userId, traits, options, callback);
      }
      /**
       *
       * @param {*} to
       * @param {*} from
       * @param {*} options
       * @param {*} callback
       */

    }, {
      key: "alias",
      value: function alias(to, from, options, callback) {
        if (!this.loaded) return;
        if (typeof options === "function") callback = options, options = null;
        if (typeof from === "function") callback = from, options = null, from = null;
        if (_typeof(from) === "object") options = from, from = null;
        var rudderElement = new RudderElementBuilder().setType("alias").build();
        rudderElement.message.previousId = from || (this.userId ? this.userId : this.getAnonymousId());
        rudderElement.message.userId = to;
        this.processAndSendDataToDestinations("alias", rudderElement, options, callback);
      }
      /**
       *
       * @param {*} to
       * @param {*} from
       * @param {*} options
       * @param {*} callback
       */

    }, {
      key: "group",
      value: function group(groupId, traits, options, callback) {
        if (!this.loaded) return;
        if (!arguments.length) return;
        if (typeof options === "function") callback = options, options = null;
        if (typeof traits === "function") callback = traits, options = null, traits = null;
        if (_typeof(groupId) === "object") options = traits, traits = groupId, groupId = this.groupId;
        this.groupId = groupId;
        this.storage.setGroupId(this.groupId);
        var rudderElement = new RudderElementBuilder().setType("group").build();

        if (traits) {
          for (var key in traits) {
            this.groupTraits[key] = traits[key];
          }
        } else {
          this.groupTraits = {};
        }

        this.storage.setGroupTraits(this.groupTraits);
        this.processAndSendDataToDestinations("group", rudderElement, options, callback);
      }
      /**
       * Send page call to Rudder BE and to initialized integrations
       *
       * @param {*} category
       * @param {*} name
       * @param {*} properties
       * @param {*} options
       * @param {*} callback
       * @memberof Analytics
       */

    }, {
      key: "processPage",
      value: function processPage(category, name, properties, options, callback) {
        var rudderElement = new RudderElementBuilder().setType("page").build();

        if (!properties) {
          properties = {};
        }

        if (name) {
          rudderElement.message.name = name;
          properties.name = name;
        }

        if (category) {
          rudderElement.message.category = category;
          properties.category = category;
        }

        rudderElement.message.properties = this.getPageProperties(properties); // properties;

        this.trackPage(rudderElement, options, callback);
      }
      /**
       * Send track call to Rudder BE and to initialized integrations
       *
       * @param {*} event
       * @param {*} properties
       * @param {*} options
       * @param {*} callback
       * @memberof Analytics
       */

    }, {
      key: "processTrack",
      value: function processTrack(event, properties, options, callback) {
        var rudderElement = new RudderElementBuilder().setType("track").build();

        if (event) {
          rudderElement.setEventName(event);
        }

        if (properties) {
          rudderElement.setProperty(properties);
        } else {
          rudderElement.setProperty({});
        }

        this.trackEvent(rudderElement, options, callback);
      }
      /**
       * Send identify call to Rudder BE and to initialized integrations
       *
       * @param {*} userId
       * @param {*} traits
       * @param {*} options
       * @param {*} callback
       * @memberof Analytics
       */

    }, {
      key: "processIdentify",
      value: function processIdentify(userId, traits, options, callback) {
        if (userId && this.userId && userId !== this.userId) {
          this.reset();
        }

        this.userId = userId;
        this.storage.setUserId(this.userId);
        var rudderElement = new RudderElementBuilder().setType("identify").build();

        if (traits) {
          for (var key in traits) {
            this.userTraits[key] = traits[key];
          }

          this.storage.setUserTraits(this.userTraits);
        }

        this.identifyUser(rudderElement, options, callback);
      }
      /**
       * Identify call supporting rudderelement from builder
       *
       * @param {*} rudderElement
       * @param {*} callback
       * @memberof Analytics
       */

    }, {
      key: "identifyUser",
      value: function identifyUser(rudderElement, options, callback) {
        if (rudderElement.message.userId) {
          this.userId = rudderElement.message.userId;
          this.storage.setUserId(this.userId);
        }

        if (rudderElement && rudderElement.message && rudderElement.message.context && rudderElement.message.context.traits) {
          this.userTraits = _objectSpread2({}, rudderElement.message.context.traits);
          this.storage.setUserTraits(this.userTraits);
        }

        this.processAndSendDataToDestinations("identify", rudderElement, options, callback);
      }
      /**
       * Page call supporting rudderelement from builder
       *
       * @param {*} rudderElement
       * @param {*} callback
       * @memberof Analytics
       */

    }, {
      key: "trackPage",
      value: function trackPage(rudderElement, options, callback) {
        this.processAndSendDataToDestinations("page", rudderElement, options, callback);
      }
      /**
       * Track call supporting rudderelement from builder
       *
       * @param {*} rudderElement
       * @param {*} callback
       * @memberof Analytics
       */

    }, {
      key: "trackEvent",
      value: function trackEvent(rudderElement, options, callback) {
        this.processAndSendDataToDestinations("track", rudderElement, options, callback);
      }
    }, {
      key: "IsEventBlackListed",
      value: function IsEventBlackListed(eventName, intgName) {
        if (!eventName || !(typeof eventName === "string")) {
          return false;
        }

        var sdkIntgName = commonNames[intgName];
        var intg = this.clientIntegrations.find(function (intg) {
          return intg.name === sdkIntgName;
        });
        var _intg$config = intg.config,
            blacklistedEvents = _intg$config.blacklistedEvents,
            whitelistedEvents = _intg$config.whitelistedEvents,
            eventFilteringOption = _intg$config.eventFilteringOption;

        if (!eventFilteringOption) {
          return false;
        }

        var formattedEventName = eventName.trim().toUpperCase();

        switch (eventFilteringOption) {
          // disabled filtering
          case "disable":
            return false;
          // Blacklist is choosen for filtering events

          case "blacklistedEvents":
            if (Array.isArray(blacklistedEvents)) {
              return blacklistedEvents.find(function (eventObj) {
                return eventObj.eventName.trim().toUpperCase() === formattedEventName;
              }) === undefined ? false : true;
            } else {
              return false;
            }

          // Whitelist is choosen for filtering events

          case "whitelistedEvents":
            if (Array.isArray(whitelistedEvents)) {
              return whitelistedEvents.find(function (eventObj) {
                return eventObj.eventName.trim().toUpperCase() === formattedEventName;
              }) === undefined ? true : false;
            } else {
              return true;
            }

          default:
            return false;
        }
      }
      /**
       * Process and send data to destinations along with rudder BE
       *
       * @param {*} type
       * @param {*} rudderElement
       * @param {*} callback
       * @memberof Analytics
       */

    }, {
      key: "processAndSendDataToDestinations",
      value: function processAndSendDataToDestinations(type, rudderElement, options, callback) {
        var _this3 = this;

        try {
          if (!this.anonymousId) {
            this.setAnonymousId();
          } // assign page properties to context
          // rudderElement.message.context.page = getDefaultPageProperties();


          rudderElement.message.context.traits = _objectSpread2({}, this.userTraits);
          logger.debug("anonymousId: ", this.anonymousId);
          rudderElement.message.anonymousId = this.anonymousId;
          rudderElement.message.userId = rudderElement.message.userId ? rudderElement.message.userId : this.userId;

          if (type == "group") {
            if (this.groupId) {
              rudderElement.message.groupId = this.groupId;
            }

            if (this.groupTraits) {
              rudderElement.message.traits = _objectSpread2({}, this.groupTraits);
            }
          }

          this.processOptionsParam(rudderElement, options);
          logger.debug(JSON.stringify(rudderElement)); // check for reserved keys and log

          checkReservedKeywords(rudderElement.message, type); // structure user supplied integrations object to rudder format

          if (Object.keys(rudderElement.message.integrations).length > 0) {
            tranformToRudderNames(rudderElement.message.integrations);
          } // if not specified at event level, All: true is default


          var clientSuppliedIntegrations = rudderElement.message.integrations; // get intersection between config plane native enabled destinations
          // (which were able to successfully load on the page) vs user supplied integrations

          var succesfulLoadedIntersectClientSuppliedIntegrations = findAllEnabledDestinations(clientSuppliedIntegrations, this.clientIntegrationObjects); // try to first send to all integrations, if list populated from BE

          try {
            succesfulLoadedIntersectClientSuppliedIntegrations.forEach(function (obj) {
              if (!obj.isFailed || !obj.isFailed()) {
                if (obj[type]) {
                  var sendEvent = !_this3.IsEventBlackListed(rudderElement.message.event, obj.name); // Block the event if it is blacklisted for the device-mode destination

                  if (sendEvent) {
                    var clonedRudderElement = lodash_clonedeep(rudderElement);
                    obj[type](clonedRudderElement);
                  }
                }
              }
            });
          } catch (err) {
            handleError({
              message: "[sendToNative]:".concat(err)
            });
          } // config plane native enabled destinations, still not completely loaded
          // in the page, add the events to a queue and process later


          if (!this.clientIntegrationObjects) {
            logger.debug("pushing in replay queue"); // new event processing after analytics initialized  but integrations not fetched from BE

            this.toBeProcessedByIntegrationArray.push([type, rudderElement]);
          } // convert integrations object to server identified names, kind of hack now!


          transformToServerNames(rudderElement.message.integrations); // self analytics process, send to rudder

          enqueue.call(this, rudderElement, type);
          logger.debug("".concat(type, " is called "));

          if (callback) {
            callback();
          }
        } catch (error) {
          handleError(error);
        }
      }
      /**
       * add campaign parsed details under context
       * @param {*} rudderElement
       */

    }, {
      key: "addCampaignInfo",
      value: function addCampaignInfo(rudderElement) {
        var _getDefaultPageProper = getDefaultPageProperties(),
            search = _getDefaultPageProper.search;

        var campaign = lib(search);

        if (rudderElement.message.context && _typeof(rudderElement.message.context) === "object") {
          rudderElement.message.context.campaign = campaign;
        }
      }
      /**
       * process options parameter
       * Apart from top level keys merge everyting under context
       * context.page's default properties are overriden by same keys of
       * provided properties in case of page call
       *
       * @param {*} rudderElement
       * @param {*} options
       * @memberof Analytics
       */

    }, {
      key: "processOptionsParam",
      value: function processOptionsParam(rudderElement, options) {
        var _rudderElement$messag = rudderElement.message,
            type = _rudderElement$messag.type,
            properties = _rudderElement$messag.properties;
        this.addCampaignInfo(rudderElement); // assign page properties to context.page

        rudderElement.message.context.page = type == "page" ? this.getContextPageProperties(properties) : this.getContextPageProperties();
        var toplevelElements = ["integrations", "anonymousId", "originalTimestamp"];

        for (var key in options) {
          if (toplevelElements.includes(key)) {
            rudderElement.message[key] = options[key];
          } else if (key !== "context") {
            rudderElement.message.context = lodash_merge(rudderElement.message.context, _defineProperty({}, key, options[key]));
          } else if (_typeof(options[key]) === "object" && options[key] != null) {
            rudderElement.message.context = lodash_merge(rudderElement.message.context, _objectSpread2({}, options[key]));
          } else {
            logger.error("[Analytics: processOptionsParam] context passed in options is not object");
          }
        }
      }
    }, {
      key: "getPageProperties",
      value: function getPageProperties(properties, options) {
        var defaultPageProperties = getDefaultPageProperties();
        var optionPageProperties = options && options.page ? options.page : {};

        for (var key in defaultPageProperties) {
          if (properties[key] === undefined) {
            properties[key] = optionPageProperties[key] || defaultPageProperties[key];
          }
        }

        return properties;
      } // Assign page properties to context.page if the same property is not provided under context.page

    }, {
      key: "getContextPageProperties",
      value: function getContextPageProperties(properties) {
        var defaultPageProperties = getDefaultPageProperties();
        var contextPageProperties = {};

        for (var key in defaultPageProperties) {
          contextPageProperties[key] = properties && properties[key] ? properties[key] : defaultPageProperties[key];
        }

        return contextPageProperties;
      }
      /**
       * Clear user information
       *
       * @memberof Analytics
       */

    }, {
      key: "reset",
      value: function reset(flag) {
        if (!this.loaded) return;

        if (flag) {
          this.anonymousId = "";
        }

        this.userId = "";
        this.userTraits = {};
        this.groupId = "";
        this.groupTraits = {};
        this.storage.clear(flag);
      }
    }, {
      key: "getAnonymousId",
      value: function getAnonymousId() {
        // if (!this.loaded) return;
        this.anonymousId = this.storage.getAnonymousId();

        if (!this.anonymousId) {
          this.setAnonymousId();
        }

        return this.anonymousId;
      }
    }, {
      key: "getUserId",
      value: function getUserId() {
        this.userId = this.storage.getUserId();
        return this.userId;
      }
    }, {
      key: "getUserTraits",
      value: function getUserTraits() {
        return this.userTraits;
      }
      /**
       * Sets anonymous id in the followin precedence:
       * 1. anonymousId: Id directly provided to the function.
       * 2. rudderAmpLinkerParm: value generated from linker query parm (rudderstack)
       *    using praseLinker util.
       * 3. generateUUID: A new uniquie id is generated and assigned.
       *
       * @param {string} anonymousId
       * @param {string} rudderAmpLinkerParm
       */

    }, {
      key: "setAnonymousId",
      value: function setAnonymousId(anonymousId, rudderAmpLinkerParm) {
        // if (!this.loaded) return;
        var parsedAnonymousIdObj = rudderAmpLinkerParm ? parseLinker(rudderAmpLinkerParm) : null;
        var parsedAnonymousId = parsedAnonymousIdObj ? parsedAnonymousIdObj.rs_amp_id : null;
        this.anonymousId = anonymousId || parsedAnonymousId || generateUUID();
        this.storage.setAnonymousId(this.anonymousId);
      }
    }, {
      key: "isValidWriteKey",
      value: function isValidWriteKey(writeKey) {
        if (!writeKey || typeof writeKey !== "string" || writeKey.trim().length == 0) {
          return false;
        }

        return true;
      }
    }, {
      key: "isValidServerUrl",
      value: function isValidServerUrl(serverUrl) {
        if (!serverUrl || typeof serverUrl !== "string" || serverUrl.trim().length == 0) {
          return false;
        }

        return true;
      }
      /**
       * Load after polyfills are loaded
       * @param {*} writeKey
       * @param {*} serverUrl
       * @param {*} options
       * @returns
       */

    }, {
      key: "loadAfterPolyfill",
      value: function loadAfterPolyfill(writeKey, serverUrl, options) {
        var _this4 = this;

        if (options && options.cookieConsentManager) this.cookieConsentOptions = lodash_clonedeep(options.cookieConsentManager);
        var configUrl = CONFIG_URL;

        if (!this.isValidWriteKey(writeKey) || !this.isValidServerUrl(serverUrl)) {
          handleError({
            message: "[Analytics] load:: Unable to load due to wrong writeKey or serverUrl"
          });
          throw Error("failed to initialize");
        }

        var storageOptions = {};

        if (options && options.logLevel) {
          logger.setLogLevel(options.logLevel);
        }

        if (options && options.setCookieDomain) {
          storageOptions = _objectSpread2(_objectSpread2({}, storageOptions), {}, {
            domain: options.setCookieDomain
          });
        }

        if (options && options.secureCookie) {
          storageOptions = _objectSpread2(_objectSpread2({}, storageOptions), {}, {
            secure: options.secureCookie
          });
        }

        this.storage.options(storageOptions);

        if (options && options.integrations) {
          _extends(this.loadOnlyIntegrations, options.integrations);

          tranformToRudderNames(this.loadOnlyIntegrations);
        }

        if (options && options.configUrl) {
          configUrl = getUserProvidedConfigUrl(options.configUrl);
        }

        if (options && options.sendAdblockPage) {
          this.sendAdblockPage = true;
        }

        if (options && options.sendAdblockPageOptions) {
          if (_typeof(options.sendAdblockPageOptions) === "object") {
            this.sendAdblockPageOptions = options.sendAdblockPageOptions;
          }
        }

        if (options && options.clientSuppliedCallbacks) {
          // convert to rudder recognised method names
          var tranformedCallbackMapping = {};
          Object.keys(this.methodToCallbackMapping).forEach(function (methodName) {
            if (_this4.methodToCallbackMapping.hasOwnProperty(methodName)) {
              if (options.clientSuppliedCallbacks[_this4.methodToCallbackMapping[methodName]]) {
                tranformedCallbackMapping[methodName] = options.clientSuppliedCallbacks[_this4.methodToCallbackMapping[methodName]];
              }
            }
          });

          _extends(this.clientSuppliedCallbacks, tranformedCallbackMapping);

          this.registerCallbacks(true);
        }

        if (options && options.loadIntegration != undefined) {
          this.loadIntegration = !!options.loadIntegration;
        }

        this.eventRepository.initialize(writeKey, serverUrl, options);
        this.initializeUser();
        this.setInitialPageProperties();
        this.loaded = true;

        if (options && options.valTrackingList && options.valTrackingList.push == Array.prototype.push) {
          this.trackValues = options.valTrackingList;
        }

        if (options && options.useAutoTracking) {
          this.autoTrackFeatureEnabled = true;

          if (this.autoTrackFeatureEnabled && !this.autoTrackHandlersRegistered) {
            addDomEventHandlers(this);
            this.autoTrackHandlersRegistered = true;
            logger.debug("autoTrackHandlersRegistered", this.autoTrackHandlersRegistered);
          }
        }

        function errorHandler(error) {
          handleError(error);

          if (this.autoTrackFeatureEnabled && !this.autoTrackHandlersRegistered) {
            addDomEventHandlers(this);
          }
        }

        if (options && options.getSourceConfig) {
          if (typeof options.getSourceConfig !== "function") {
            handleError('option "getSourceConfig" must be a function');
          } else {
            var res = options.getSourceConfig();

            if (res instanceof Promise) {
              res.then(function (res) {
                return _this4.processResponse(200, res);
              }).catch(errorHandler);
            } else {
              this.processResponse(200, res);
            }

            processDataInAnalyticsArray(this);
          }

          return;
        }

        try {
          getJSONTrimmed(this, configUrl, writeKey, this.processResponse);
        } catch (error) {
          errorHandler(error);
        }

        processDataInAnalyticsArray(this);
      }
      /**
       * Call control pane to get client configs
       *
       * @param {*} writeKey
       * @memberof Analytics
       */

    }, {
      key: "load",
      value: function load(writeKey, serverUrl, options) {
        // logger.debug("inside load ");
        if (this.loaded) return; // check if the below features are available in the browser or not
        // If not present dynamically load from the polyfill cdn

        if (!String.prototype.endsWith || !String.prototype.startsWith || !String.prototype.includes || !Array.prototype.find || !Array.prototype.includes || !Promise || !Object.entries) {
          ScriptLoader("polyfill", POLYFILL_URL);
          var self = this;
          var interval = setInterval(function () {
            // check if the polyfill is loaded
            if (window.hasOwnProperty("polyfill")) {
              clearInterval(interval);
              self.loadAfterPolyfill(writeKey, serverUrl, options);
            }
          }, 100);
          setTimeout(function () {
            clearInterval(interval);
          }, MAX_WAIT_FOR_INTEGRATION_LOAD);
        } else {
          this.loadAfterPolyfill(writeKey, serverUrl, options);
        }
      }
    }, {
      key: "ready",
      value: function ready(callback) {
        if (!this.loaded) return;

        if (typeof callback === "function") {
          this.readyCallback = callback;
          return;
        }

        logger.error("ready callback is not a function");
      }
    }, {
      key: "initializeCallbacks",
      value: function initializeCallbacks() {
        var _this5 = this;

        Object.keys(this.methodToCallbackMapping).forEach(function (methodName) {
          if (_this5.methodToCallbackMapping.hasOwnProperty(methodName)) {
            _this5.on(methodName, function () {});
          }
        });
      }
    }, {
      key: "registerCallbacks",
      value: function registerCallbacks(calledFromLoad) {
        var _this6 = this;

        if (!calledFromLoad) {
          Object.keys(this.methodToCallbackMapping).forEach(function (methodName) {
            if (_this6.methodToCallbackMapping.hasOwnProperty(methodName)) {
              if (window.rudderanalytics) {
                if (typeof window.rudderanalytics[_this6.methodToCallbackMapping[methodName]] === "function") {
                  _this6.clientSuppliedCallbacks[methodName] = window.rudderanalytics[_this6.methodToCallbackMapping[methodName]];
                }
              } // let callback =
              //   ? typeof window.rudderanalytics[
              //       this.methodToCallbackMapping[methodName]
              //     ] == "function"
              //     ? window.rudderanalytics[this.methodToCallbackMapping[methodName]]
              //     : () => {}
              //   : () => {};
              // logger.debug("registerCallbacks", methodName, callback);
              // this.on(methodName, callback);

            }
          });
        }

        Object.keys(this.clientSuppliedCallbacks).forEach(function (methodName) {
          if (_this6.clientSuppliedCallbacks.hasOwnProperty(methodName)) {
            logger.debug("registerCallbacks", methodName, _this6.clientSuppliedCallbacks[methodName]);

            _this6.on(methodName, _this6.clientSuppliedCallbacks[methodName]);
          }
        });
      }
    }, {
      key: "sendSampleRequest",
      value: function sendSampleRequest() {
        ScriptLoader("ad-block", "//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js");
      }
      /**
       * parse the given query string into usable Rudder object
       * @param {*} query
       */

    }, {
      key: "parseQueryString",
      value: function parseQueryString(query) {
        function getTraitsFromQueryObject(qObj) {
          var traits = {};
          Object.keys(qObj).forEach(function (key) {
            if (key.substr(0, queryDefaults.trait.length) == queryDefaults.trait) {
              traits[key.substr(queryDefaults.trait.length)] = qObj[key];
            }
          });
          return traits;
        }

        function getEventPropertiesFromQueryObject(qObj) {
          var props = {};
          Object.keys(qObj).forEach(function (key) {
            if (key.substr(0, queryDefaults.prop.length) == queryDefaults.prop) {
              props[key.substr(queryDefaults.prop.length)] = qObj[key];
            }
          });
          return props;
        }

        var returnObj = {};
        var queryObject = componentQuerystring.parse(query);
        var userTraits = getTraitsFromQueryObject(queryObject);
        var eventProps = getEventPropertiesFromQueryObject(queryObject);

        if (queryObject.ajs_uid) {
          returnObj.userId = queryObject.ajs_uid;
          returnObj.traits = userTraits;
        }

        if (queryObject.ajs_aid) {
          returnObj.anonymousId = queryObject.ajs_aid;
        }

        if (queryObject.ajs_event) {
          returnObj.event = queryObject.ajs_event;
          returnObj.properties = eventProps;
        }

        return returnObj;
      }
    }]);

    return Analytics;
  }();

  function pushQueryStringDataToAnalyticsArray(obj) {
    if (obj.anonymousId) {
      if (obj.userId) {
        instance.toBeProcessedArray.push(["setAnonymousId", obj.anonymousId], ["identify", obj.userId, obj.traits]);
      } else {
        instance.toBeProcessedArray.push(["setAnonymousId", obj.anonymousId]);
      }
    } else if (obj.userId) {
      instance.toBeProcessedArray.push(["identify", obj.userId, obj.traits]);
    }

    if (obj.event) {
      instance.toBeProcessedArray.push(["track", obj.event, obj.properties]);
    }
  }

  function processDataInAnalyticsArray(analytics) {
    if (instance.loaded) {
      for (var i = 0; i < analytics.toBeProcessedArray.length; i++) {
        var event = _toConsumableArray(analytics.toBeProcessedArray[i]);

        var method = event[0];
        event.shift();
        logger.debug("=====from analytics array, calling method:: ", method);
        analytics[method].apply(analytics, _toConsumableArray(event));
      }

      instance.toBeProcessedArray = [];
    }
  }

  var instance = new Analytics();
  componentEmitter(instance);
  window.addEventListener("error", function (e) {
    handleError(e, instance);
  }, true); // if (true) {
  // test for adblocker
  // instance.sendSampleRequest()
  // initialize supported callbacks

  instance.initializeCallbacks(); // register supported callbacks

  instance.registerCallbacks(false);
  var eventsPushedAlready = !!window.rudderanalytics && window.rudderanalytics.push == Array.prototype.push;
  var argumentsArray = window.rudderanalytics;

  while (argumentsArray && argumentsArray[0] && argumentsArray[0][0] !== "load") {
    argumentsArray.shift();
  }

  if (argumentsArray && argumentsArray.length > 0 && argumentsArray[0][0] === "load") {
    var method = argumentsArray[0][0];
    argumentsArray[0].shift();
    logger.debug("=====from init, calling method:: ", method);
    instance[method].apply(instance, _toConsumableArray(argumentsArray[0]));
    argumentsArray.shift();
  } // once loaded, parse querystring of the page url to send events


  var parsedQueryObject = instance.parseQueryString(window.location.search);
  pushQueryStringDataToAnalyticsArray(parsedQueryObject);

  if (argumentsArray && argumentsArray.length > 0) {
    for (var i$1 = 0; i$1 < argumentsArray.length; i$1++) {
      instance.toBeProcessedArray.push(argumentsArray[i$1]);
    }
  }

  if (eventsPushedAlready) {
    processDataInAnalyticsArray(instance);
  } // }


  var ready = instance.ready.bind(instance);
  var identify = instance.identify.bind(instance);
  var page = instance.page.bind(instance);
  var track = instance.track.bind(instance);
  var alias = instance.alias.bind(instance);
  var group = instance.group.bind(instance);
  var reset = instance.reset.bind(instance);
  var load = instance.load.bind(instance);
  var initialized = instance.initialized = true;
  var getUserTraits = instance.getUserTraits.bind(instance);
  var getAnonymousId = instance.getAnonymousId.bind(instance);
  var setAnonymousId = instance.setAnonymousId.bind(instance);

  exports.alias = alias;
  exports.getAnonymousId = getAnonymousId;
  exports.getUserTraits = getUserTraits;
  exports.group = group;
  exports.identify = identify;
  exports.initialized = initialized;
  exports.load = load;
  exports.page = page;
  exports.ready = ready;
  exports.reset = reset;
  exports.setAnonymousId = setAnonymousId;
  exports.track = track;

  return exports;

}({}));
